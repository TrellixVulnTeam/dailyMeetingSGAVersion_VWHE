(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/platform-browser'), require('rxjs'), require('@angular/common'), require('@angular/forms'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@angular-mdl/core', ['exports', '@angular/core', '@angular/platform-browser', 'rxjs', '@angular/common', '@angular/forms', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['angular-mdl'] = global['angular-mdl'] || {}, global['angular-mdl'].core = {}), global.ng.core, global.ng.platformBrowser, global.rxjs, global.ng.common, global.ng.forms, global.rxjs.operators));
}(this, (function (exports, i0, platformBrowser, rxjs, common, forms, operators) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var AppendViewContainerRefDirective = /** @class */ (function () {
        function AppendViewContainerRefDirective(viewRef, renderer) {
            this.viewRef = viewRef;
            this.renderer = renderer;
        }
        AppendViewContainerRefDirective.prototype.ngAfterViewInit = function () {
            this.renderer.appendChild(this.viewRef.element.nativeElement, this.viewContainerRefToAppend.element.nativeElement);
        };
        return AppendViewContainerRefDirective;
    }());
    AppendViewContainerRefDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: '[append-view-container-ref]'
                },] }
    ];
    AppendViewContainerRefDirective.ctorParameters = function () { return [
        { type: i0.ViewContainerRef },
        { type: i0.Renderer2 }
    ]; };
    AppendViewContainerRefDirective.propDecorators = {
        viewContainerRefToAppend: [{ type: i0.Input, args: ["append-view-container-ref",] }]
    };

    var NativeWebAnimationPlayer = /** @class */ (function () {
        function NativeWebAnimationPlayer(element, keyframes, duration, easing) {
            this.element = element;
            this.keyframes = keyframes;
            this.duration = duration;
            this.easing = easing;
            this.onDoneCallback = [];
        }
        NativeWebAnimationPlayer.prototype.onDone = function (fn) {
            this.onDoneCallback.push(fn);
        };
        NativeWebAnimationPlayer.prototype.play = function () {
            var _this = this;
            var animation = this.element.animate(this.keyframes, {
                duration: this.duration,
                easing: this.easing,
                fill: "forwards",
            });
            animation.addEventListener("finish", function () { return _this.onDoneCallback.forEach(function (fn) { return fn(); }); });
        };
        return NativeWebAnimationPlayer;
    }());
    var NoopAnimationPlayer = /** @class */ (function () {
        function NoopAnimationPlayer() {
            this.onDoneCallback = [];
        }
        NoopAnimationPlayer.prototype.onDone = function (fn) {
            this.onDoneCallback.push(fn);
        };
        NoopAnimationPlayer.prototype.play = function () {
            this.onDoneCallback.forEach(function (fn) { return fn(); });
        };
        return NoopAnimationPlayer;
    }());
    var Animations = /** @class */ (function () {
        function Animations() {
        }
        return Animations;
    }());
    var NativeWebAnimations = /** @class */ (function () {
        function NativeWebAnimations() {
        }
        NativeWebAnimations.prototype.animate = function (element, keyframes, duration, easing) {
            return new NativeWebAnimationPlayer(element, keyframes, duration, easing);
        };
        return NativeWebAnimations;
    }());
    var NoopWebAnimations = /** @class */ (function () {
        function NoopWebAnimations() {
        }
        NoopWebAnimations.prototype.animate = function () {
            return new NoopAnimationPlayer();
        };
        return NoopWebAnimations;
    }());

    var toBoolean = function (value) { return value != null && "" + value !== "false"; };

    /**
     * Wrapper for mdl error messages.
     */
    var MdlError = /** @class */ (function (_super) {
        __extends(MdlError, _super);
        function MdlError(value) {
            /* istanbul ignore next */
            return _super.call(this, value) || this;
        }
        return MdlError;
    }(Error));
    var MdlStructureError = /** @class */ (function (_super) {
        __extends(MdlStructureError, _super);
        function MdlStructureError(child, requiredParent) {
            /* istanbul ignore next */
            return _super.call(this, "\"" + child + "\" requires \"" + requiredParent + "\" as a parent.") || this;
        }
        return MdlStructureError;
    }(MdlError));

    var callNative = function (el, method, arg) {
        if (arg === void 0) { arg = null; }
        /* istanbul ignore next */ // if this code runs in browser this is allways true!
        if (el[method]) {
            el[method](arg);
        }
    };

    /* istanbul ignore next */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    var noop = function () { };

    var toNumber = function (value) {
        if (typeof value === "undefined") {
            return null;
        }
        else if (typeof value === "string") {
            return parseInt(value, 10);
        }
        return value;
    };

    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
    function isWebAnimationsSupported() {
        return (typeof Element !== "undefined" &&
            typeof Element.prototype.animate === "function");
    }
    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
    function instantiateSupportedAnimationDriver() {
        /* istanbul ignore next */
        if (isWebAnimationsSupported()) {
            return new NativeWebAnimations();
        }
        /* istanbul ignore next */
        return new NoopWebAnimations();
    }
    var MdlCommonsModule = /** @class */ (function () {
        function MdlCommonsModule() {
        }
        return MdlCommonsModule;
    }());
    MdlCommonsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [],
                    exports: [AppendViewContainerRefDirective],
                    declarations: [AppendViewContainerRefDirective],
                    providers: [
                        { provide: Animations, useFactory: instantiateSupportedAnimationDriver },
                    ],
                },] }
    ];

    var MdlLayoutMediatorService = /** @class */ (function () {
        function MdlLayoutMediatorService() {
            this.tabMouseoverSubject = new rxjs.Subject();
            this.tabMouseoutSubject = new rxjs.Subject();
            this.tabSelectedSubject = new rxjs.Subject();
        }
        MdlLayoutMediatorService.prototype.onTabMouseover = function () {
            return this.tabMouseoverSubject.asObservable();
        };
        MdlLayoutMediatorService.prototype.tabMouseover = function (tab) {
            this.tabMouseoverSubject.next(tab);
        };
        MdlLayoutMediatorService.prototype.onTabMouseOut = function () {
            return this.tabMouseoutSubject.asObservable();
        };
        MdlLayoutMediatorService.prototype.tabMouseout = function (tab) {
            this.tabMouseoutSubject.next(tab);
        };
        MdlLayoutMediatorService.prototype.onTabSelected = function () {
            return this.tabSelectedSubject.asObservable();
        };
        MdlLayoutMediatorService.prototype.tabSelected = function (tab) {
            this.tabSelectedSubject.next(tab);
        };
        return MdlLayoutMediatorService;
    }());
    MdlLayoutMediatorService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function MdlLayoutMediatorService_Factory() { return new MdlLayoutMediatorService(); }, token: MdlLayoutMediatorService, providedIn: "root" });
    MdlLayoutMediatorService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: "root",
                },] }
    ];

    var MdlLayoutHeaderComponent = /** @class */ (function () {
        function MdlLayoutHeaderComponent(elementRef, layoutMediatorService) {
            this.elementRef = elementRef;
            this.layoutMediatorService = layoutMediatorService;
            this.isSeamed = false;
            this.isLayoutHeader = true;
            this.isCompact = false;
            this.isAnimating = false;
            this.isRipple = true;
            this.el = elementRef.nativeElement;
        }
        Object.defineProperty(MdlLayoutHeaderComponent.prototype, "isWaterfall", {
            get: function () {
                return this.mode === "waterfall";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlLayoutHeaderComponent.prototype, "isCastingShadow", {
            get: function () {
                return this.mode === "standard" || this.isCompact;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlLayoutHeaderComponent.prototype, "isHeaderScroll", {
            get: function () {
                return this.mode === "scroll";
            },
            enumerable: false,
            configurable: true
        });
        MdlLayoutHeaderComponent.prototype.onTransitionEnd = function () {
            this.isAnimating = false;
        };
        MdlLayoutHeaderComponent.prototype.onClick = function () {
            if (this.isCompact) {
                this.isCompact = false;
                this.isAnimating = true;
            }
        };
        MdlLayoutHeaderComponent.prototype.onTabMouseover = function (tab) {
            this.layoutMediatorService.tabMouseover(tab);
        };
        MdlLayoutHeaderComponent.prototype.onTabMouseout = function (tab) {
            this.layoutMediatorService.tabMouseout(tab);
        };
        MdlLayoutHeaderComponent.prototype.tabSelected = function (tab) {
            this.layoutMediatorService.tabSelected(tab);
        };
        return MdlLayoutHeaderComponent;
    }());
    MdlLayoutHeaderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-layout-header",
                    template: "\n    <ng-content></ng-content>\n    <div\n      *ngIf=\"tabs?.toArray()?.length > 0\"\n      class=\"mdl-layout__tab-bar-container\"\n    >\n      <div class=\"mdl-layout__tab-bar is-casting-shadow\">\n        <div\n          *ngFor=\"let tab of tabs.toArray()\"\n          class=\"mdl-layout__tab\"\n          [ngClass]=\"{ 'is-active': tab.isActive }\"\n          (mouseover)=\"onTabMouseover(tab)\"\n          (mouseout)=\"onTabMouseout(tab)\"\n        >\n          <div\n            *ngIf=\"tab.titleComponent\"\n            (click)=\"tabSelected(tab)\"\n            [mdl-ripple]=\"isRipple\"\n            [append-view-container-ref]=\"tab.titleComponent.vcRef\"\n          ></div>\n          <a\n            *ngIf=\"!tab.titleComponent\"\n            href=\"javascript:void(0)\"\n            (click)=\"tabSelected(tab)\"\n            class=\"mdl-layout__tab\"\n            [ngClass]=\"{ 'is-active': tab.isActive }\"\n            [mdl-ripple]=\"isRipple\"\n            >{{ tab.title }}</a\n          >\n        </div>\n      </div>\n    </div>\n  ",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlLayoutHeaderComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: MdlLayoutMediatorService }
    ]; };
    MdlLayoutHeaderComponent.propDecorators = {
        isSeamed: [{ type: i0.HostBinding, args: ["class.mdl-layout__header--seamed",] }],
        isLayoutHeader: [{ type: i0.HostBinding, args: ["class.mdl-layout__header",] }],
        isCompact: [{ type: i0.HostBinding, args: ["class.is-compact",] }],
        isWaterfall: [{ type: i0.HostBinding, args: ["class.mdl-layout__header--waterfall",] }],
        isCastingShadow: [{ type: i0.HostBinding, args: ["class.is-casting-shadow",] }],
        isHeaderScroll: [{ type: i0.HostBinding, args: ["class.mdl-layout__header--scroll",] }],
        onTransitionEnd: [{ type: i0.HostListener, args: ["transitionend",] }],
        onClick: [{ type: i0.HostListener, args: ["click",] }]
    };

    var MdlLayoutDrawerComponent = /** @class */ (function () {
        function MdlLayoutDrawerComponent() {
            this.isDrawer = true;
            this.isDrawerVisible = false;
        }
        return MdlLayoutDrawerComponent;
    }());
    MdlLayoutDrawerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-layout-drawer",
                    template: " <ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlLayoutDrawerComponent.propDecorators = {
        isDrawer: [{ type: i0.HostBinding, args: ["class.mdl-layout__drawer",] }],
        isDrawerVisible: [{ type: i0.HostBinding, args: ["class.is-visible",] }]
    };

    var MdlTabPanelTitleComponent = /** @class */ (function () {
        function MdlTabPanelTitleComponent(vcRef) {
            this.vcRef = vcRef;
        }
        return MdlTabPanelTitleComponent;
    }());
    MdlTabPanelTitleComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-tab-panel-title",
                    template: " <ng-content></ng-content> ",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlTabPanelTitleComponent.ctorParameters = function () { return [
        { type: i0.ViewContainerRef }
    ]; };

    var MdlLayoutTabPanelComponent = /** @class */ (function () {
        function MdlLayoutTabPanelComponent() {
            this.isLayoutTabPanel = true;
            this.isActive = false;
        }
        return MdlLayoutTabPanelComponent;
    }());
    MdlLayoutTabPanelComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-layout-tab-panel",
                    template: "\n    <ng-content\n      *ngIf=\"titleComponent\"\n      select=\"mdl-tab-panel-content\"\n    ></ng-content>\n    <ng-content *ngIf=\"!titleComponent\"></ng-content>\n  ",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlLayoutTabPanelComponent.propDecorators = {
        titleComponent: [{ type: i0.ContentChild, args: [MdlTabPanelTitleComponent, { static: true },] }],
        title: [{ type: i0.Input, args: ["mdl-layout-tab-panel-title",] }],
        isLayoutTabPanel: [{ type: i0.HostBinding, args: ["class.mdl-layout__tab-panel",] }],
        isActive: [{ type: i0.HostBinding, args: ["class.is-active",] }]
    };

    var MdlLayoutContentComponent = /** @class */ (function () {
        function MdlLayoutContentComponent(elRef) {
            this.elRef = elRef;
            this.isContent = true;
            this.el = elRef.nativeElement;
        }
        return MdlLayoutContentComponent;
    }());
    MdlLayoutContentComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-layout-content",
                    template: " <ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlLayoutContentComponent.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    MdlLayoutContentComponent.propDecorators = {
        isContent: [{ type: i0.HostBinding, args: ["class.mdl-layout__content",] }],
        tabs: [{ type: i0.ContentChildren, args: [MdlLayoutTabPanelComponent,] }]
    };

    var ESCAPE = 27;
    var STANDARD = "standard";
    var WATERFALL = "waterfall";
    var SCROLL = "scroll";
    /**
     * The LAYOUT_SCREEN_SIZE_THRESHOLD can be changed at the root module. Just provide a value for this InjectionToken:
     *
     * providers: [
     *  {provide:LAYOUT_SCREEN_SIZE_THRESHOLD, useValue: 768 }
     * ]
     *
     * you also need to change the scss variable to the same value: $layout-screen-size-threshold: 768px.
     *
     * It should be clear that this can only be used if you are using the scss and not the pre compiled css from getmdl.io.
     *
     */
    var LAYOUT_SCREEN_SIZE_THRESHOLD = new i0.InjectionToken("layoutScreenSizeThreshold");
    var MdLUnsupportedLayoutTypeError = /** @class */ (function (_super) {
        __extends(MdLUnsupportedLayoutTypeError, _super);
        function MdLUnsupportedLayoutTypeError(type) {
            /* istanbul ignore next */
            return _super.call(this, "Layout type \"" + type + "\" isn't supported by mdl-layout (allowed: standard, waterfall, scroll).") || this;
        }
        return MdLUnsupportedLayoutTypeError;
    }(MdlError));
    var MdlScreenSizeService = /** @class */ (function () {
        function MdlScreenSizeService(ngZone, layoutScreenSizeThreshold) {
            var _this = this;
            this.layoutScreenSizeThreshold = layoutScreenSizeThreshold;
            this.sizesSubject = new rxjs.BehaviorSubject(false);
            // if no value is injected the default size wil be used. same as $layout-screen-size-threshold in scss
            if (!this.layoutScreenSizeThreshold) {
                this.layoutScreenSizeThreshold = 1024;
            }
            // do not try to access the window object if rendered on the server
            if (typeof window === "object" && "matchMedia" in window) {
                var query_1 = window.matchMedia("(max-width: " + this.layoutScreenSizeThreshold + "px)");
                var queryListener_1 = function () {
                    ngZone.run(function () {
                        _this.sizesSubject.next(query_1.matches);
                    });
                };
                // - addEventListener not working in Safari
                // eslint-disable-next-line
                query_1.addListener(queryListener_1);
                this.windowMediaQueryListener = function () {
                    // eslint-disable-next-line
                    query_1.removeListener(queryListener_1);
                };
                // set the initial state
                this.sizesSubject.next(query_1.matches);
            }
        }
        MdlScreenSizeService.prototype.isSmallScreen = function () {
            return this.sizesSubject.value;
        };
        MdlScreenSizeService.prototype.sizes = function () {
            return this.sizesSubject.asObservable();
        };
        MdlScreenSizeService.prototype.destroy = function () {
            if (this.windowMediaQueryListener) {
                this.windowMediaQueryListener();
                this.windowMediaQueryListener = null;
            }
        };
        return MdlScreenSizeService;
    }());
    MdlScreenSizeService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function MdlScreenSizeService_Factory() { return new MdlScreenSizeService(i0__namespace.ɵɵinject(i0__namespace.NgZone), i0__namespace.ɵɵinject(LAYOUT_SCREEN_SIZE_THRESHOLD, 8)); }, token: MdlScreenSizeService, providedIn: "root" });
    MdlScreenSizeService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: "root",
                },] }
    ];
    MdlScreenSizeService.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: Number, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [LAYOUT_SCREEN_SIZE_THRESHOLD,] }] }
    ]; };
    var MdlLayoutComponent = /** @class */ (function () {
        function MdlLayoutComponent(renderer, evm, el, screenSizeService, layoutMediatorService) {
            this.renderer = renderer;
            this.evm = evm;
            this.el = el;
            this.screenSizeService = screenSizeService;
            this.layoutMediatorService = layoutMediatorService;
            // eslint-disable-next-line
            this.mode = STANDARD;
            // eslint-disable-next-line
            this.selectedTabEmitter = new i0.EventEmitter();
            // eslint-disable-next-line
            this.mouseoverTabEmitter = new i0.EventEmitter();
            // eslint-disable-next-line
            this.mouseoutTabEmitter = new i0.EventEmitter();
            // eslint-disable-next-line
            this.onOpen = new i0.EventEmitter();
            // eslint-disable-next-line
            this.onClose = new i0.EventEmitter();
            this.isDrawerVisible = false;
            this.isSmallScreen = false;
            this.isFixedDrawerIntern = false;
            this.isFixedHeaderIntern = false;
            this.isSeamedIntern = false;
            this.selectedIndexIntern = 0;
            this.isNoDrawerIntern = false;
            this.subscriptions = [];
        }
        Object.defineProperty(MdlLayoutComponent.prototype, "isFixedDrawer", {
            get: function () {
                return this.isFixedDrawerIntern;
            },
            set: function (value) {
                this.isFixedDrawerIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlLayoutComponent.prototype, "isFixedHeader", {
            get: function () {
                return this.isFixedHeaderIntern;
            },
            set: function (value) {
                this.isFixedHeaderIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlLayoutComponent.prototype, "isSeamed", {
            get: function () {
                return this.isSeamedIntern;
            },
            set: function (value) {
                this.isSeamedIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlLayoutComponent.prototype, "selectedIndex", {
            get: function () {
                return this.selectedIndexIntern;
            },
            set: function (value) {
                this.selectedIndexIntern = toNumber(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlLayoutComponent.prototype, "isNoDrawer", {
            get: function () {
                return this.isNoDrawerIntern;
            },
            set: function (value) {
                this.isNoDrawerIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        MdlLayoutComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.validateMode();
            if (this.header && this.content && this.content.tabs) {
                this.header.tabs = this.content.tabs;
                this.updateSelectedTabIndex();
            }
            if (this.header && this.header.tabs) {
                this.subscriptions.push(this.layoutMediatorService
                    .onTabMouseOut()
                    .subscribe(function (tab) {
                    _this.onTabMouseout(tab);
                }));
                this.subscriptions.push(this.layoutMediatorService
                    .onTabMouseover()
                    .subscribe(function (tab) {
                    _this.onTabMouseover(tab);
                }));
                this.subscriptions.push(this.layoutMediatorService
                    .onTabSelected()
                    .subscribe(function (tab) {
                    _this.tabSelected(tab);
                }));
            }
        };
        MdlLayoutComponent.prototype.ngOnChanges = function (changes) {
            if (changes.selectedIndex) {
                this.updateSelectedTabIndex();
            }
        };
        MdlLayoutComponent.prototype.toggleDrawer = function () {
            this.isDrawerVisible = !this.isDrawerVisible;
            if (this.drawers.length > 0) {
                this.setDrawerVisible(this.isDrawerVisible);
            }
        };
        MdlLayoutComponent.prototype.closeDrawer = function () {
            this.isDrawerVisible = false;
            if (this.drawers.length > 0) {
                this.setDrawerVisible(false);
            }
        };
        MdlLayoutComponent.prototype.openDrawer = function () {
            this.isDrawerVisible = true;
            if (this.drawers.length > 0) {
                this.setDrawerVisible(true);
            }
        };
        MdlLayoutComponent.prototype.obfuscatorKeyDown = function ($event) {
            if ($event.keyCode === ESCAPE) {
                this.toggleDrawer();
            }
        };
        MdlLayoutComponent.prototype.ngOnDestroy = function () {
            if (this.scrollListener) {
                this.scrollListener();
                this.scrollListener = null;
            }
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        };
        MdlLayoutComponent.prototype.closeDrawerOnSmallScreens = function () {
            if (this.isSmallScreen && this.isDrawerVisible) {
                this.closeDrawer();
            }
        };
        MdlLayoutComponent.prototype.openDrawerOnSmallScreens = function () {
            if (this.isSmallScreen && !this.isDrawerVisible) {
                this.openDrawer();
            }
        };
        MdlLayoutComponent.prototype.hasDrawer = function () {
            return this.drawers.length > 0;
        };
        MdlLayoutComponent.prototype.tabSelected = function (tab) {
            var index = this.header.tabs.toArray().indexOf(tab);
            if (index !== this.selectedIndex) {
                this.selectedIndex = index;
                this.updateSelectedTabIndex();
                this.selectedTabEmitter.emit({ index: this.selectedIndex });
            }
        };
        MdlLayoutComponent.prototype.onTabMouseover = function (tab) {
            var index = this.header.tabs.toArray().indexOf(tab);
            this.mouseoverTabEmitter.emit({ index: index });
        };
        MdlLayoutComponent.prototype.onTabMouseout = function (tab) {
            var index = this.header.tabs.toArray().indexOf(tab);
            this.mouseoutTabEmitter.emit({ index: index });
        };
        MdlLayoutComponent.prototype.updateSelectedTabIndex = function () {
            if (this.header && this.header.tabs) {
                this.header.tabs.forEach(function (tab) { return (tab.isActive = false); });
                if (this.header.tabs.toArray().length > 0 &&
                    this.selectedIndex < this.header.tabs.toArray().length) {
                    this.header.tabs.toArray()[this.selectedIndex].isActive = true;
                }
            }
        };
        MdlLayoutComponent.prototype.validateMode = function () {
            var _this = this;
            if (this.mode === "") {
                this.mode = STANDARD;
            }
            if ([STANDARD, WATERFALL, SCROLL].indexOf(this.mode) === -1) {
                throw new MdLUnsupportedLayoutTypeError(this.mode);
            }
            if (this.header) {
                // inform the header about the mode
                this.header.mode = this.mode;
                this.header.isSeamed = this.isSeamed;
            }
            if (this.content) {
                this.scrollListener = this.renderer.listen(this.content.el, "scroll", function () {
                    _this.onScroll(_this.content.el.scrollTop);
                    return true;
                });
                this.screenSizeService.sizes().subscribe(function (isSmall) {
                    _this.onQueryChange(isSmall);
                });
            }
        };
        MdlLayoutComponent.prototype.onScroll = function (scrollTop) {
            if (this.mode !== WATERFALL) {
                return;
            }
            if (this.header.isAnimating) {
                return;
            }
            var headerVisible = !this.isSmallScreen || this.isFixedHeader;
            if (scrollTop > 0 && !this.header.isCompact) {
                this.header.isCompact = true;
                if (headerVisible) {
                    this.header.isAnimating = true;
                }
            }
            else if (scrollTop <= 0 && this.header.isCompact) {
                this.header.isCompact = false;
                if (headerVisible) {
                    this.header.isAnimating = true;
                }
            }
        };
        MdlLayoutComponent.prototype.onQueryChange = function (isSmall) {
            if (isSmall) {
                this.isSmallScreen = true;
            }
            else {
                this.isSmallScreen = false;
                this.closeDrawer();
            }
        };
        MdlLayoutComponent.prototype.setDrawerVisible = function (visible) {
            this.drawers.first.isDrawerVisible = visible;
            if (this.drawers.first.isDrawerVisible) {
                this.onOpen.emit();
            }
            else {
                this.onClose.emit();
            }
        };
        return MdlLayoutComponent;
    }());
    MdlLayoutComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-layout",
                    template: "\n    <div\n      class=\"mdl-layout__container\"\n      [ngClass]=\"{ 'has-scrolling-header': mode === 'scroll' }\"\n    >\n      <div\n        class=\"mdl-layout is-upgraded\"\n        [ngClass]=\"{\n          'is-small-screen': isSmallScreen,\n          'mdl-layout--fixed-drawer': isFixedDrawer,\n          'mdl-layout--fixed-header': isFixedHeader,\n          'mdl-layout--fixed-tabs': 'tabs.toArray().length > 0'\n        }\"\n      >\n        <ng-content select=\"mdl-layout-header\"></ng-content>\n        <ng-content select=\"mdl-layout-drawer\"></ng-content>\n        <div\n          *ngIf=\"drawers.length > 0 && isNoDrawer == false\"\n          class=\"mdl-layout__drawer-button\"\n          (click)=\"toggleDrawer()\"\n        >\n          <mdl-icon>&#xE5D2;</mdl-icon>\n        </div>\n        <ng-content select=\"mdl-layout-content\"></ng-content>\n        <div\n          class=\"mdl-layout__obfuscator\"\n          [ngClass]=\"{ 'is-visible': isDrawerVisible }\"\n          (click)=\"toggleDrawer()\"\n          (keydown)=\"obfuscatorKeyDown($event)\"\n        ></div>\n      </div>\n    </div>\n  ",
                    exportAs: "mdlLayout",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlLayoutComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 },
        { type: platformBrowser.EventManager },
        { type: i0.ElementRef },
        { type: MdlScreenSizeService },
        { type: MdlLayoutMediatorService }
    ]; };
    MdlLayoutComponent.propDecorators = {
        header: [{ type: i0.ContentChild, args: [MdlLayoutHeaderComponent,] }],
        drawers: [{ type: i0.ContentChildren, args: [MdlLayoutDrawerComponent, { descendants: false },] }],
        content: [{ type: i0.ContentChild, args: [MdlLayoutContentComponent, { static: true },] }],
        mode: [{ type: i0.Input, args: ['mdl-layout-mode',] }],
        selectedTabEmitter: [{ type: i0.Output, args: ['mdl-layout-tab-active-changed',] }],
        mouseoverTabEmitter: [{ type: i0.Output, args: ['mdl-layout-tab-mouseover',] }],
        mouseoutTabEmitter: [{ type: i0.Output, args: ['mdl-layout-tab-mouseout',] }],
        onOpen: [{ type: i0.Output, args: ['open',] }],
        onClose: [{ type: i0.Output, args: ['close',] }],
        isFixedDrawer: [{ type: i0.Input, args: ["mdl-layout-fixed-drawer",] }],
        isFixedHeader: [{ type: i0.Input, args: ["mdl-layout-fixed-header",] }],
        isSeamed: [{ type: i0.Input, args: ["mdl-layout-header-seamed",] }],
        selectedIndex: [{ type: i0.Input, args: ["mdl-layout-tab-active-index",] }],
        isNoDrawer: [{ type: i0.Input, args: ["mdl-layout-no-drawer-button",] }]
    };

    var MdlLayoutHeaderTransparentDirective = /** @class */ (function () {
        function MdlLayoutHeaderTransparentDirective() {
            this.isTransparent = true;
        }
        return MdlLayoutHeaderTransparentDirective;
    }());
    MdlLayoutHeaderTransparentDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: 'mdl-layout-header[mdl-layout-header-transparent]'
                },] }
    ];
    MdlLayoutHeaderTransparentDirective.propDecorators = {
        isTransparent: [{ type: i0.HostBinding, args: ["class.mdl-layout__header--transparent",] }]
    };

    var MdlLayoutHeaderRowComponent = /** @class */ (function () {
        function MdlLayoutHeaderRowComponent() {
            this.isHeaderRow = true;
        }
        return MdlLayoutHeaderRowComponent;
    }());
    MdlLayoutHeaderRowComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-layout-header-row",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlLayoutHeaderRowComponent.propDecorators = {
        isHeaderRow: [{ type: i0.HostBinding, args: ["class.mdl-layout__header-row",] }]
    };

    var MdlLayoutTitleComponent = /** @class */ (function () {
        function MdlLayoutTitleComponent() {
            this.isLayoutTitle = true;
        }
        return MdlLayoutTitleComponent;
    }());
    MdlLayoutTitleComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-layout-title",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlLayoutTitleComponent.propDecorators = {
        isLayoutTitle: [{ type: i0.HostBinding, args: ["class.mdl-layout-title",] }]
    };

    var MdlLayoutSpacerComponent = /** @class */ (function () {
        function MdlLayoutSpacerComponent() {
            this.isLayoutSpacer = true;
        }
        return MdlLayoutSpacerComponent;
    }());
    MdlLayoutSpacerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-layout-spacer",
                    template: "",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlLayoutSpacerComponent.propDecorators = {
        isLayoutSpacer: [{ type: i0.HostBinding, args: ["class.mdl-layout-spacer",] }]
    };

    var MdlIconComponent = /** @class */ (function () {
        function MdlIconComponent() {
            this.isMatIcon = true;
        }
        return MdlIconComponent;
    }());
    MdlIconComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-icon",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlIconComponent.propDecorators = {
        isMatIcon: [{ type: i0.HostBinding, args: ["class.material-icons",] }]
    };

    var MDL_ICON_DIRECTIVES = [MdlIconComponent];
    var MdlIconModule = /** @class */ (function () {
        function MdlIconModule() {
        }
        MdlIconModule.forRoot = function () {
            return {
                ngModule: MdlIconModule,
                providers: [],
            };
        };
        return MdlIconModule;
    }());
    MdlIconModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [],
                    exports: MDL_ICON_DIRECTIVES,
                    declarations: MDL_ICON_DIRECTIVES,
                },] }
    ];

    var MdlTabPanelContentComponent = /** @class */ (function () {
        function MdlTabPanelContentComponent() {
        }
        return MdlTabPanelContentComponent;
    }());
    MdlTabPanelContentComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-tab-panel-content",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    var MdlTabPanelComponent = /** @class */ (function () {
        function MdlTabPanelComponent() {
            this.isTabPanel = true;
            this.isActive = false;
        }
        return MdlTabPanelComponent;
    }());
    MdlTabPanelComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-tab-panel",
                    template: "\n    <ng-content\n      *ngIf=\"titleComponent\"\n      select=\"mdl-tab-panel-content\"\n    ></ng-content>\n    <ng-content *ngIf=\"!titleComponent\"></ng-content>\n  ",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlTabPanelComponent.propDecorators = {
        titleComponent: [{ type: i0.ContentChild, args: [MdlTabPanelTitleComponent, { static: true },] }],
        title: [{ type: i0.Input, args: ['mdl-tab-panel-title',] }],
        disabled: [{ type: i0.Input, args: ['disabled',] }],
        isTabPanel: [{ type: i0.HostBinding, args: ["class.mdl-tabs__panel",] }],
        isActive: [{ type: i0.HostBinding, args: ["class.is-active",] }]
    };

    var MdlTabsComponent = /** @class */ (function () {
        function MdlTabsComponent() {
            // eslint-disable-next-line
            this.selectedTabEmitter = new i0.EventEmitter();
            this.isTabs = true;
            this.isUpgraded = true;
            this.selectedIndexIntern = 0;
            this.isRippleIntern = false;
        }
        Object.defineProperty(MdlTabsComponent.prototype, "selectedIndex", {
            get: function () {
                return this.selectedIndexIntern;
            },
            set: function (value) {
                this.selectedIndexIntern = toNumber(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlTabsComponent.prototype, "isRipple", {
            get: function () {
                return this.isRippleIntern;
            },
            set: function (value) {
                this.isRippleIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        MdlTabsComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            // the initial tabs
            this.updateSelectedTabIndex();
            // listen to tab changes - this would not be necessary if this would be fixed:
            // https://github.com/angular/angular/issues/12818
            this.tabs.changes.subscribe(function () {
                _this.updateSelectedTabIndex();
            });
        };
        MdlTabsComponent.prototype.ngOnChanges = function (changes) {
            if (changes.selectedIndex) {
                this.updateSelectedTabIndex();
            }
        };
        MdlTabsComponent.prototype.tabSelected = function (tab) {
            if (tab.disabled) {
                return;
            }
            var index = this.tabs.toArray().indexOf(tab);
            if (index !== this.selectedIndex) {
                this.selectedIndex = index;
                this.updateSelectedTabIndex();
                this.selectedTabEmitter.emit({ index: this.selectedIndex });
            }
        };
        MdlTabsComponent.prototype.updateSelectedTabIndex = function () {
            var _this = this;
            if (this.tabs) {
                // https://github.com/angular/angular/issues/6005
                // this would not be necessare if this would be fixed: https://github.com/angular/angular/issues/12818
                setTimeout(function () {
                    _this.tabs.forEach(function (tab, idx) {
                        tab.isActive = _this.selectedIndex === idx;
                    });
                }, 1);
            }
        };
        return MdlTabsComponent;
    }());
    MdlTabsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-tabs",
                    template: "\n    <div class=\"mdl-tabs__tab-bar\">\n      <div *ngFor=\"let tab of tabs.toArray()\">\n        <div\n          *ngIf=\"tab.titleComponent\"\n          class=\"mdl-tabs__tab\"\n          (click)=\"tabSelected(tab)\"\n          [mdl-ripple]=\"isRipple && !tab.disabled\"\n          [ngClass]=\"{ 'is-active': tab.isActive, disabled: tab.disabled }\"\n          [append-view-container-ref]=\"tab.titleComponent.vcRef\"\n        ></div>\n        <a\n          *ngIf=\"!tab.titleComponent\"\n          href=\"javascript:void(0)\"\n          (click)=\"tabSelected(tab)\"\n          class=\"mdl-tabs__tab\"\n          [mdl-ripple]=\"isRipple && !tab.disabled\"\n          [ngClass]=\"{ 'is-active': tab.isActive, disabled: tab.disabled }\"\n          >{{ tab.title }}</a\n        >\n      </div>\n    </div>\n    <ng-content></ng-content>\n  ",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlTabsComponent.propDecorators = {
        selectedTabEmitter: [{ type: i0.Output, args: ['mdl-tab-active-changed',] }],
        tabs: [{ type: i0.ContentChildren, args: [MdlTabPanelComponent,] }],
        isTabs: [{ type: i0.HostBinding, args: ["class.mdl-tabs",] }],
        isUpgraded: [{ type: i0.HostBinding, args: ["class.is-upgraded",] }],
        selectedIndex: [{ type: i0.Input, args: ["mdl-tab-active-index",] }],
        isRipple: [{ type: i0.Input, args: ["mdl-ripple",] }]
    };

    /**
     * @license
     * Copyright 2015 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /* eslint-disable */
    /* istanbul ignore file */
    'use strict';
    /**
     * Class constructor for Ripple MDL component.
     * Implements MDL component design pattern defined at:
     * https://github.com/jasonmayes/mdl-component-design-pattern
     *
     */
    function MaterialRipple(renderer, element) {
        this.renderer_ = renderer;
        this.element_ = element;
        // Initialize instance.
        this.init();
    }
    /**
     * Store constants in one place so they can be updated easily.
     */
    MaterialRipple.prototype.Constant_ = {
        INITIAL_SCALE: 'scale(0.0001, 0.0001)',
        INITIAL_SIZE: '1px',
        INITIAL_OPACITY: '0.4',
        FINAL_OPACITY: '0',
        FINAL_SCALE: ''
    };
    /**
     * Store strings for class names defined by this component that are used in
     * JavaScript. This allows us to simply change it in one place should we
     * decide to modify at a later date.
     */
    MaterialRipple.prototype.CssClasses_ = {
        RIPPLE_CENTER: 'mdl-ripple--center',
        RIPPLE_EFFECT_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
        RIPPLE: 'mdl-ripple',
        IS_ANIMATING: 'is-animating',
        IS_VISIBLE: 'is-visible'
    };
    /**
     * Handle mouse / finger down on element.
     *
     */
    // eslint-disable-next-line
    MaterialRipple.prototype.downHandler_ = function (event) {
        if (!this.rippleElement_.style.width && !this.rippleElement_.style.height) {
            var rect = this.element_.getBoundingClientRect();
            this.boundHeight = rect.height;
            this.boundWidth = rect.width;
            this.rippleSize_ = Math.sqrt(rect.width * rect.width +
                rect.height * rect.height) * 2 + 2;
            this.rippleElement_.style.width = this.rippleSize_ + 'px';
            this.rippleElement_.style.height = this.rippleSize_ + 'px';
        }
        this.renderer_.addClass(this.rippleElement_, this.CssClasses_.IS_VISIBLE);
        if (event.type === 'mousedown' && this.ignoringMouseDown_) {
            this.ignoringMouseDown_ = false;
        }
        else {
            if (event.type === 'touchstart') {
                this.ignoringMouseDown_ = true;
            }
            var frameCount = this.getFrameCount();
            if (frameCount > 0) {
                return;
            }
            this.setFrameCount(1);
            var bound = event.currentTarget.getBoundingClientRect();
            var x = void 0;
            var y = void 0;
            // Check if we are handling a keyboard click.
            if (event.clientX === 0 && event.clientY === 0) {
                x = Math.round(bound.width / 2);
                y = Math.round(bound.height / 2);
            }
            else {
                var clientX = event.clientX !== undefined ? event.clientX : event.touches[0].clientX;
                var clientY = event.clientY !== undefined ? event.clientY : event.touches[0].clientY;
                x = Math.round(clientX - bound.left);
                y = Math.round(clientY - bound.top);
            }
            this.setRippleXY(x, y);
            this.setRippleStyles(true);
            window.requestAnimationFrame(this.animFrameHandler.bind(this));
        }
    };
    /**
     * Handle mouse / finger up on element.
     *
     */
    // eslint-disable-next-line
    MaterialRipple.prototype.upHandler_ = function (event) {
        // Don't fire for the artificial "mouseup" generated by a double-click.
        if (event && event.detail !== 2) {
            // Allow a repaint to occur before removing this class, so the animation
            // shows for tap events, which seem to trigger a mouseup too soon after
            // mousedown.
            // eslint-disable-next-line
            setTimeout(function () {
                this.renderer_.removeClass(this.rippleElement_, this.CssClasses_.IS_VISIBLE);
            }.bind(this), 0);
        }
    };
    /**
     * Initialize element.
     */
    // eslint-disable-next-line
    MaterialRipple.prototype.init = function () {
        if (this.element_) {
            var recentering_1 = this.element_.classList.contains(this.CssClasses_.RIPPLE_CENTER);
            if (!this.element_.classList.contains(this.CssClasses_.RIPPLE_EFFECT_IGNORE_EVENTS)) {
                this.rippleElement_ = this.element_.querySelector('.' +
                    this.CssClasses_.RIPPLE);
                this.frameCount_ = 0;
                this.rippleSize_ = 0;
                this.x_ = 0;
                this.y_ = 0;
                // Touch start produces a compat mouse down event, which would cause a
                // second ripples. To avoid that, we use this property to ignore the first
                // mouse down after a touch start.
                this.ignoringMouseDown_ = false;
                this.boundDownHandler = this.downHandler_.bind(this);
                this.element_.addEventListener('mousedown', this.boundDownHandler);
                this.element_.addEventListener('touchstart', this.boundDownHandler);
                this.boundUpHandler = this.upHandler_.bind(this);
                this.element_.addEventListener('mouseup', this.boundUpHandler);
                this.element_.addEventListener('mouseleave', this.boundUpHandler);
                this.element_.addEventListener('touchend', this.boundUpHandler);
                this.element_.addEventListener('blur', this.boundUpHandler);
                // eslint-disable-next-line
                this.getFrameCount = function () {
                    return this.frameCount_;
                };
                // eslint-disable-next-line
                this.setFrameCount = function (fC) {
                    this.frameCount_ = fC;
                };
                // eslint-disable-next-line
                this.getRippleElement = function () {
                    return this.rippleElement_;
                };
                // eslint-disable-next-line
                this.setRippleXY = function (newX, newY) {
                    this.x_ = newX;
                    this.y_ = newY;
                };
                // eslint-disable-next-line
                this.setRippleStyles = function (start) {
                    if (this.rippleElement_ !== null) {
                        var transformString = void 0;
                        var scale = void 0;
                        var size = void 0;
                        var offset = 'translate(' + this.x_ + 'px, ' + this.y_ + 'px)';
                        if (start) {
                            scale = this.Constant_.INITIAL_SCALE;
                            size = this.Constant_.INITIAL_SIZE;
                        }
                        else {
                            scale = this.Constant_.FINAL_SCALE;
                            size = this.rippleSize_ + 'px';
                            if (recentering_1) {
                                offset = 'translate(' + this.boundWidth / 2 + 'px, ' +
                                    this.boundHeight / 2 + 'px)';
                            }
                        }
                        transformString = 'translate(-50%, -50%) ' + offset + scale;
                        this.rippleElement_.style.webkitTransform = transformString;
                        this.rippleElement_.style.msTransform = transformString;
                        this.rippleElement_.style.transform = transformString;
                        if (start) {
                            this.renderer_.removeClass(this.rippleElement_, this.CssClasses_.IS_ANIMATING);
                        }
                        else {
                            this.renderer_.addClass(this.rippleElement_, this.CssClasses_.IS_ANIMATING);
                        }
                    }
                };
                /**
                 * Handles an animation frame.
                 */
                // eslint-disable-next-line
                this.animFrameHandler = function () {
                    if (this.frameCount_-- > 0) {
                        window.requestAnimationFrame(this.animFrameHandler.bind(this));
                    }
                    else {
                        this.setRippleStyles(false);
                    }
                };
            }
        }
    };

    var RIPPLE = "mdl-ripple";
    // known bugs: https://github.com/google/material-design-lite/issues/4215
    var MdlRippleDirective = /** @class */ (function () {
        function MdlRippleDirective(elementRef, renderer, cssContainerClasses) {
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.cssContainerClasses = cssContainerClasses;
            this.rippleActive = true;
            this.el = elementRef.nativeElement;
        }
        MdlRippleDirective.prototype.ngOnChanges = function () {
            var _this = this;
            // remove any existing ripple container
            if (this.rippleContainer) {
                this.el.removeChild(this.rippleContainer);
                delete this.rippleContainer;
                delete this.ripple;
            }
            // if used as mdl-ripple without property binding it is an empty string
            // otherwise (e.g. [mdl-ripple] it is a boolean - may be with the default value true.
            if (this.rippleActive === "" || this.rippleActive) {
                this.rippleContainer = this.renderer.createElement("span");
                this.cssContainerClasses.forEach(function (cssClass) {
                    _this.renderer.addClass(_this.rippleContainer, cssClass);
                });
                var rippleElement = this.renderer.createElement("span");
                this.renderer.addClass(rippleElement, RIPPLE);
                this.rippleContainer.appendChild(rippleElement);
                this.el.appendChild(this.rippleContainer);
                this.ripple = new MaterialRipple(this.renderer, this.el);
            }
        };
        return MdlRippleDirective;
    }());
    MdlRippleDirective.decorators = [
        { type: i0.Directive }
    ];
    MdlRippleDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: Array }
    ]; };
    var MdlButtonRippleDirective = /** @class */ (function (_super) {
        __extends(MdlButtonRippleDirective, _super);
        function MdlButtonRippleDirective(elementRef, renderer) {
            var _this = _super.call(this, elementRef, renderer, ["mdl-button__ripple-container"]) || this;
            // eslint-disable-next-line
            _this.rippleActive = true;
            return _this;
        }
        return MdlButtonRippleDirective;
    }(MdlRippleDirective));
    MdlButtonRippleDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: 'mdl-button[mdl-ripple], button[mdl-ripple]'
                },] }
    ];
    MdlButtonRippleDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    MdlButtonRippleDirective.propDecorators = {
        rippleActive: [{ type: i0.Input, args: ['mdl-ripple',] }]
    };
    var MdlCheckboxRippleDirective = /** @class */ (function (_super) {
        __extends(MdlCheckboxRippleDirective, _super);
        function MdlCheckboxRippleDirective(elementRef, renderer) {
            var _this = _super.call(this, elementRef, renderer, [
                "mdl-checkbox__ripple-container",
                "mdl-ripple--center",
            ]) || this;
            // eslint-disable-next-line
            _this.rippleActive = true;
            return _this;
        }
        return MdlCheckboxRippleDirective;
    }(MdlRippleDirective));
    MdlCheckboxRippleDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: 'mdl-checkbox[mdl-ripple]'
                },] }
    ];
    MdlCheckboxRippleDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    MdlCheckboxRippleDirective.propDecorators = {
        rippleActive: [{ type: i0.Input, args: ['mdl-ripple',] }]
    };
    var MdlRadioRippleDirective = /** @class */ (function (_super) {
        __extends(MdlRadioRippleDirective, _super);
        function MdlRadioRippleDirective(elementRef, renderer) {
            var _this = _super.call(this, elementRef, renderer, [
                "mdl-radio__ripple-container",
                "mdl-ripple--center",
            ]) || this;
            // eslint-disable-next-line
            _this.rippleActive = true;
            return _this;
        }
        return MdlRadioRippleDirective;
    }(MdlRippleDirective));
    MdlRadioRippleDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: 'mdl-radio[mdl-ripple]'
                },] }
    ];
    MdlRadioRippleDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    MdlRadioRippleDirective.propDecorators = {
        rippleActive: [{ type: i0.Input, args: ['mdl-ripple',] }]
    };
    var MdlIconToggleRippleDirective = /** @class */ (function (_super) {
        __extends(MdlIconToggleRippleDirective, _super);
        function MdlIconToggleRippleDirective(elementRef, renderer) {
            var _this = _super.call(this, elementRef, renderer, [
                "mdl-icon-toggle__ripple-container",
                "mdl-ripple--center",
            ]) || this;
            // eslint-disable-next-line
            _this.rippleActive = true;
            return _this;
        }
        return MdlIconToggleRippleDirective;
    }(MdlRippleDirective));
    MdlIconToggleRippleDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: 'mdl-icon-toggle[mdl-ripple]'
                },] }
    ];
    MdlIconToggleRippleDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    MdlIconToggleRippleDirective.propDecorators = {
        rippleActive: [{ type: i0.Input, args: ['mdl-ripple',] }]
    };
    var MdlSwitchRippleDirective = /** @class */ (function (_super) {
        __extends(MdlSwitchRippleDirective, _super);
        function MdlSwitchRippleDirective(elementRef, renderer) {
            var _this = _super.call(this, elementRef, renderer, [
                "mdl-switch__ripple-container",
                "mdl-ripple--center",
            ]) || this;
            // eslint-disable-next-line
            _this.rippleActive = true;
            return _this;
        }
        return MdlSwitchRippleDirective;
    }(MdlRippleDirective));
    MdlSwitchRippleDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: 'mdl-switch[mdl-ripple]'
                },] }
    ];
    MdlSwitchRippleDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    MdlSwitchRippleDirective.propDecorators = {
        rippleActive: [{ type: i0.Input, args: ['mdl-ripple',] }]
    };
    var MdlMenuItemRippleDirective = /** @class */ (function (_super) {
        __extends(MdlMenuItemRippleDirective, _super);
        function MdlMenuItemRippleDirective(elementRef, renderer) {
            var _this = _super.call(this, elementRef, renderer, ["mdl-menu__item--ripple-container"]) || this;
            // eslint-disable-next-line
            _this.rippleActive = true;
            return _this;
        }
        return MdlMenuItemRippleDirective;
    }(MdlRippleDirective));
    MdlMenuItemRippleDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: 'mdl-menu-item[mdl-ripple]'
                },] }
    ];
    MdlMenuItemRippleDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    MdlMenuItemRippleDirective.propDecorators = {
        rippleActive: [{ type: i0.Input, args: ['mdl-ripple',] }]
    };
    var MdlAnchorRippleDirective = /** @class */ (function (_super) {
        __extends(MdlAnchorRippleDirective, _super);
        function MdlAnchorRippleDirective(elementRef, renderer) {
            var _this = _super.call(this, elementRef, renderer, [
                "mdl-tabs__ripple-container",
                "mdl-layout__tab-ripple-container",
            ]) || this;
            // eslint-disable-next-line
            _this.rippleActive = true;
            return _this;
        }
        return MdlAnchorRippleDirective;
    }(MdlRippleDirective));
    MdlAnchorRippleDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: 'a[mdl-ripple],div[mdl-ripple]'
                },] }
    ];
    MdlAnchorRippleDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    MdlAnchorRippleDirective.propDecorators = {
        rippleActive: [{ type: i0.Input, args: ['mdl-ripple',] }]
    };

    var MDL_RIPPLE_DIRECTIVES = [
        MdlCheckboxRippleDirective,
        MdlButtonRippleDirective,
        MdlRadioRippleDirective,
        MdlIconToggleRippleDirective,
        MdlSwitchRippleDirective,
        MdlMenuItemRippleDirective,
        MdlAnchorRippleDirective,
    ];
    var MdlRippleModule = /** @class */ (function () {
        function MdlRippleModule() {
        }
        MdlRippleModule.forRoot = function () {
            return {
                ngModule: MdlRippleModule,
                providers: [],
            };
        };
        return MdlRippleModule;
    }());
    MdlRippleModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [],
                    exports: MDL_RIPPLE_DIRECTIVES,
                    declarations: MDL_RIPPLE_DIRECTIVES,
                },] }
    ];

    var MDL_TABS_DIRECTIVES = [
        MdlTabsComponent,
        MdlTabPanelComponent,
        MdlTabPanelTitleComponent,
        MdlTabPanelContentComponent,
    ];
    var MdlTabsModule = /** @class */ (function () {
        function MdlTabsModule() {
        }
        MdlTabsModule.forRoot = function () {
            return {
                ngModule: MdlTabsModule,
                providers: [],
            };
        };
        return MdlTabsModule;
    }());
    MdlTabsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [MdlCommonsModule, MdlRippleModule, common.CommonModule, MdlRippleModule],
                    exports: MDL_TABS_DIRECTIVES,
                    declarations: __spreadArray([], __read(MDL_TABS_DIRECTIVES)),
                },] }
    ];

    var MDL_LAYOUT_DIRECTIVES = [
        MdlLayoutComponent,
        MdlLayoutHeaderComponent,
        MdlLayoutDrawerComponent,
        MdlLayoutContentComponent,
        MdlLayoutHeaderTransparentDirective,
        MdlLayoutHeaderRowComponent,
        MdlLayoutTitleComponent,
        MdlLayoutSpacerComponent,
        MdlLayoutTabPanelComponent,
    ];
    var MdlLayoutModule = /** @class */ (function () {
        function MdlLayoutModule() {
        }
        MdlLayoutModule.forRoot = function () {
            return {
                ngModule: MdlLayoutModule,
                providers: [MdlScreenSizeService],
            };
        };
        return MdlLayoutModule;
    }());
    MdlLayoutModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        MdlIconModule,
                        MdlCommonsModule,
                        MdlRippleModule,
                        MdlTabsModule,
                        common.CommonModule,
                    ],
                    exports: MDL_LAYOUT_DIRECTIVES,
                    declarations: MDL_LAYOUT_DIRECTIVES,
                },] }
    ];

    var DATA_BADE_ATTR = "data-badge";
    var MdlBadgeDirective = /** @class */ (function () {
        function MdlBadgeDirective(elementRef, renderer) {
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.isBadge = true;
            this.el = elementRef.nativeElement;
        }
        MdlBadgeDirective.prototype.ngOnChanges = function () {
            if (this.mdlBadgeContent === null ||
                typeof this.mdlBadgeContent === "undefined") {
                this.renderer.removeAttribute(this.el, DATA_BADE_ATTR);
                return;
            }
            this.renderer.setAttribute(this.el, DATA_BADE_ATTR, this.mdlBadgeContent);
        };
        return MdlBadgeDirective;
    }());
    MdlBadgeDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: '[mdl-badge]'
                },] }
    ];
    MdlBadgeDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    MdlBadgeDirective.propDecorators = {
        mdlBadgeContent: [{ type: i0.Input, args: ["mdl-badge",] }],
        isBadge: [{ type: i0.HostBinding, args: ["class.mdl-badge",] }]
    };
    var MdlBadgeOverlapDirective = /** @class */ (function () {
        function MdlBadgeOverlapDirective() {
            this.isOverlapping = true;
        }
        return MdlBadgeOverlapDirective;
    }());
    MdlBadgeOverlapDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: '[mdl-badge-overlap]'
                },] }
    ];
    MdlBadgeOverlapDirective.propDecorators = {
        isOverlapping: [{ type: i0.HostBinding, args: ["class.mdl-badge--overlap",] }]
    };
    var MdlBadgeNoBackgroundDirective = /** @class */ (function () {
        function MdlBadgeNoBackgroundDirective() {
            this.isNoBackground = true;
        }
        return MdlBadgeNoBackgroundDirective;
    }());
    MdlBadgeNoBackgroundDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: '[mdl-badge-no-background]'
                },] }
    ];
    MdlBadgeNoBackgroundDirective.propDecorators = {
        isNoBackground: [{ type: i0.HostBinding, args: ["class.mdl-badge--no-background",] }]
    };

    var MDL_BADGE_DIRECTIVES = [
        MdlBadgeDirective,
        MdlBadgeOverlapDirective,
        MdlBadgeNoBackgroundDirective,
    ];
    var MdlBadgeModule = /** @class */ (function () {
        function MdlBadgeModule() {
        }
        MdlBadgeModule.forRoot = function () {
            return {
                ngModule: MdlBadgeModule,
                providers: [],
            };
        };
        return MdlBadgeModule;
    }());
    MdlBadgeModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [],
                    exports: MDL_BADGE_DIRECTIVES,
                    declarations: MDL_BADGE_DIRECTIVES,
                },] }
    ];

    var MdlUnsupportedButtonTypeError = /** @class */ (function (_super) {
        __extends(MdlUnsupportedButtonTypeError, _super);
        function MdlUnsupportedButtonTypeError(type) {
            /* istanbul ignore next */
            return _super.call(this, "Button type \"" + type + "\" isn't supported (allowed: raised, fab, mini-fab, icon, '').") || this;
        }
        return MdlUnsupportedButtonTypeError;
    }(MdlError));
    var MdlUnsupportedColoredTypeError = /** @class */ (function (_super) {
        __extends(MdlUnsupportedColoredTypeError, _super);
        function MdlUnsupportedColoredTypeError(type) {
            /* istanbul ignore next */
            return _super.call(this, "Colored type \"" + type + "\" isn't supported (allowed: primary, accent, '').") || this;
        }
        return MdlUnsupportedColoredTypeError;
    }(MdlError));
    var MDL_BUTTON_TYPES = ["raised", "fab", "mini-fab", "icon", ""];
    var MDL_COLORED_TYPES = ["primary", "accent", ""];
    var MdlButtonComponent = /** @class */ (function () {
        function MdlButtonComponent(elementRef) {
            this.elementRef = elementRef;
            this.isButton = true;
            this.disabledIntern = false;
            this.element = elementRef.nativeElement;
        }
        Object.defineProperty(MdlButtonComponent.prototype, "isDisable", {
            get: function () {
                return this.disabled ? "disabled" : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlButtonComponent.prototype, "raised", {
            get: function () {
                return this.mdlButtonType === "raised";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlButtonComponent.prototype, "fab", {
            get: function () {
                return this.mdlButtonType === "fab" || this.mdlButtonType === "mini-fab";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlButtonComponent.prototype, "miniFab", {
            get: function () {
                return this.mdlButtonType === "mini-fab";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlButtonComponent.prototype, "icon", {
            get: function () {
                return this.mdlButtonType === "icon";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlButtonComponent.prototype, "primary", {
            get: function () {
                return this.mdlColoredType === "primary";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlButtonComponent.prototype, "accent", {
            get: function () {
                return this.mdlColoredType === "accent";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlButtonComponent.prototype, "disabled", {
            get: function () {
                return this.disabledIntern;
            },
            set: function (value) {
                this.disabledIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        MdlButtonComponent.prototype.onMouseUp = function () {
            this.blurIt();
        };
        MdlButtonComponent.prototype.onMouseLeave = function () {
            this.blurIt();
        };
        MdlButtonComponent.prototype.ngOnChanges = function () {
            if (this.mdlButtonType &&
                MDL_BUTTON_TYPES.indexOf(this.mdlButtonType) === -1) {
                throw new MdlUnsupportedButtonTypeError(this.mdlButtonType);
            }
            if (this.mdlColoredType &&
                MDL_COLORED_TYPES.indexOf(this.mdlColoredType) === -1) {
                throw new MdlUnsupportedColoredTypeError(this.mdlColoredType);
            }
        };
        MdlButtonComponent.prototype.blurIt = function () {
            callNative(this.element, "blur");
        };
        return MdlButtonComponent;
    }());
    MdlButtonComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-button, button[mdl-button], a[mdl-button]",
                    exportAs: "mdlButton",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlButtonComponent.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    MdlButtonComponent.propDecorators = {
        isButton: [{ type: i0.HostBinding, args: ["class.mdl-button",] }],
        mdlButtonType: [{ type: i0.Input, args: ["mdl-button-type",] }],
        mdlColoredType: [{ type: i0.Input, args: ["mdl-colored",] }],
        isDisable: [{ type: i0.HostBinding, args: ["attr.disabled",] }],
        raised: [{ type: i0.HostBinding, args: ["class.mdl-button--raised",] }],
        fab: [{ type: i0.HostBinding, args: ["class.mdl-button--fab",] }],
        miniFab: [{ type: i0.HostBinding, args: ["class.mdl-button--mini-fab",] }],
        icon: [{ type: i0.HostBinding, args: ["class.mdl-button--icon",] }],
        primary: [{ type: i0.HostBinding, args: ["class.mdl-button--primary",] }],
        accent: [{ type: i0.HostBinding, args: ["class.mdl-button--accent",] }],
        disabled: [{ type: i0.Input }],
        onMouseUp: [{ type: i0.HostListener, args: ["mouseup",] }],
        onMouseLeave: [{ type: i0.HostListener, args: ["mouseleave",] }]
    };

    var MDL_BUTTON_DIRECTIVES = [MdlButtonComponent];
    var MdlButtonModule = /** @class */ (function () {
        function MdlButtonModule() {
        }
        MdlButtonModule.forRoot = function () {
            return {
                ngModule: MdlButtonModule,
                providers: [],
            };
        };
        return MdlButtonModule;
    }());
    MdlButtonModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [],
                    exports: MDL_BUTTON_DIRECTIVES,
                    declarations: MDL_BUTTON_DIRECTIVES,
                },] }
    ];

    var MdlCardComponent = /** @class */ (function () {
        function MdlCardComponent() {
            this.isCard = true;
        }
        return MdlCardComponent;
    }());
    MdlCardComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-card",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlCardComponent.propDecorators = {
        isCard: [{ type: i0.HostBinding, args: ["class.mdl-card",] }]
    };
    // eslint-disable-next-line @angular-eslint/directive-class-suffix
    var MdlCardChildStructure = /** @class */ (function () {
        function MdlCardChildStructure(mdlCardComponent, childComponentName) {
            this.mdlCardComponent = mdlCardComponent;
            this.childComponentName = childComponentName;
        }
        MdlCardChildStructure.prototype.ngOnInit = function () {
            if (this.mdlCardComponent === null) {
                throw new MdlStructureError(this.childComponentName, "mdl-card");
            }
        };
        return MdlCardChildStructure;
    }());
    MdlCardChildStructure.decorators = [
        { type: i0.Directive }
    ];
    MdlCardChildStructure.ctorParameters = function () { return [
        { type: MdlCardComponent },
        { type: String }
    ]; };
    var MdlCardTitleComponent = /** @class */ (function (_super) {
        __extends(MdlCardTitleComponent, _super);
        function MdlCardTitleComponent(mdlCardComponent) {
            var _this = _super.call(this, mdlCardComponent, "mdl-card-title") || this;
            _this.isCardTitle = true;
            return _this;
        }
        return MdlCardTitleComponent;
    }(MdlCardChildStructure));
    MdlCardTitleComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-card-title",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlCardTitleComponent.ctorParameters = function () { return [
        { type: MdlCardComponent, decorators: [{ type: i0.Optional }] }
    ]; };
    MdlCardTitleComponent.propDecorators = {
        isCardTitle: [{ type: i0.HostBinding, args: ["class.mdl-card__title",] }]
    };
    var MdlCardSupportingTextComponent = /** @class */ (function (_super) {
        __extends(MdlCardSupportingTextComponent, _super);
        function MdlCardSupportingTextComponent(mdlCardComponent) {
            var _this = _super.call(this, mdlCardComponent, "mdl-card-supporting-text") || this;
            _this.isSupportingText = true;
            return _this;
        }
        return MdlCardSupportingTextComponent;
    }(MdlCardChildStructure));
    MdlCardSupportingTextComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-card-supporting-text",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlCardSupportingTextComponent.ctorParameters = function () { return [
        { type: MdlCardComponent, decorators: [{ type: i0.Optional }] }
    ]; };
    MdlCardSupportingTextComponent.propDecorators = {
        isSupportingText: [{ type: i0.HostBinding, args: ["class.mdl-card__supporting-text",] }]
    };
    var MdlCardMediaComponent = /** @class */ (function (_super) {
        __extends(MdlCardMediaComponent, _super);
        function MdlCardMediaComponent(mdlCardComponent) {
            var _this = _super.call(this, mdlCardComponent, "mdl-card-media") || this;
            _this.isCardMedia = true;
            return _this;
        }
        return MdlCardMediaComponent;
    }(MdlCardChildStructure));
    MdlCardMediaComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-card-media",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlCardMediaComponent.ctorParameters = function () { return [
        { type: MdlCardComponent, decorators: [{ type: i0.Optional }] }
    ]; };
    MdlCardMediaComponent.propDecorators = {
        isCardMedia: [{ type: i0.HostBinding, args: ["class.mdl-card__media",] }]
    };
    var MdlCardActionsComponent = /** @class */ (function (_super) {
        __extends(MdlCardActionsComponent, _super);
        function MdlCardActionsComponent(mdlCardComponent) {
            var _this = _super.call(this, mdlCardComponent, "mdl-card-actions") || this;
            _this.isCardAction = true;
            return _this;
        }
        return MdlCardActionsComponent;
    }(MdlCardChildStructure));
    MdlCardActionsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-card-actions",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlCardActionsComponent.ctorParameters = function () { return [
        { type: MdlCardComponent, decorators: [{ type: i0.Optional }] }
    ]; };
    MdlCardActionsComponent.propDecorators = {
        isCardAction: [{ type: i0.HostBinding, args: ["class.mdl-card__actions",] }]
    };
    var MdlCardMenuComponent = /** @class */ (function (_super) {
        __extends(MdlCardMenuComponent, _super);
        function MdlCardMenuComponent(mdlCardComponent) {
            var _this = _super.call(this, mdlCardComponent, "mdl-card-menu") || this;
            _this.isCardMenu = true;
            return _this;
        }
        return MdlCardMenuComponent;
    }(MdlCardChildStructure));
    MdlCardMenuComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-card-menu",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlCardMenuComponent.ctorParameters = function () { return [
        { type: MdlCardComponent, decorators: [{ type: i0.Optional }] }
    ]; };
    MdlCardMenuComponent.propDecorators = {
        isCardMenu: [{ type: i0.HostBinding, args: ["class.mdl-card__menu",] }]
    };
    var MdlCardTitleTextDirective = /** @class */ (function () {
        function MdlCardTitleTextDirective() {
            this.isCardTitleText = true;
        }
        return MdlCardTitleTextDirective;
    }());
    MdlCardTitleTextDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: '[mdl-card-title-text]'
                },] }
    ];
    MdlCardTitleTextDirective.propDecorators = {
        isCardTitleText: [{ type: i0.HostBinding, args: ["class.mdl-card__title-text",] }]
    };
    var MdlCardBorderDirective = /** @class */ (function () {
        function MdlCardBorderDirective() {
            this.isCardBorder = true;
        }
        return MdlCardBorderDirective;
    }());
    MdlCardBorderDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: '[mdl-card-border]'
                },] }
    ];
    MdlCardBorderDirective.propDecorators = {
        isCardBorder: [{ type: i0.HostBinding, args: ["class.mdl-card--border",] }]
    };
    var MdlCardExpandDirective = /** @class */ (function () {
        function MdlCardExpandDirective() {
            this.isCardExpand = true;
        }
        return MdlCardExpandDirective;
    }());
    MdlCardExpandDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: '[mdl-card-expand]'
                },] }
    ];
    MdlCardExpandDirective.propDecorators = {
        isCardExpand: [{ type: i0.HostBinding, args: ["class.mdl-card--expand",] }]
    };

    var MDL_CARD_DIRECTIVES = [
        MdlCardComponent,
        MdlCardTitleComponent,
        MdlCardMediaComponent,
        MdlCardSupportingTextComponent,
        MdlCardActionsComponent,
        MdlCardMenuComponent,
        MdlCardTitleTextDirective,
        MdlCardBorderDirective,
        MdlCardExpandDirective,
    ];
    var MdlCardModule = /** @class */ (function () {
        function MdlCardModule() {
        }
        MdlCardModule.forRoot = function () {
            return {
                ngModule: MdlCardModule,
                providers: [],
            };
        };
        return MdlCardModule;
    }());
    MdlCardModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [],
                    exports: MDL_CARD_DIRECTIVES,
                    declarations: MDL_CARD_DIRECTIVES,
                },] }
    ];

    var IS_FOCUSED$2 = "is-focused";
    var CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return MdlCheckboxComponent; }),
        multi: true,
    };
    var MdlCheckboxComponent = /** @class */ (function () {
        function MdlCheckboxComponent(elementRef, renderer) {
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.tabindex = null;
            // eslint-disable-next-line
            this.change = new i0.EventEmitter();
            this.isCheckbox = true;
            this.isUpgraded = true;
            this.onTouchedCallback = noop;
            this.onChangeCallback = noop;
            this.internalValue = false;
            this.internalDisabled = false;
            this.el = elementRef.nativeElement;
        }
        Object.defineProperty(MdlCheckboxComponent.prototype, "value", {
            get: function () {
                return this.internalValue;
            },
            set: function (v) {
                this.internalValue = v;
                this.onChangeCallback(v);
                this.change.emit(v);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlCheckboxComponent.prototype, "disabled", {
            get: function () {
                return this.internalDisabled;
            },
            set: function (value) {
                this.internalDisabled = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        MdlCheckboxComponent.prototype.onClick = function () {
            if (this.disabled) {
                return;
            }
            this.value = !this.value;
        };
        MdlCheckboxComponent.prototype.writeValue = function (value) {
            this.internalValue = value;
        };
        MdlCheckboxComponent.prototype.registerOnChange = function (fn) {
            this.onChangeCallback = fn;
        };
        MdlCheckboxComponent.prototype.registerOnTouched = function (fn) {
            this.onTouchedCallback = fn;
        };
        MdlCheckboxComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        MdlCheckboxComponent.prototype.onFocus = function () {
            this.renderer.addClass(this.el, IS_FOCUSED$2);
        };
        MdlCheckboxComponent.prototype.onBlur = function () {
            this.renderer.removeClass(this.el, IS_FOCUSED$2);
            this.onTouchedCallback();
        };
        return MdlCheckboxComponent;
    }());
    MdlCheckboxComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-checkbox",
                    providers: [CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR],
                    template: "\n    <input\n      type=\"checkbox\"\n      class=\"mdl-checkbox__input\"\n      (focus)=\"onFocus()\"\n      (blur)=\"onBlur()\"\n      [disabled]=\"disabled\"\n      [attr.tabindex]=\"tabindex\"\n      [ngModel]=\"value\"\n    />\n    <span class=\"mdl-checkbox__label\"><ng-content></ng-content></span>\n    <span class=\"mdl-checkbox__focus-helper\"></span>\n    <span class=\"mdl-checkbox__box-outline\">\n      <span class=\"mdl-checkbox__tick-outline\"></span>\n    </span>\n  ",
                    encapsulation: i0.ViewEncapsulation.None,
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    MdlCheckboxComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    MdlCheckboxComponent.propDecorators = {
        tabindex: [{ type: i0.Input }],
        change: [{ type: i0.Output }],
        isCheckbox: [{ type: i0.HostBinding, args: ["class.mdl-checkbox",] }],
        isUpgraded: [{ type: i0.HostBinding, args: ["class.is-upgraded",] }],
        value: [{ type: i0.Input }, { type: i0.HostBinding, args: ["class.is-checked",] }],
        disabled: [{ type: i0.Input }, { type: i0.HostBinding, args: ["class.is-disabled",] }],
        onClick: [{ type: i0.HostListener, args: ["click",] }]
    };

    var MDL_CHECKBOX_DIRECTIVES = [MdlCheckboxComponent];
    var MdlCheckboxModule = /** @class */ (function () {
        function MdlCheckboxModule() {
        }
        MdlCheckboxModule.forRoot = function () {
            return {
                ngModule: MdlCheckboxModule,
                providers: [],
            };
        };
        return MdlCheckboxModule;
    }());
    MdlCheckboxModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule, forms.FormsModule],
                    exports: MDL_CHECKBOX_DIRECTIVES,
                    declarations: MDL_CHECKBOX_DIRECTIVES,
                },] }
    ];

    var MdlChipComponent = /** @class */ (function () {
        function MdlChipComponent() {
            // eslint-disable-next-line
            this.actionClick = new i0.EventEmitter();
            this.isChip = true;
            this.isChipContact = false;
        }
        MdlChipComponent.prototype.action = function () {
            this.actionClick.emit();
        };
        return MdlChipComponent;
    }());
    MdlChipComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-chip",
                    template: "\n    <ng-content></ng-content>\n    <span *ngIf=\"mdlLabel\" class=\"mdl-chip__text\">{{ mdlLabel }}</span>\n    <button\n      *ngIf=\"mdlActionIcon\"\n      (click)=\"action()\"\n      type=\"button\"\n      class=\"mdl-chip__action\"\n    >\n      <mdl-icon>{{ mdlActionIcon }}</mdl-icon>\n    </button>\n  ",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlChipComponent.propDecorators = {
        mdlLabel: [{ type: i0.Input, args: ['mdl-label',] }],
        mdlActionIcon: [{ type: i0.Input, args: ['mdl-action-icon',] }],
        actionClick: [{ type: i0.Output, args: ['action-click',] }],
        isChip: [{ type: i0.HostBinding, args: ["class.mdl-chip",] }],
        isChipContact: [{ type: i0.HostBinding, args: ["class.mdl-chip--contact",] }]
    };

    var MdlChipContactDirective = /** @class */ (function () {
        function MdlChipContactDirective(mdlChipComponent) {
            this.mdlChipComponent = mdlChipComponent;
            this.isChipContact = true;
        }
        MdlChipContactDirective.prototype.ngOnInit = function () {
            if (!this.mdlChipComponent) {
                throw new MdlStructureError("mdl-chip-contact", "mdl-chip");
            }
            this.mdlChipComponent.isChipContact = true;
        };
        return MdlChipContactDirective;
    }());
    MdlChipContactDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: '[mdl-chip-contact]'
                },] }
    ];
    MdlChipContactDirective.ctorParameters = function () { return [
        { type: MdlChipComponent, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [MdlChipComponent,] }] }
    ]; };
    MdlChipContactDirective.propDecorators = {
        isChipContact: [{ type: i0.HostBinding, args: ["class.mdl-chip__contact",] }]
    };

    var DIRECTIVES = [MdlChipComponent, MdlChipContactDirective];
    var MdlChipModule = /** @class */ (function () {
        function MdlChipModule() {
        }
        MdlChipModule.forRoot = function () {
            return {
                ngModule: MdlChipModule,
                providers: [],
            };
        };
        return MdlChipModule;
    }());
    MdlChipModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [MdlIconModule, common.CommonModule],
                    exports: DIRECTIVES,
                    declarations: DIRECTIVES,
                },] }
    ];

    var MDL_CONFIGUARTION = new i0.InjectionToken("MDL_CONFIGUARTION");
    var MIN_DIALOG_Z_INDEX = 100000;

    /**
     * The reference to the created and displayed dialog.
     */
    var MdlDialogReference = /** @class */ (function () {
        function MdlDialogReference(internaleRef) {
            this.internaleRef = internaleRef;
            internaleRef.dialogRef = this;
        }
        /**
         * closes the dialog
         */
        MdlDialogReference.prototype.hide = function (data) {
            this.internaleRef.hide(data);
        };
        /**
         * Observable that emits, if the dialog was closed.
         * returns {Observable<void>}
         */
        MdlDialogReference.prototype.onHide = function () {
            return this.internaleRef.onHide();
        };
        /**
         * Observable that emits, if the dialog is really visible and not only created.
         * returns {Observable<void>}
         */
        MdlDialogReference.prototype.onVisible = function () {
            return this.internaleRef.onVisible();
        };
        return MdlDialogReference;
    }());

    var MdlSimpleDialogComponent = /** @class */ (function () {
        // why do i need forwardRef at this point, the demo LoginDialog dosn't need this!?!?
        function MdlSimpleDialogComponent(dialogConfiguration, dialog) {
            var _this = this;
            this.dialogConfiguration = dialogConfiguration;
            this.dialog = dialog;
            this.dialog = dialog;
            dialog.onVisible().subscribe(function () {
                if (_this.buttons) {
                    _this.buttons.first.elementRef.nativeElement.focus();
                }
            });
        }
        MdlSimpleDialogComponent.prototype.onEsc = function () {
            // run the first action that is marked as closing action
            var closeAction = this.dialogConfiguration.actions.find(function (action) { return action.isClosingAction; });
            if (closeAction) {
                closeAction.handler();
                this.dialog.hide();
            }
        };
        MdlSimpleDialogComponent.prototype.actionClicked = function (action) {
            action.handler();
            this.dialog.hide();
        };
        return MdlSimpleDialogComponent;
    }());
    MdlSimpleDialogComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-dialog-component",
                    template: "\n    <h3 class=\"mdl-dialog__title\" *ngIf=\"dialogConfiguration?.title\">\n      {{ dialogConfiguration?.title }}\n    </h3>\n    <div\n      class=\"mdl-dialog__content\"\n      [innerHTML]=\"dialogConfiguration?.message\"\n    ></div>\n    <div\n      class=\"mdl-dialog__actions\"\n      [ngClass]=\"{\n        'mdl-dialog__actions--full-width': dialogConfiguration?.fullWidthAction\n      }\"\n    >\n      <button\n        mdl-button\n        mdl-colored=\"primary\"\n        type=\"button\"\n        *ngFor=\"let action of dialogConfiguration?.actions\"\n        (click)=\"actionClicked(action)\"\n        [ngClass]=\"{ close: action.isClosingAction }\"\n      >\n        {{ action.text }}\n      </button>\n    </div>\n  ",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlSimpleDialogComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [i0.forwardRef(function () { return MDL_CONFIGUARTION; }),] }] },
        { type: MdlDialogReference, decorators: [{ type: i0.Inject, args: [i0.forwardRef(function () { return MdlDialogReference; }),] }] }
    ]; };
    MdlSimpleDialogComponent.propDecorators = {
        buttons: [{ type: i0.ViewChildren, args: [MdlButtonComponent,] }],
        onEsc: [{ type: i0.HostListener, args: ["keydown.esc",] }]
    };

    /**
     * Internal representation of the dialog ref. the service
     * user should not have access to the created components
     * and internal implementations.
     */
    var InternalMdlDialogReference = /** @class */ (function () {
        function InternalMdlDialogReference(config) {
            this.config = config;
            this.isModal = false;
            this.onHideSubject = new rxjs.Subject();
            this.onVisibleSubject = new rxjs.Subject();
            this.dialogRef = new MdlDialogReference(this);
        }
        Object.defineProperty(InternalMdlDialogReference.prototype, "hostDialog", {
            get: function () {
                return this.hostDialogComponentRef.instance;
            },
            enumerable: false,
            configurable: true
        });
        InternalMdlDialogReference.prototype.hide = function (data) {
            this.onHideSubject.next(data);
            this.onHideSubject.complete();
            this.closeCallback();
        };
        InternalMdlDialogReference.prototype.visible = function () {
            this.onVisibleSubject.next();
            this.onVisibleSubject.complete();
        };
        InternalMdlDialogReference.prototype.onHide = function () {
            return this.onHideSubject.asObservable();
        };
        InternalMdlDialogReference.prototype.onVisible = function () {
            return this.onVisibleSubject.asObservable();
        };
        return InternalMdlDialogReference;
    }());

    var enterTransitionDuration = 300;
    var leaveTransitionDuration = 250;
    var enterTransitionEasingCurve = "cubic-bezier(0.0, 0.0, 0.2, 1)";
    var leaveTransitionEasingCurve = "cubic-bezier(0.0, 0.0, 0.2, 1)";
    var createOpenCloseRect = function (rect) { return ({
        height: rect.top - rect.bottom,
        left: rect.left,
        top: rect.top,
        width: rect.right - rect.left,
    }); };
    var ɵ0$1 = createOpenCloseRect;
    var getCenterInScreen = function (rect) { return ({
        cx: Math.round(rect.left + rect.width / 2),
        cy: Math.round(rect.top + rect.height / 2),
    }); };
    var ɵ1 = getCenterInScreen;
    var getClientRect = function (input) {
        if (input instanceof MdlButtonComponent) {
            var elRef = input.elementRef;
            var rect = elRef.nativeElement.getBoundingClientRect();
            return createOpenCloseRect(rect);
        }
        else if (input instanceof MouseEvent) {
            var evt = input;
            // just to make it possible to test this code with a fake event - target is
            // readonly and con not be mutated.
            // eslint-disable-next-line
            var htmlElement = (evt.target || evt.testtarget);
            var rect = htmlElement.getBoundingClientRect();
            return createOpenCloseRect(rect);
        }
        return input;
    };
    var ɵ2 = getClientRect;
    // @experimental
    var MdlDialogHostComponent = /** @class */ (function () {
        function MdlDialogHostComponent(ngZone, renderer, animations, elementRef, config, internalDialogRef) {
            this.ngZone = ngZone;
            this.renderer = renderer;
            this.animations = animations;
            this.elementRef = elementRef;
            this.config = config;
            this.internalDialogRef = internalDialogRef;
            this.isDialog = true;
            this.visible = false;
            this.zIndex = MIN_DIALOG_Z_INDEX + 1;
            this.showAnimationStartStyle = {
                top: "38%",
                opacity: "0",
            };
            this.showStyle = {
                top: "50%",
                opacity: "1",
            };
            this.hideAnimationEndStyle = {
                top: "63%",
                opacity: "0",
            };
        }
        MdlDialogHostComponent.prototype.show = function () {
            var _this = this;
            this.visible = true;
            // give the dialogs time to draw so that a focus can be set
            setTimeout(function () {
                _this.internalDialogRef.visible();
            });
            if (this.isAnimateEnabled()) {
                if (this.config.openFrom || this.config.closeTo) {
                    // transform is modified during anmiation and must be part of each animation keyframe.
                    this.showStyle.transform = "translate(0, -50%) scale(1.0)";
                    var targetClientRect = this.elementRef.nativeElement.getBoundingClientRect();
                    var openFromRect = getClientRect(this.config.openFrom);
                    var closeToRect = this.config.closeTo
                        ? getClientRect(this.config.closeTo)
                        : openFromRect;
                    var centerTarget = getCenterInScreen(targetClientRect);
                    var centerFrom = getCenterInScreen(openFromRect);
                    var centerTo = getCenterInScreen(closeToRect);
                    var translationFrom = {
                        x: Math.round(centerFrom.cx - centerTarget.cx),
                        y: Math.round(centerFrom.cy - centerTarget.cy),
                        scaleX: Math.round(100 * Math.min(0.25, openFromRect.width / targetClientRect.width)) / 100,
                        scaleY: Math.round(100 *
                            Math.min(0.25, openFromRect.height / targetClientRect.height)) / 100,
                    };
                    this.showAnimationStartStyle = {
                        top: targetClientRect.top + "px",
                        opacity: "0",
                        transform: "translate(" + translationFrom.x + "px, " + translationFrom.y + "px) scale(" + translationFrom.scaleX + ", " + translationFrom.scaleY + ")",
                    };
                    var translationTo = {
                        x: Math.round(centerTo.cx - centerTarget.cx),
                        y: Math.round(centerTo.cy - centerTarget.cy),
                        scaleX: Math.round(100 * Math.min(0.25, closeToRect.width / targetClientRect.width)) / 100,
                        scaleY: Math.round(100 * Math.min(0.25, closeToRect.height / targetClientRect.height)) / 100,
                    };
                    this.hideAnimationEndStyle = {
                        top: targetClientRect.top + "px",
                        opacity: "0",
                        transform: "translate(" + translationTo.x + "px, " + translationTo.y + "px) scale(" + translationTo.scaleX + ", " + translationTo.scaleY + ")",
                    };
                }
                var animation = this.animations.animate(this.elementRef.nativeElement, [this.showAnimationStartStyle, this.showStyle], this.config.enterTransitionDuration || enterTransitionDuration, this.config.enterTransitionEasingCurve || enterTransitionEasingCurve);
                animation.play();
            }
        };
        MdlDialogHostComponent.prototype.hide = function (selfComponentRef) {
            if (this.isAnimateEnabled()) {
                var animation = this.animations.animate(this.elementRef.nativeElement, [this.showStyle, this.hideAnimationEndStyle], this.config.leaveTransitionDuration || leaveTransitionDuration, this.config.leaveTransitionEasingCurve || leaveTransitionEasingCurve);
                animation.onDone(function () {
                    selfComponentRef.destroy();
                });
                animation.play();
            }
            else {
                selfComponentRef.destroy();
            }
        };
        MdlDialogHostComponent.prototype.ngOnInit = function () {
            this.applyStyle(this.config.styles);
            this.applyClasses(this.config.classes ? this.config.classes : "");
        };
        MdlDialogHostComponent.prototype.applyStyle = function (styles) {
            var e_1, _a;
            if (styles) {
                try {
                    for (var _b = __values(Object.keys(styles)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var style = _c.value;
                        this.renderer.setStyle(this.elementRef.nativeElement, style, styles[style]);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        };
        MdlDialogHostComponent.prototype.applyClasses = function (classes) {
            var _this = this;
            classes
                .split(" ")
                .filter(function (cssClass) { return !!cssClass; })
                .forEach(function (cssClass) {
                _this.renderer.addClass(_this.elementRef.nativeElement, cssClass);
            });
        };
        MdlDialogHostComponent.prototype.isAnimateEnabled = function () {
            // not present?  assume it is true.
            if (typeof this.config.animate === "undefined") {
                return true;
            }
            return this.config.animate;
        };
        return MdlDialogHostComponent;
    }());
    MdlDialogHostComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-dialog-host-component",
                    template: " <div #dialogTarget></div>",
                    encapsulation: i0.ViewEncapsulation.None,
                    styles: ["\n      mdl-dialog-host-component {\n        width: fit-content;\n        height: fit-content;\n        padding: 1em;\n        background: white;\n        color: black;\n        opacity: 1;\n        visibility: hidden;\n        display: block;\n        position: fixed;\n        margin: auto;\n        left: 0;\n        right: 0;\n        transition: all;\n        top: 50%;\n        transform: translate(0, -50%);\n      }\n\n      mdl-dialog-host-component.open {\n        visibility: visible;\n      }\n    "]
                },] }
    ];
    MdlDialogHostComponent.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: i0.Renderer2 },
        { type: Animations },
        { type: i0.ElementRef },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i0.forwardRef(function () { return MDL_CONFIGUARTION; }),] }] },
        { type: InternalMdlDialogReference }
    ]; };
    MdlDialogHostComponent.propDecorators = {
        dialogTarget: [{ type: i0.ViewChild, args: ["dialogTarget", { read: i0.ViewContainerRef, static: true },] }],
        isDialog: [{ type: i0.HostBinding, args: ["class.mdl-dialog",] }],
        visible: [{ type: i0.HostBinding, args: ["class.open",] }],
        zIndex: [{ type: i0.HostBinding, args: ["style.zIndex",] }]
    };

    var MdlBackdropOverlayComponent = /** @class */ (function () {
        function MdlBackdropOverlayComponent(ngZone) {
            this.ngZone = ngZone;
            this.zIndex = 0;
            this.isBackdrop = true;
            this.clickEmitter = new i0.EventEmitter();
            this.visible = false;
        }
        Object.defineProperty(MdlBackdropOverlayComponent.prototype, "display", {
            get: function () {
                return this.visible ? null : "none";
            },
            enumerable: false,
            configurable: true
        });
        MdlBackdropOverlayComponent.prototype.onBackdropClick = function (e) {
            var _this = this;
            // this event runs not in angular zone of the main app. make sure it runs in the main angular zone
            // and change detection works
            this.ngZone.run(function () {
                _this.clickEmitter.emit();
            });
            e.stopPropagation();
        };
        MdlBackdropOverlayComponent.prototype.hide = function () {
            this.visible = false;
        };
        MdlBackdropOverlayComponent.prototype.showWithZIndex = function (zIndex) {
            this.zIndex = zIndex;
            this.visible = true;
        };
        return MdlBackdropOverlayComponent;
    }());
    MdlBackdropOverlayComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-backdrop-overlay",
                    template: "",
                    encapsulation: i0.ViewEncapsulation.None,
                    styles: ["\n      .dialog-backdrop {\n        position: fixed;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        background: rgba(0, 0, 0, 0.1);\n      }\n    "]
                },] }
    ];
    MdlBackdropOverlayComponent.ctorParameters = function () { return [
        { type: i0.NgZone }
    ]; };
    MdlBackdropOverlayComponent.propDecorators = {
        zIndex: [{ type: i0.HostBinding, args: ["style.zIndex",] }],
        isBackdrop: [{ type: i0.HostBinding, args: ["class.dialog-backdrop",] }],
        display: [{ type: i0.HostBinding, args: ["style.display",] }],
        onBackdropClick: [{ type: i0.HostListener, args: ["click", ["$event"],] }]
    };

    // the componnet is used outside the app-root. injecting MdlDialogService would not work
    // this component is not exported - needs to be instanciated by
    //    let x = this.appRef.bootstrap(MdlDialogOutletComponent);
    var MdlDialogOutletComponent = /** @class */ (function () {
        function MdlDialogOutletComponent(vCRef) {
            this.vCRef = vCRef;
        }
        Object.defineProperty(MdlDialogOutletComponent.prototype, "viewContainerRef", {
            get: function () {
                return this.vCRef;
            },
            enumerable: false,
            configurable: true
        });
        return MdlDialogOutletComponent;
    }());
    MdlDialogOutletComponent.decorators = [
        { type: i0.Component, args: [{
                    // eslint-disable-next-line
                    selector: 'dialog-outlet',
                    template: ""
                },] }
    ];
    MdlDialogOutletComponent.ctorParameters = function () { return [
        { type: i0.ViewContainerRef }
    ]; };

    var MdlDialogOutletService = /** @class */ (function () {
        function MdlDialogOutletService(appRef, componentFactoryResolver) {
            var _this = this;
            this.appRef = appRef;
            this.componentFactoryResolver = componentFactoryResolver;
            this.backdropClickEmitter = new i0.EventEmitter();
            this.viewContainerRefInternal = null;
            var dialogOutletCompRef = null;
            appRef.isStable
                .pipe(operators.take(1), operators.filter(function () { return _this.viewContainerRefInternal == null; }))
                .subscribe(function () {
                try {
                    dialogOutletCompRef = _this.appRef.bootstrap(MdlDialogOutletComponent);
                }
                catch (e) {
                    // the user did not use the dialog.outlet element outside of his root app.
                    // console.log(e);
                }
                if (dialogOutletCompRef) {
                    _this.setViewContainerRef(dialogOutletCompRef.instance.viewContainerRef);
                }
            });
        }
        Object.defineProperty(MdlDialogOutletService.prototype, "viewContainerRef", {
            get: function () {
                return this.viewContainerRefInternal;
            },
            enumerable: false,
            configurable: true
        });
        MdlDialogOutletService.prototype.setDefaultViewContainerRef = function (vCRef) {
            this.setViewContainerRef(vCRef);
        };
        MdlDialogOutletService.prototype.hideBackdrop = function () {
            this.backdropComponent.hide();
        };
        MdlDialogOutletService.prototype.showBackdropWithZIndex = function (zIndex) {
            this.backdropComponent.showWithZIndex(zIndex);
        };
        MdlDialogOutletService.prototype.setViewContainerRef = function (value) {
            var _this = this;
            this.viewContainerRefInternal = value;
            if (this.viewContainerRefInternal) {
                var cFactory = this.componentFactoryResolver.resolveComponentFactory(MdlBackdropOverlayComponent);
                this.backdropComponent = this.viewContainerRefInternal.createComponent(cFactory).instance;
                this.backdropComponent.clickEmitter.subscribe(function () {
                    _this.backdropClickEmitter.emit();
                });
            }
        };
        return MdlDialogOutletService;
    }());
    MdlDialogOutletService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function MdlDialogOutletService_Factory() { return new MdlDialogOutletService(i0__namespace.ɵɵinject(i0__namespace.ApplicationRef), i0__namespace.ɵɵinject(i0__namespace.ComponentFactoryResolver)); }, token: MdlDialogOutletService, providedIn: "root" });
    MdlDialogOutletService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: "root",
                },] }
    ];
    MdlDialogOutletService.ctorParameters = function () { return [
        { type: i0.ApplicationRef },
        { type: i0.ComponentFactoryResolver }
    ]; };

    /**
     * The MdlDialogService is used to open different kind of dialogs. SimpleDialogs and Custom Dialogs.
     *
     * @experimental
     */
    var MdlDialogService = /** @class */ (function () {
        function MdlDialogService(componentFactoryResolver, mdlDialogOutletService, injector) {
            var _this = this;
            this.componentFactoryResolver = componentFactoryResolver;
            this.mdlDialogOutletService = mdlDialogOutletService;
            this.injector = injector;
            /**
             * Emits an event when either all modals are closed, or one gets opened.
             *
             * @returns A subscribable event emitter that provides a boolean indicating whether a modal is open or not.
             */
            this.onDialogsOpenChanged = new i0.EventEmitter();
            this.openDialogs = new Array();
            this.mdlDialogOutletService.backdropClickEmitter.subscribe(function () {
                _this.onBackdropClick();
            });
        }
        /**
         * Shows a dialog that is just an alert - e.g. with one button.
         *
         * @param alertMessage The message that should be displayed.
         * @param okText The text that the button should have
         * @param title The optional title of the dialog
         * returns An Observable that is called if the user hits the Ok button.
         */
        MdlDialogService.prototype.alert = function (alertMessage, okText, title) {
            if (okText === void 0) { okText = "Ok"; }
            var result = new rxjs.Subject();
            this.showDialog({
                title: title,
                message: alertMessage,
                actions: [
                    {
                        handler: function () {
                            result.next(null);
                            result.complete();
                        },
                        text: okText,
                    },
                ],
                isModal: true,
            });
            return result;
        };
        /**
         * Shows a dialog that is just a confirm message - e.g. with two button.
         *
         * @param question The question that should be displayed.
         * @param title The title that should be displayed on top of Question.
         * @param declineText The text for decline button. defaults to Cancel
         * @param confirmText The text for the confirm button . defaults to Ok
         * returns An Observable that is called if the user hits the Ok button.
         */
        MdlDialogService.prototype.confirm = function (question, declineText, confirmText, title) {
            if (declineText === void 0) { declineText = "Cancel"; }
            if (confirmText === void 0) { confirmText = "Ok"; }
            var result = new rxjs.Subject();
            this.showDialog({
                title: title,
                message: question,
                actions: [
                    {
                        handler: function () {
                            result.next(null);
                            result.complete();
                        },
                        text: confirmText,
                    },
                    {
                        handler: function () {
                            result.error(null);
                        },
                        text: declineText,
                        isClosingAction: true,
                    },
                ],
                isModal: true,
            });
            return result.asObservable();
        };
        /**
         * Shows a dialog that is specified by the provided configuration.
         *
         * @param config The simple dialog configuration.
         * returns An Observable that returns the MdlDialogReference.
         */
        MdlDialogService.prototype.showDialog = function (config) {
            if (config.actions.length === 0) {
                throw new Error("a dialog mus have at least one action");
            }
            var internalDialogRef = new InternalMdlDialogReference(config);
            var providers = [
                {
                    provide: MdlDialogReference,
                    useValue: new MdlDialogReference(internalDialogRef),
                },
                { provide: MDL_CONFIGUARTION, useValue: config },
            ];
            var hostComponentRef = this.createHostDialog(internalDialogRef, config);
            this.createComponentInstance(hostComponentRef.instance.dialogTarget, providers, MdlSimpleDialogComponent);
            return this.showHostDialog(internalDialogRef.dialogRef, hostComponentRef);
        };
        /**
         * Shows a dialog that is specified by the provided configuration.
         *
         * @param config The custom dialog configuration.
         * returns An Observable that returns the MdlDialogReference.
         */
        MdlDialogService.prototype.showCustomDialog = function (config) {
            var internalDialogRef = new InternalMdlDialogReference(config);
            var providers = [
                {
                    provide: MdlDialogReference,
                    useValue: new MdlDialogReference(internalDialogRef),
                },
            ];
            if (config.providers) {
                providers.push.apply(providers, __spreadArray([], __read(config.providers)));
            }
            var hostComponentRef = this.createHostDialog(internalDialogRef, config);
            this.createComponentInstance(hostComponentRef.instance.dialogTarget, providers, config.component);
            return this.showHostDialog(internalDialogRef.dialogRef, hostComponentRef);
        };
        MdlDialogService.prototype.showDialogTemplate = function (template, config) {
            var internalDialogRef = new InternalMdlDialogReference(config);
            var hostComponentRef = this.createHostDialog(internalDialogRef, config);
            hostComponentRef.instance.dialogTarget.createEmbeddedView(template);
            return this.showHostDialog(internalDialogRef.dialogRef, hostComponentRef);
        };
        MdlDialogService.prototype.showHostDialog = function (dialogRef, hostComponentRef) {
            var result = new rxjs.Subject();
            setTimeout(function () {
                result.next(dialogRef);
                result.complete();
                hostComponentRef.instance.show();
            });
            return result.asObservable();
        };
        MdlDialogService.prototype.createHostDialog = function (internalDialogRef, dialogConfig) {
            var _this = this;
            var viewContainerRef = this.mdlDialogOutletService.viewContainerRef;
            if (!viewContainerRef) {
                throw new Error("You did not provide a ViewContainerRef. " +
                    "Please see https://github.com/mseemann/angular2-mdl/wiki/How-to-use-the-MdlDialogService");
            }
            var providers = [
                { provide: MDL_CONFIGUARTION, useValue: dialogConfig },
                { provide: InternalMdlDialogReference, useValue: internalDialogRef },
            ];
            var hostDialogComponent = this.createComponentInstance(viewContainerRef, providers, MdlDialogHostComponent);
            internalDialogRef.hostDialogComponentRef = hostDialogComponent;
            internalDialogRef.isModal = dialogConfig.isModal;
            internalDialogRef.closeCallback = function () {
                _this.popDialog(internalDialogRef);
                hostDialogComponent.instance.hide(hostDialogComponent);
            };
            this.pushDialog(internalDialogRef);
            return hostDialogComponent;
        };
        MdlDialogService.prototype.pushDialog = function (dialogRef) {
            if (this.openDialogs.length === 0) {
                // first dialog being opened
                this.onDialogsOpenChanged.emit(true);
            }
            this.openDialogs.push(dialogRef);
            this.orderDialogStack();
        };
        MdlDialogService.prototype.popDialog = function (dialogRef) {
            this.openDialogs.splice(this.openDialogs.indexOf(dialogRef), 1);
            this.orderDialogStack();
            if (this.openDialogs.length === 0) {
                // last dialog being closed
                this.onDialogsOpenChanged.emit(false);
            }
        };
        MdlDialogService.prototype.orderDialogStack = function () {
            // +1 because the overlay may have MIN_DIALOG_Z_INDEX if the dialog is modal.
            var zIndex = MIN_DIALOG_Z_INDEX + 1;
            this.openDialogs.forEach(function (iDialogRef) {
                iDialogRef.hostDialog.zIndex = zIndex;
                // +2 to make room for the overlay if a dialog is modal
                zIndex += 2;
            });
            this.mdlDialogOutletService.hideBackdrop();
            // if there is a modal dialog append the overloay to the dom - if not remove the overlay from the body
            var topMostModalDialog = this.getTopMostInternalDialogRef();
            if (topMostModalDialog) {
                // move the overlay diredct under the topmos modal dialog
                this.mdlDialogOutletService.showBackdropWithZIndex(topMostModalDialog.hostDialog.zIndex - 1);
            }
        };
        MdlDialogService.prototype.getTopMostInternalDialogRef = function () {
            var topMostModalDialog = null;
            for (var i = this.openDialogs.length - 1; i >= 0; i--) {
                if (this.openDialogs[i].isModal) {
                    topMostModalDialog = this.openDialogs[i];
                    break;
                }
            }
            return topMostModalDialog;
        };
        MdlDialogService.prototype.onBackdropClick = function () {
            var topMostModalDialog = this.getTopMostInternalDialogRef();
            if (topMostModalDialog.config.clickOutsideToClose) {
                topMostModalDialog.hide();
            }
        };
        MdlDialogService.prototype.createComponentInstance = function (viewContainerRef, providers, component) {
            var cFactory = this.componentFactoryResolver.resolveComponentFactory(component);
            var injector = i0.Injector.create({
                providers: __spreadArray(__spreadArray([], __read(providers)), [
                    { provide: i0.ViewContainerRef, useValue: viewContainerRef },
                ]),
                parent: this.injector,
            });
            return viewContainerRef.createComponent(cFactory, viewContainerRef.length, injector);
        };
        return MdlDialogService;
    }());
    MdlDialogService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function MdlDialogService_Factory() { return new MdlDialogService(i0__namespace.ɵɵinject(i0__namespace.ComponentFactoryResolver), i0__namespace.ɵɵinject(MdlDialogOutletService), i0__namespace.ɵɵinject(i0__namespace.INJECTOR)); }, token: MdlDialogService, providedIn: "root" });
    MdlDialogService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: "root",
                },] }
    ];
    MdlDialogService.ctorParameters = function () { return [
        { type: i0.ComponentFactoryResolver },
        { type: MdlDialogOutletService },
        { type: i0.Injector }
    ]; };

    var MdlDialogComponent = /** @class */ (function () {
        function MdlDialogComponent(dialogService) {
            this.dialogService = dialogService;
            // eslint-disable-next-line
            this.showEmitter = new i0.EventEmitter();
            // eslint-disable-next-line
            this.hideEmitter = new i0.EventEmitter();
            this.isShown = false;
            this.dialogRef = null;
        }
        MdlDialogComponent.prototype.show = function () {
            var _this = this;
            if (this.isShown) {
                throw new Error("Only one instance of an embedded mdl-dialog can exist!");
            }
            this.isShown = true;
            var mergedConfig = this.config || {};
            // default is true
            if (typeof mergedConfig.isModal === "undefined") {
                mergedConfig.isModal = true;
            }
            var result = new rxjs.Subject();
            var p = this.dialogService.showDialogTemplate(this.template, mergedConfig);
            p.subscribe(function (dialogRef) {
                _this.dialogRef = dialogRef;
                _this.dialogRef.onVisible().subscribe(function () {
                    _this.showEmitter.emit(dialogRef);
                    result.next(dialogRef);
                    result.complete();
                });
                _this.dialogRef.onHide().subscribe(function () {
                    _this.hideEmitter.emit(null);
                    _this.dialogRef = null;
                    _this.isShown = false;
                });
            });
            return result.asObservable();
        };
        MdlDialogComponent.prototype.close = function () {
            if (this.dialogRef) {
                this.dialogRef.hide();
            }
        };
        return MdlDialogComponent;
    }());
    MdlDialogComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-dialog",
                    template: "\n    <div *dialogTemplate>\n      <ng-content></ng-content>\n    </div>\n  ",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlDialogComponent.ctorParameters = function () { return [
        { type: MdlDialogService }
    ]; };
    MdlDialogComponent.propDecorators = {
        template: [{ type: i0.ViewChild, args: [i0.TemplateRef, { static: true },] }],
        config: [{ type: i0.Input, args: ['mdl-dialog-config',] }],
        showEmitter: [{ type: i0.Output, args: ['show',] }],
        hideEmitter: [{ type: i0.Output, args: ['hide',] }]
    };

    var MdlAlertComponent = /** @class */ (function () {
        function MdlAlertComponent(mdlDialogService) {
            this.mdlDialogService = mdlDialogService;
            this.display = "none";
            this.confirmed = new i0.EventEmitter();
        }
        MdlAlertComponent.prototype.show = function () {
            var _this = this;
            this.mdlDialogService
                .alert(this.message, this.okText, this.title)
                .subscribe(function () {
                _this.confirmed.emit();
            });
        };
        return MdlAlertComponent;
    }());
    MdlAlertComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-alert",
                    template: "",
                    exportAs: "mdlAlert"
                },] }
    ];
    MdlAlertComponent.ctorParameters = function () { return [
        { type: MdlDialogService }
    ]; };
    MdlAlertComponent.propDecorators = {
        title: [{ type: i0.Input }],
        message: [{ type: i0.Input }],
        okText: [{ type: i0.Input }],
        display: [{ type: i0.HostBinding, args: ["style.display",] }],
        confirmed: [{ type: i0.Output }]
    };

    // the component is used inside the app-root. this is possible because this component
    var MdlDialogInnerOutletComponent = /** @class */ (function () {
        function MdlDialogInnerOutletComponent(vCRef, service) {
            this.vCRef = vCRef;
            service.setDefaultViewContainerRef(vCRef);
        }
        return MdlDialogInnerOutletComponent;
    }());
    MdlDialogInnerOutletComponent.decorators = [
        { type: i0.Component, args: [{
                    // eslint-disable-next-line
                    selector: 'dialog-outlet',
                    template: ""
                },] }
    ];
    MdlDialogInnerOutletComponent.ctorParameters = function () { return [
        { type: i0.ViewContainerRef },
        { type: MdlDialogOutletService, decorators: [{ type: i0.Inject, args: [i0.forwardRef(function () { return MdlDialogOutletService; }),] }] }
    ]; };

    var PUBLIC_COMPONENTS$1 = [MdlDialogInnerOutletComponent];
    var PRIVATE_COMPONENTS$1 = [
        MdlDialogOutletComponent,
        MdlBackdropOverlayComponent,
    ];
    var MdlDialogOutletModule = /** @class */ (function () {
        function MdlDialogOutletModule() {
        }
        MdlDialogOutletModule.forRoot = function () {
            return {
                ngModule: MdlDialogOutletModule,
                providers: [MdlDialogOutletService],
            };
        };
        return MdlDialogOutletModule;
    }());
    MdlDialogOutletModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [],
                    exports: PUBLIC_COMPONENTS$1,
                    declarations: __spreadArray(__spreadArray([], __read(PUBLIC_COMPONENTS$1)), __read(PRIVATE_COMPONENTS$1)),
                    entryComponents: [MdlDialogOutletComponent, MdlBackdropOverlayComponent],
                },] }
    ];

    var PUBLIC_COMPONENTS = [MdlDialogComponent, MdlAlertComponent];
    var PRIVATE_COMPONENTS = [MdlDialogHostComponent, MdlSimpleDialogComponent];
    var MdlDialogModule = /** @class */ (function () {
        function MdlDialogModule() {
        }
        MdlDialogModule.forRoot = function () {
            return {
                ngModule: MdlDialogModule,
                providers: [MdlDialogService, MdlDialogOutletService],
            };
        };
        return MdlDialogModule;
    }());
    MdlDialogModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        MdlCommonsModule,
                        MdlButtonModule,
                        MdlDialogOutletModule,
                    ],
                    exports: __spreadArray([], __read(PUBLIC_COMPONENTS)),
                    declarations: __spreadArray(__spreadArray([], __read(PUBLIC_COMPONENTS)), __read(PRIVATE_COMPONENTS)),
                    entryComponents: __spreadArray(__spreadArray([], __read(PUBLIC_COMPONENTS)), __read(PRIVATE_COMPONENTS)),
                },] }
    ];

    var MdlIconToggleComponent = /** @class */ (function (_super) {
        __extends(MdlIconToggleComponent, _super);
        function MdlIconToggleComponent(elementRef, renderer) {
            var _this = _super.call(this, elementRef, renderer) || this;
            _this.isIconToggle = true;
            _this.isCheckbox = false;
            return _this;
        }
        return MdlIconToggleComponent;
    }(MdlCheckboxComponent));
    MdlIconToggleComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-icon-toggle",
                    providers: [
                        {
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: i0.forwardRef(function () { return MdlIconToggleComponent; }),
                            multi: true,
                        },
                    ],
                    template: "\n    <input\n      type=\"checkbox\"\n      class=\"mdl-icon-toggle__input\"\n      (focus)=\"onFocus()\"\n      (blur)=\"onBlur()\"\n      [disabled]=\"disabled\"\n      [(ngModel)]=\"value\"\n    />\n    <mdl-icon class=\"mdl-icon-toggle__label\">\n      <ng-content></ng-content>\n    </mdl-icon>\n  ",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlIconToggleComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    MdlIconToggleComponent.propDecorators = {
        isIconToggle: [{ type: i0.HostBinding, args: ["class.mdl-icon-toggle",] }]
    };

    var MDL_ICON_TOGGLE_DIRECTIVES = [MdlIconToggleComponent];
    var MdlIconToggleModule = /** @class */ (function () {
        function MdlIconToggleModule() {
        }
        MdlIconToggleModule.forRoot = function () {
            return {
                ngModule: MdlIconToggleModule,
                providers: [],
            };
        };
        return MdlIconToggleModule;
    }());
    MdlIconToggleModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [MdlIconModule, common.CommonModule, forms.FormsModule],
                    exports: MDL_ICON_TOGGLE_DIRECTIVES,
                    declarations: MDL_ICON_TOGGLE_DIRECTIVES,
                },] }
    ];

    var MdlUnsupportedCountOfListItemLinesError = /** @class */ (function (_super) {
        __extends(MdlUnsupportedCountOfListItemLinesError, _super);
        function MdlUnsupportedCountOfListItemLinesError(lines) {
            /* istanbul ignore next */
            return _super.call(this, "\"" + lines + "\" is not supported - max 3 lines please.") || this;
        }
        return MdlUnsupportedCountOfListItemLinesError;
    }(MdlError));
    var MdlListComponent = /** @class */ (function () {
        function MdlListComponent() {
            this.isMdlList = true;
        }
        return MdlListComponent;
    }());
    MdlListComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-list",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlListComponent.propDecorators = {
        isMdlList: [{ type: i0.HostBinding, args: ["class.mdl-list",] }]
    };
    var MdlListItemComponent = /** @class */ (function () {
        function MdlListItemComponent() {
            this.isMdlListItem = true;
            this.linesIntern = 1;
        }
        Object.defineProperty(MdlListItemComponent.prototype, "lines", {
            get: function () {
                return this.linesIntern;
            },
            set: function (value) {
                this.linesIntern = toNumber(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlListItemComponent.prototype, "lines2", {
            get: function () {
                return this.lines === 2;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlListItemComponent.prototype, "lines3", {
            get: function () {
                return this.lines === 3;
            },
            enumerable: false,
            configurable: true
        });
        MdlListItemComponent.prototype.ngOnChanges = function () {
            if (this.lines && this.lines > 3) {
                throw new MdlUnsupportedCountOfListItemLinesError(this.lines);
            }
        };
        return MdlListItemComponent;
    }());
    MdlListItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-list-item",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlListItemComponent.propDecorators = {
        isMdlListItem: [{ type: i0.HostBinding, args: ["class.mdl-list__item",] }],
        lines: [{ type: i0.Input }],
        lines2: [{ type: i0.HostBinding, args: ["class.mdl-list__item--two-line",] }],
        lines3: [{ type: i0.HostBinding, args: ["class.mdl-list__item--three-line",] }]
    };
    var MdlListItemPrimaryContentComponent = /** @class */ (function () {
        function MdlListItemPrimaryContentComponent(mdlListItemComponent) {
            this.mdlListItemComponent = mdlListItemComponent;
            this.isPrimaryContent = true;
        }
        MdlListItemPrimaryContentComponent.prototype.ngOnInit = function () {
            if (this.mdlListItemComponent === null) {
                throw new MdlStructureError("mdl-list-item-primary-content", "mdl-list-item");
            }
        };
        return MdlListItemPrimaryContentComponent;
    }());
    MdlListItemPrimaryContentComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-list-item-primary-content",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlListItemPrimaryContentComponent.ctorParameters = function () { return [
        { type: MdlListItemComponent, decorators: [{ type: i0.Optional }] }
    ]; };
    MdlListItemPrimaryContentComponent.propDecorators = {
        isPrimaryContent: [{ type: i0.HostBinding, args: ["class.mdl-list__item-primary-content",] }]
    };
    var MdlListItemSecondaryContentComponent = /** @class */ (function () {
        function MdlListItemSecondaryContentComponent(mdlListItemComponent) {
            this.mdlListItemComponent = mdlListItemComponent;
            this.isSecondaryContent = true;
        }
        MdlListItemSecondaryContentComponent.prototype.ngOnInit = function () {
            if (this.mdlListItemComponent === null) {
                throw new MdlStructureError("mdl-list-item-secondary-content", "mdl-list-item");
            }
        };
        return MdlListItemSecondaryContentComponent;
    }());
    MdlListItemSecondaryContentComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-list-item-secondary-content",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlListItemSecondaryContentComponent.ctorParameters = function () { return [
        { type: MdlListItemComponent, decorators: [{ type: i0.Optional }] }
    ]; };
    MdlListItemSecondaryContentComponent.propDecorators = {
        isSecondaryContent: [{ type: i0.HostBinding, args: ["class.mdl-list__item-secondary-content",] }]
    };
    var MdlListItemSecondaryActionComponent = /** @class */ (function () {
        function MdlListItemSecondaryActionComponent(mdlListItemComponent) {
            this.mdlListItemComponent = mdlListItemComponent;
            this.isSecondaryAction = true;
        }
        MdlListItemSecondaryActionComponent.prototype.ngOnInit = function () {
            if (this.mdlListItemComponent === null) {
                throw new MdlStructureError("mdl-list-item-secondary-action", "mdl-list-item");
            }
        };
        return MdlListItemSecondaryActionComponent;
    }());
    MdlListItemSecondaryActionComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-list-item-secondary-action",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlListItemSecondaryActionComponent.ctorParameters = function () { return [
        { type: MdlListItemComponent, decorators: [{ type: i0.Optional }] }
    ]; };
    MdlListItemSecondaryActionComponent.propDecorators = {
        isSecondaryAction: [{ type: i0.HostBinding, args: ["class.mdl-list__item-secondary-action",] }]
    };
    var MdlListItemSubTitleComponent = /** @class */ (function () {
        function MdlListItemSubTitleComponent(mdlListItemComponent) {
            this.mdlListItemComponent = mdlListItemComponent;
            this.isSubTitle = true;
        }
        MdlListItemSubTitleComponent.prototype.ngOnInit = function () {
            if (this.mdlListItemComponent === null) {
                throw new MdlStructureError("mdl-list-item-sub-title", "mdl-list-item-primary-content");
            }
        };
        return MdlListItemSubTitleComponent;
    }());
    MdlListItemSubTitleComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-list-item-sub-title",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlListItemSubTitleComponent.ctorParameters = function () { return [
        { type: MdlListItemPrimaryContentComponent, decorators: [{ type: i0.Optional }] }
    ]; };
    MdlListItemSubTitleComponent.propDecorators = {
        isSubTitle: [{ type: i0.HostBinding, args: ["class.mdl-list__item-sub-title",] }]
    };
    var MdlListItemSecondaryInfoComponent = /** @class */ (function () {
        function MdlListItemSecondaryInfoComponent(mdlListItemComponent) {
            this.mdlListItemComponent = mdlListItemComponent;
            this.isSecondaryInfo = true;
        }
        MdlListItemSecondaryInfoComponent.prototype.ngOnInit = function () {
            if (this.mdlListItemComponent === null) {
                throw new MdlStructureError("mdl-list-item-secondary-info", "mdl-list-item-secondary-content");
            }
        };
        return MdlListItemSecondaryInfoComponent;
    }());
    MdlListItemSecondaryInfoComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-list-item-secondary-info",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlListItemSecondaryInfoComponent.ctorParameters = function () { return [
        { type: MdlListItemSecondaryContentComponent, decorators: [{ type: i0.Optional }] }
    ]; };
    MdlListItemSecondaryInfoComponent.propDecorators = {
        isSecondaryInfo: [{ type: i0.HostBinding, args: ["class.mdl-list__item-secondary-info",] }]
    };
    var MdlListItemTextBodyComponent = /** @class */ (function () {
        function MdlListItemTextBodyComponent(mdlListItemComponent) {
            this.mdlListItemComponent = mdlListItemComponent;
            this.isTextBody = true;
        }
        MdlListItemTextBodyComponent.prototype.ngOnInit = function () {
            if (this.mdlListItemComponent === null) {
                throw new MdlStructureError("mdl-list-item-text-body", "mdl-list-item");
            }
        };
        return MdlListItemTextBodyComponent;
    }());
    MdlListItemTextBodyComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-list-item-text-body",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlListItemTextBodyComponent.ctorParameters = function () { return [
        { type: MdlListItemComponent, decorators: [{ type: i0.Optional }] }
    ]; };
    MdlListItemTextBodyComponent.propDecorators = {
        isTextBody: [{ type: i0.HostBinding, args: ["class.mdl-list__item-text-body",] }]
    };
    var MdlListItemIconDirective = /** @class */ (function () {
        function MdlListItemIconDirective() {
            this.isItemIcon = true;
        }
        return MdlListItemIconDirective;
    }());
    MdlListItemIconDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: 'mdl-icon[mdl-list-item-icon]'
                },] }
    ];
    MdlListItemIconDirective.propDecorators = {
        isItemIcon: [{ type: i0.HostBinding, args: ["class.mdl-list__item-icon",] }]
    };
    var MdlListItemAvatarDirective = /** @class */ (function () {
        function MdlListItemAvatarDirective() {
            this.isItemAvatar = true;
        }
        return MdlListItemAvatarDirective;
    }());
    MdlListItemAvatarDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: 'mdl-icon[mdl-list-item-avatar]'
                },] }
    ];
    MdlListItemAvatarDirective.propDecorators = {
        isItemAvatar: [{ type: i0.HostBinding, args: ["class.mdl-list__item-avatar",] }]
    };

    var MDL_LIST_DIRECTIVES = [
        MdlListComponent,
        MdlListItemComponent,
        MdlListItemPrimaryContentComponent,
        MdlListItemIconDirective,
        MdlListItemAvatarDirective,
        MdlListItemSecondaryContentComponent,
        MdlListItemSecondaryActionComponent,
        MdlListItemSubTitleComponent,
        MdlListItemSecondaryInfoComponent,
        MdlListItemTextBodyComponent,
    ];
    var MdlListModule = /** @class */ (function () {
        function MdlListModule() {
        }
        MdlListModule.forRoot = function () {
            return {
                ngModule: MdlListModule,
                providers: [],
            };
        };
        return MdlListModule;
    }());
    MdlListModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [],
                    exports: MDL_LIST_DIRECTIVES,
                    declarations: MDL_LIST_DIRECTIVES,
                },] }
    ];

    var BOTTOM_LEFT = "bottom-left";
    var BOTTOM_RIGHT = "bottom-right";
    var TOP_LEFT = "top-left";
    var TOP_RIGHT = "top-right";
    var UNALIGNED = "unaligned";
    // Total duration of the menu animation.
    var TRANSITION_DURATION_SECONDS = 0.3;
    // The fraction of the total duration we want to use for menu item animations.
    var TRANSITION_DURATION_FRACTION = 0.8;
    // How long the menu stays open after choosing an option (so the user can see
    // the ripple).
    var CLOSE_TIMEOUT = 175;
    var CSS_ALIGN_MAP = {};
    CSS_ALIGN_MAP[BOTTOM_LEFT] = "mdl-menu--bottom-left";
    CSS_ALIGN_MAP[BOTTOM_RIGHT] = "mdl-menu--bottom-right";
    CSS_ALIGN_MAP[TOP_LEFT] = "mdl-menu--top-left";
    CSS_ALIGN_MAP[TOP_RIGHT] = "mdl-menu--top-right";
    CSS_ALIGN_MAP[UNALIGNED] = "mdl-menu--unaligned";
    var MdlMenuError = /** @class */ (function (_super) {
        __extends(MdlMenuError, _super);
        function MdlMenuError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return MdlMenuError;
    }(MdlError));
    var MdlMenuRegisty = /** @class */ (function () {
        function MdlMenuRegisty() {
            this.menuComponents = [];
        }
        MdlMenuRegisty.prototype.add = function (menuComponent) {
            this.menuComponents.push(menuComponent);
        };
        MdlMenuRegisty.prototype.remove = function (menuComponent) {
            var fromIndex = this.menuComponents.indexOf(menuComponent);
            this.menuComponents.splice(fromIndex, 1);
        };
        MdlMenuRegisty.prototype.hideAllExcept = function (menuComponent) {
            this.menuComponents.forEach(function (component) {
                if (component !== menuComponent) {
                    component.hide();
                }
            });
        };
        return MdlMenuRegisty;
    }());
    MdlMenuRegisty.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function MdlMenuRegisty_Factory() { return new MdlMenuRegisty(); }, token: MdlMenuRegisty, providedIn: "root" });
    MdlMenuRegisty.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: "root",
                },] }
    ];
    var MdlMenuComponent = /** @class */ (function () {
        function MdlMenuComponent(renderer, menuRegistry) {
            this.renderer = renderer;
            this.menuRegistry = menuRegistry;
            this.cssPosition = "mdl-menu--bottom-left";
            this.isVisible = false;
            this.menuRegistry.add(this);
        }
        MdlMenuComponent.prototype.ngOnInit = function () {
            this.cssPosition = CSS_ALIGN_MAP[this.position] || BOTTOM_LEFT;
        };
        MdlMenuComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.container = this.containerChild.nativeElement;
            this.menuElement = this.menuElementChild.nativeElement;
            this.outline = this.outlineChild.nativeElement;
            // Add a click listener to the document, to close the menu.
            var callback = function () {
                if (_this.isVisible) {
                    _this.hide();
                }
                return true;
            };
            this.renderer.listen("window", "click", callback);
            this.renderer.listen("window", "touchstart", callback);
        };
        MdlMenuComponent.prototype.toggle = function (event, mdlButton) {
            if (!mdlButton) {
                throw new MdlMenuError("MdlButtonComponent is required");
            }
            if (this.isVisible) {
                this.hide();
            }
            else {
                this.show(event, mdlButton);
            }
        };
        MdlMenuComponent.prototype.hideOnItemClicked = function () {
            var _this = this;
            // Wait some time before closing menu, so the user can see the ripple.
            setTimeout(function () {
                _this.hide();
            }, CLOSE_TIMEOUT);
        };
        MdlMenuComponent.prototype.hide = function () {
            // Remove all transition delays; menu items fade out concurrently.
            document.querySelectorAll("mdl-menu-item").forEach(function (el) {
                el.style.removeProperty("transition-delay");
            });
            // this.menuItemComponents.toArray().forEach(mi => {
            //   mi.element.style.removeProperty('transition-delay');
            // });
            // Measure the inner element.
            var rect = this.menuElement.getBoundingClientRect();
            var height = rect.height;
            var width = rect.width;
            // Turn on animation, and apply the final clip. Also make invisible.
            // This triggers the transitions.
            this.renderer.addClass(this.menuElement, "is-animating");
            this.applyClip(height, width);
            this.renderer.removeClass(this.container, "is-visible");
            // Clean up after the animation is complete.
            this.addAnimationEndListener();
            this.isVisible = false;
        };
        MdlMenuComponent.prototype.show = function (event, mdlButton) {
            var _this = this;
            this.menuRegistry.hideAllExcept(this);
            event.stopPropagation();
            var forElement = mdlButton.element;
            var rect = forElement.getBoundingClientRect();
            var forRect = forElement.parentElement.getBoundingClientRect();
            if (this.position === UNALIGNED) {
                // Do not position the menu automatically. Requires the developer to
                // manually specify position.
            }
            else if (this.position === BOTTOM_RIGHT) {
                // Position below the "for" element, aligned to its right.
                this.container.style.right = forRect.right - rect.right + "px";
                this.container.style.top =
                    forElement.offsetTop + forElement.offsetHeight + "px";
            }
            else if (this.position === TOP_LEFT) {
                // Position above the "for" element, aligned to its left.
                this.container.style.left = forElement.offsetLeft + "px";
                this.container.style.bottom = forRect.bottom - rect.top + "px";
            }
            else if (this.position === TOP_RIGHT) {
                // Position above the "for" element, aligned to its right.
                this.container.style.right = forRect.right - rect.right + "px";
                this.container.style.bottom = forRect.bottom - rect.top + "px";
            }
            else {
                // Default: position below the "for" element, aligned to its left.
                this.container.style.left = forElement.offsetLeft + "px";
                this.container.style.top =
                    forElement.offsetTop + forElement.offsetHeight + "px";
            }
            // Measure the inner element.
            var height = this.menuElement.getBoundingClientRect().height;
            var width = this.menuElement.getBoundingClientRect().width;
            this.container.style.width = width + "px";
            this.container.style.height = height + "px";
            this.outline.style.width = width + "px";
            this.outline.style.height = height + "px";
            var transitionDuration = TRANSITION_DURATION_SECONDS * TRANSITION_DURATION_FRACTION;
            document.querySelectorAll("mdl-menu-item").forEach(function (el) {
                var mi = el;
                var itemDelay;
                if (_this.position === TOP_LEFT || _this.position === TOP_RIGHT) {
                    itemDelay =
                        ((height - mi.offsetTop - mi.offsetHeight) / height) *
                            transitionDuration +
                            "s";
                }
                else {
                    itemDelay = (mi.offsetTop / height) * transitionDuration + "s";
                }
                mi.style.transitionDelay = itemDelay;
            });
            // Apply the initial clip to the text before we start animating.
            this.applyClip(height, width);
            this.renderer.addClass(this.container, "is-visible");
            this.menuElement.style.clip = "rect(0 " + width + "px " + height + "px 0)";
            this.renderer.addClass(this.menuElement, "is-animating");
            this.addAnimationEndListener();
            this.isVisible = true;
        };
        MdlMenuComponent.prototype.ngOnDestroy = function () {
            this.menuRegistry.remove(this);
        };
        MdlMenuComponent.prototype.addAnimationEndListener = function () {
            var _this = this;
            this.renderer.listen(this.menuElement, "transitionend", function () {
                _this.renderer.removeClass(_this.menuElement, "is-animating");
                return true;
            });
        };
        MdlMenuComponent.prototype.applyClip = function (height, width) {
            if (this.position === UNALIGNED) {
                // Do not clip.
                this.menuElement.style.clip = "";
            }
            else if (this.position === BOTTOM_RIGHT) {
                // Clip to the top right corner of the menu.
                this.menuElement.style.clip =
                    "rect(0 " + width + "px " + "0 " + width + "px)";
            }
            else if (this.position === TOP_LEFT) {
                // Clip to the bottom left corner of the menu.
                this.menuElement.style.clip =
                    "rect(" + height + "px 0 " + height + "px 0)";
            }
            else if (this.position === TOP_RIGHT) {
                // Clip to the bottom right corner of the menu.
                this.menuElement.style.clip =
                    "rect(" +
                        height +
                        "px " +
                        width +
                        "px " +
                        height +
                        "px " +
                        width +
                        "px)";
            }
            else {
                // Default: do not clip (same as clipping to the top left corner).
                this.menuElement.style.clip = "";
            }
        };
        return MdlMenuComponent;
    }());
    MdlMenuComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-menu",
                    exportAs: "mdlMenu",
                    template: "\n    <div #container class=\"mdl-menu__container is-upgraded\">\n      <div #outline class=\"mdl-menu__outline\" [ngClass]=\"cssPosition\"></div>\n      <div class=\"mdl-menu\" #menuElement>\n        <ng-content></ng-content>\n      </div>\n    </div>\n  ",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlMenuComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 },
        { type: MdlMenuRegisty }
    ]; };
    MdlMenuComponent.propDecorators = {
        position: [{ type: i0.Input, args: ['mdl-menu-position',] }],
        containerChild: [{ type: i0.ViewChild, args: ["container", { static: true },] }],
        menuElementChild: [{ type: i0.ViewChild, args: ["menuElement", { static: true },] }],
        outlineChild: [{ type: i0.ViewChild, args: ["outline", { static: true },] }]
    };

    var MdlMenuItemComponent = /** @class */ (function () {
        // forwardRef is needed because of he circular dependency menu queries menuitems; menuitem needs the parent
        function MdlMenuItemComponent(elementRef, mdlMenu) {
            this.elementRef = elementRef;
            this.mdlMenu = mdlMenu;
            this.tabindex = -1;
            this.isMenuItem = true;
            this.disabledIntern = false;
            this.element = elementRef.nativeElement;
        }
        Object.defineProperty(MdlMenuItemComponent.prototype, "disabled", {
            get: function () {
                return this.disabledIntern;
            },
            set: function (value) {
                this.disabledIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        MdlMenuItemComponent.prototype.onClick = function ($event) {
            $event.stopPropagation();
            if (this.disabled) {
                this.mdlMenu.hide();
                return;
            }
            this.mdlMenu.hideOnItemClicked();
        };
        // we need to register a touchstart at the window to get informed if the user taps outside the menu.
        // But if we register a touchstart event - safari will no longer convert touch events to click events.
        // So we need to convert touch to click and the user still needs to register a (click) listener to be
        // informed if the menu item has clicked.
        MdlMenuItemComponent.prototype.onTouch = function ($event) {
            // ensure that this event is totally consumed
            $event.stopPropagation();
            $event.preventDefault();
            var event = new MouseEvent("click", { bubbles: true });
            callNative(this.element, "dispatchEvent", event);
        };
        return MdlMenuItemComponent;
    }());
    MdlMenuItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-menu-item",
                    template: "<ng-content></ng-content>",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlMenuItemComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: MdlMenuComponent, decorators: [{ type: i0.Inject, args: [i0.forwardRef(function () { return MdlMenuComponent; }),] }] }
    ]; };
    MdlMenuItemComponent.propDecorators = {
        tabindex: [{ type: i0.HostBinding, args: ["tabindex",] }],
        isMenuItem: [{ type: i0.HostBinding, args: ["class.mdl-menu__item",] }],
        disabled: [{ type: i0.Input }],
        onClick: [{ type: i0.HostListener, args: ["click", ["$event"],] }],
        onTouch: [{ type: i0.HostListener, args: ["touchstart", ["$event"],] }]
    };

    var MdlMenuItemFullBleedDeviderDirective = /** @class */ (function () {
        function MdlMenuItemFullBleedDeviderDirective() {
            this.isFullBleedDivider = true;
        }
        return MdlMenuItemFullBleedDeviderDirective;
    }());
    MdlMenuItemFullBleedDeviderDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: '[mdl-menu-item-full-bleed-divider]'
                },] }
    ];
    MdlMenuItemFullBleedDeviderDirective.propDecorators = {
        isFullBleedDivider: [{ type: i0.HostBinding, args: ["class.mdl-menu__item--full-bleed-divider",] }]
    };

    var MdlToggleMenuDirective = /** @class */ (function () {
        function MdlToggleMenuDirective(button) {
            this.button = button;
        }
        MdlToggleMenuDirective.prototype.onClick = function ($event) {
            this.menu.toggle($event, this.button);
        };
        return MdlToggleMenuDirective;
    }());
    MdlToggleMenuDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: '[mdl-button][mdl-toggle-menu]'
                },] }
    ];
    MdlToggleMenuDirective.ctorParameters = function () { return [
        { type: MdlButtonComponent }
    ]; };
    MdlToggleMenuDirective.propDecorators = {
        menu: [{ type: i0.Input, args: ['mdl-toggle-menu',] }],
        onClick: [{ type: i0.HostListener, args: ["click", ["$event"],] }]
    };

    var MDL_MENU_DIRECTIVES = [
        MdlMenuComponent,
        MdlMenuItemComponent,
        MdlMenuItemFullBleedDeviderDirective,
        MdlToggleMenuDirective,
    ];
    var MdlMenuModule = /** @class */ (function () {
        function MdlMenuModule() {
        }
        MdlMenuModule.forRoot = function () {
            return {
                ngModule: MdlMenuModule,
                providers: [MdlMenuRegisty],
            };
        };
        return MdlMenuModule;
    }());
    MdlMenuModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule],
                    exports: MDL_MENU_DIRECTIVES,
                    declarations: MDL_MENU_DIRECTIVES,
                },] }
    ];

    var MdlProgressComponent = /** @class */ (function () {
        function MdlProgressComponent() {
            this.progress = 0;
            this.buffer = 100;
            this.aux = 0;
            this.isProgess = true;
            this.indeterminateIntern = false;
        }
        Object.defineProperty(MdlProgressComponent.prototype, "indeterminate", {
            get: function () {
                return this.indeterminateIntern;
            },
            set: function (value) {
                this.indeterminateIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        MdlProgressComponent.prototype.ngOnChanges = function (changes) {
            if (changes.buffer) {
                this.setBuffer(changes.buffer.currentValue);
            }
        };
        MdlProgressComponent.prototype.setBuffer = function (b) {
            this.aux = 100 - b;
        };
        return MdlProgressComponent;
    }());
    MdlProgressComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-progress",
                    template: "\n    <div class=\"progressbar bar bar1\" [style.width]=\"progress + '%'\"></div>\n    <div class=\"bufferbar bar bar2\" [style.width]=\"buffer + '%'\"></div>\n    <div class=\"auxbar bar bar3\" [ngStyle]=\"{ width: aux + '%' }\"></div>\n  ",
                    encapsulation: i0.ViewEncapsulation.None,
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    MdlProgressComponent.propDecorators = {
        progress: [{ type: i0.Input }],
        buffer: [{ type: i0.Input }],
        aux: [{ type: i0.Input }],
        isProgess: [{ type: i0.HostBinding, args: ["class.mdl-progress",] }],
        indeterminate: [{ type: i0.HostBinding, args: ["class.mdl-progress__indeterminate",] }, { type: i0.Input }]
    };

    var MDL_PROGRESS_DIRECTIVES = [MdlProgressComponent];
    var MdlProgressModule = /** @class */ (function () {
        function MdlProgressModule() {
        }
        MdlProgressModule.forRoot = function () {
            return {
                ngModule: MdlProgressModule,
                providers: [],
            };
        };
        return MdlProgressModule;
    }());
    MdlProgressModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule],
                    exports: MDL_PROGRESS_DIRECTIVES,
                    declarations: MDL_PROGRESS_DIRECTIVES,
                },] }
    ];

    var throwNameError = function () {
        throw new Error("\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <mdl-radio formControlName=\"food\" name=\"food\"></mdl-radio>\n    ");
    };
    var ɵ0 = throwNameError;
    var IS_FOCUSED$1 = "is-focused";
    // Registry for mdl-readio compnents. Is responsible to keep the
    // right state of the radio buttons of a radio group. It would be
    // easier if i had a mdl-radio-group component. but this would be
    // a big braking change.
    var MdlRadioGroupRegisty = /** @class */ (function () {
        function MdlRadioGroupRegisty() {
            this.defaultFormGroup = "defaultFromGroup";
            this.radioComponents = [];
        }
        MdlRadioGroupRegisty.prototype.add = function (radioComponent, formGroupName) {
            this.radioComponents.push({
                radio: radioComponent,
                group: formGroupName || this.defaultFormGroup,
            });
        };
        MdlRadioGroupRegisty.prototype.remove = function (radioComponent) {
            this.radioComponents = this.radioComponents.filter(function (radioComponentInArray) { return radioComponentInArray.radio !== radioComponent; });
        };
        MdlRadioGroupRegisty.prototype.select = function (radioComponent, formGroupName) {
            // unselect every radioComponent that is not the provided radiocomponent
            // and has the same name and is in teh same group.
            var groupToTest = formGroupName || this.defaultFormGroup;
            this.radioComponents.forEach(function (component) {
                if (component.radio.name === radioComponent.name &&
                    component.group === groupToTest) {
                    if (component.radio !== radioComponent) {
                        component.radio.deselect(radioComponent.value);
                    }
                }
            });
        };
        return MdlRadioGroupRegisty;
    }());
    MdlRadioGroupRegisty.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function MdlRadioGroupRegisty_Factory() { return new MdlRadioGroupRegisty(); }, token: MdlRadioGroupRegisty, providedIn: "root" });
    MdlRadioGroupRegisty.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: "root",
                },] }
    ];
    /*
     <mdl-radio name="group1" value="1" [(ngModel)]="radioOption">Value 1</mdl-radio>
     */
    var MdlRadioComponent = /** @class */ (function () {
        function MdlRadioComponent(elementRef, renderer, radioGroupRegistry, formGroupName) {
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.radioGroupRegistry = radioGroupRegistry;
            this.formGroupName = formGroupName;
            this.tabindex = null;
            // eslint-disable-next-line
            this.change = new i0.EventEmitter();
            // the internal state - used to set the underlaying radio button state.
            this.checked = false;
            this.isUpgraded = true;
            this.isRadio = true;
            this.onTouchedCallback = noop;
            this.onChangeCallback = noop;
            this.disabledIntern = false;
            this.el = elementRef.nativeElement;
        }
        Object.defineProperty(MdlRadioComponent.prototype, "disabled", {
            get: function () {
                return this.disabledIntern;
            },
            set: function (value) {
                this.disabledIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        MdlRadioComponent.prototype.onClick = function () {
            if (this.disabled) {
                return;
            }
            this.optionValue = this.value;
            this.updateCheckState();
            this.onChangeCallback();
            this.change.emit(this.optionValue);
        };
        MdlRadioComponent.prototype.ngOnInit = function () {
            // we need a name and it must be the same as in the formcontrol.
            // a radio group without name is useless.
            this.checkName();
            // register the radio button - this is the only chance to unselect the
            // radio button that is no longer active - scope the radio button with it's group
            // if there is one.
            this.radioGroupRegistry.add(this, this.formGroupName);
        };
        MdlRadioComponent.prototype.ngOnDestroy = function () {
            this.radioGroupRegistry.remove(this);
        };
        MdlRadioComponent.prototype.writeValue = function (optionValue) {
            this.optionValue = optionValue;
            this.updateCheckState();
        };
        MdlRadioComponent.prototype.deselect = function (value) {
            // called from the registry. the value is the value of the selected radio button
            // e.g. the radio button get unselected if it isnÄt the selected one.
            this.writeValue(value);
        };
        MdlRadioComponent.prototype.registerOnChange = function (fn) {
            var _this = this;
            // wrap the callback, so that we can call select on the registry
            this.onChangeCallback = function () {
                fn(_this.value);
                _this.radioGroupRegistry.select(_this, _this.formGroupName);
            };
        };
        MdlRadioComponent.prototype.registerOnTouched = function (fn) {
            this.onTouchedCallback = fn;
        };
        MdlRadioComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        MdlRadioComponent.prototype.onFocus = function () {
            this.renderer.addClass(this.el, IS_FOCUSED$1);
        };
        MdlRadioComponent.prototype.onBlur = function () {
            this.renderer.removeClass(this.el, IS_FOCUSED$1);
        };
        MdlRadioComponent.prototype.spaceKeyPress = function () {
            this.checked = false; // in case of space key is pressed radio button value must remain same
        };
        MdlRadioComponent.prototype.updateCheckState = function () {
            this.checked = this.optionValue === this.value;
        };
        MdlRadioComponent.prototype.checkName = function () {
            if (this.name &&
                this.formControlName &&
                this.name !== this.formControlName) {
                throwNameError();
            }
            if (!this.name && this.formControlName) {
                this.name = this.formControlName;
            }
        };
        return MdlRadioComponent;
    }());
    MdlRadioComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-radio",
                    providers: [
                        {
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: i0.forwardRef(function () { return MdlRadioComponent; }),
                            multi: true,
                        },
                    ],
                    template: "\n    <input\n      type=\"checkbox\"\n      class=\"mdl-radio__button\"\n      [attr.name]=\"name\"\n      (focus)=\"onFocus()\"\n      (blur)=\"onBlur()\"\n      (keyup.space)=\"spaceKeyPress()\"\n      [disabled]=\"disabled\"\n      [attr.tabindex]=\"tabindex\"\n      [(ngModel)]=\"checked\"\n    />\n    <span class=\"mdl-radio__label\"><ng-content></ng-content></span>\n    <span class=\"mdl-radio__outer-circle\"></span>\n    <span class=\"mdl-radio__inner-circle\"></span>\n  ",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlRadioComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: MdlRadioGroupRegisty },
        { type: forms.FormGroupName, decorators: [{ type: i0.Optional }] }
    ]; };
    MdlRadioComponent.propDecorators = {
        name: [{ type: i0.Input }],
        formControlName: [{ type: i0.Input }],
        value: [{ type: i0.Input }],
        tabindex: [{ type: i0.Input }],
        change: [{ type: i0.Output }],
        checked: [{ type: i0.HostBinding, args: ["class.is-checked",] }],
        isUpgraded: [{ type: i0.HostBinding, args: ["class.is-upgraded",] }],
        isRadio: [{ type: i0.HostBinding, args: ["class.mdl-radio",] }],
        disabled: [{ type: i0.HostBinding, args: ["class.is-disabled",] }, { type: i0.Input }],
        onClick: [{ type: i0.HostListener, args: ["click",] }]
    };

    var MdlRadioModule = /** @class */ (function () {
        function MdlRadioModule() {
        }
        MdlRadioModule.forRoot = function () {
            return {
                ngModule: MdlRadioModule,
                providers: [MdlRadioGroupRegisty],
            };
        };
        return MdlRadioModule;
    }());
    MdlRadioModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule, forms.FormsModule],
                    exports: [MdlRadioComponent],
                    declarations: [MdlRadioComponent],
                },] }
    ];

    var MdlUnsupportedShadowValueError = /** @class */ (function (_super) {
        __extends(MdlUnsupportedShadowValueError, _super);
        function MdlUnsupportedShadowValueError(value) {
            /* istanbul ignore next */
            return _super.call(this, "Shadow value \"" + value + "\" isn't supported (allowed: 2,3,4,6,8,16,24).") || this;
        }
        return MdlUnsupportedShadowValueError;
    }(MdlError));
    var MDL_SHADOW_VALUES = [0, 2, 3, 4, 6, 8, 16, 24];
    var MdlShadowDirective = /** @class */ (function () {
        function MdlShadowDirective(elementRef, renderer) {
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.mdlShadowIntern = 2;
            this.el = elementRef.nativeElement;
        }
        Object.defineProperty(MdlShadowDirective.prototype, "mdlShadow", {
            get: function () {
                return this.mdlShadowIntern;
            },
            set: function (value) {
                this.mdlShadowIntern = toNumber(value);
            },
            enumerable: false,
            configurable: true
        });
        MdlShadowDirective.prototype.ngOnChanges = function (changes) {
            if (MDL_SHADOW_VALUES.indexOf(Number(this.mdlShadow)) === -1) {
                throw new MdlUnsupportedShadowValueError(this.mdlShadow);
            }
            var change = changes.mdlShadow;
            if (!change.isFirstChange()) {
                this.renderer.removeClass(this.el, "mdl-shadow--" + change.previousValue + "dp");
            }
            this.renderer.addClass(this.el, "mdl-shadow--" + change.currentValue + "dp");
        };
        return MdlShadowDirective;
    }());
    MdlShadowDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: '[mdl-shadow]'
                },] }
    ];
    MdlShadowDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    MdlShadowDirective.propDecorators = {
        mdlShadow: [{ type: i0.Input, args: ["mdl-shadow",] }]
    };

    var MDL_SHADOW_DIRECTIVES = [MdlShadowDirective];
    var MdlShadowModule = /** @class */ (function () {
        function MdlShadowModule() {
        }
        MdlShadowModule.forRoot = function () {
            return {
                ngModule: MdlShadowModule,
                providers: [],
            };
        };
        return MdlShadowModule;
    }());
    MdlShadowModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [],
                    exports: MDL_SHADOW_DIRECTIVES,
                    declarations: MDL_SHADOW_DIRECTIVES,
                },] }
    ];

    var MdlSliderComponent = /** @class */ (function () {
        function MdlSliderComponent(renderer, elRef) {
            this.renderer = renderer;
            this.elRef = elRef;
            this.isSliderContainer = true;
            this.onTouchedCallback = noop;
            this.onChangeCallback = noop;
            this.disabledIntern = false;
        }
        Object.defineProperty(MdlSliderComponent.prototype, "disabled", {
            get: function () {
                return this.disabledIntern;
            },
            set: function (value) {
                this.disabledIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlSliderComponent.prototype, "value", {
            get: function () {
                return this.valueIntern;
            },
            set: function (v) {
                this.valueIntern = v;
                this.updateSliderUI();
                this.onChangeCallback(v);
            },
            enumerable: false,
            configurable: true
        });
        MdlSliderComponent.prototype.onMouseUp = function (event) {
            event.target.blur();
        };
        MdlSliderComponent.prototype.onMouseDown = function (event) {
            if (event.target !== this.elRef.nativeElement) {
                return;
            }
            // Discard the original event and create a new event that
            // is on the slider element.
            event.preventDefault();
            var newEvent = new MouseEvent("mousedown", {
                relatedTarget: event.relatedTarget,
                button: event.button,
                buttons: event.buttons,
                clientX: event.clientX,
                clientY: this.inputEl.nativeElement.getBoundingClientRect().y,
                screenX: event.screenX,
                screenY: event.screenY,
            });
            callNative(this.inputEl.nativeElement, "dispatchEvent", newEvent);
        };
        MdlSliderComponent.prototype.ngAfterViewInit = function () {
            this.updateSliderUI();
        };
        MdlSliderComponent.prototype.writeValue = function (value) {
            this.valueIntern = value;
            this.updateSliderUI();
        };
        MdlSliderComponent.prototype.registerOnChange = function (fn) {
            this.onChangeCallback = fn;
        };
        MdlSliderComponent.prototype.registerOnTouched = function (fn) {
            this.onTouchedCallback = fn;
        };
        MdlSliderComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        MdlSliderComponent.prototype.updateSliderUI = function () {
            // if the input hat a static value (for example value="30"
            // the setvalue method is called before the ViewChilds are initialized
            // this has changed in Angular 9! :(
            if (!this.inputEl) {
                return;
            }
            var fraction = (this.valueIntern - this.min) / (this.max - this.min);
            if (fraction === 0) {
                this.renderer.addClass(this.inputEl.nativeElement, "is-lowest-value");
            }
            else {
                this.renderer.removeClass(this.inputEl.nativeElement, "is-lowest-value");
            }
            this.renderer.setStyle(this.lowerEl.nativeElement, "flex", "" + fraction);
            this.renderer.setStyle(this.upperEl.nativeElement, "flex", "" + (1 - fraction));
        };
        return MdlSliderComponent;
    }());
    MdlSliderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-slider",
                    providers: [
                        {
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: i0.forwardRef(function () { return MdlSliderComponent; }),
                            multi: true,
                        },
                    ],
                    template: "\n    <input\n      class=\"mdl-slider is-upgraded\"\n      type=\"range\"\n      [min]=\"min\"\n      [max]=\"max\"\n      [step]=\"step\"\n      [(ngModel)]=\"value\"\n      [disabled]=\"disabled\"\n      tabindex=\"0\"\n      #input\n    />\n    <div class=\"mdl-slider__background-flex\">\n      <div class=\"mdl-slider__background-lower\" #lower></div>\n      <div class=\"mdl-slider__background-upper\" #uppper></div>\n    </div>\n  ",
                    encapsulation: i0.ViewEncapsulation.None,
                    styles: ["\n      :host {\n        height: 22px;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n      }\n    "]
                },] }
    ];
    MdlSliderComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 },
        { type: i0.ElementRef }
    ]; };
    MdlSliderComponent.propDecorators = {
        min: [{ type: i0.Input }],
        max: [{ type: i0.Input }],
        step: [{ type: i0.Input }],
        lowerEl: [{ type: i0.ViewChild, args: ["lower", { static: true },] }],
        upperEl: [{ type: i0.ViewChild, args: ["uppper", { static: true },] }],
        inputEl: [{ type: i0.ViewChild, args: ["input", { static: true },] }],
        isSliderContainer: [{ type: i0.HostBinding, args: ["class.mdl-slider__container",] }],
        disabled: [{ type: i0.Input }],
        value: [{ type: i0.Input }],
        onMouseUp: [{ type: i0.HostListener, args: ["mouseup", ["$event"],] }],
        onMouseDown: [{ type: i0.HostListener, args: ["mousedown", ["$event"],] }]
    };

    var MDL_SLIDER_DIRECTIVES = [MdlSliderComponent];
    var MdlSliderModule = /** @class */ (function () {
        function MdlSliderModule() {
        }
        MdlSliderModule.forRoot = function () {
            return {
                ngModule: MdlSliderModule,
                providers: [],
            };
        };
        return MdlSliderModule;
    }());
    MdlSliderModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [forms.FormsModule, common.CommonModule],
                    exports: MDL_SLIDER_DIRECTIVES,
                    declarations: MDL_SLIDER_DIRECTIVES,
                },] }
    ];

    var ANIMATION_TIME = 250;
    var MdlSnackbarComponent = /** @class */ (function () {
        function MdlSnackbarComponent() {
            this.showIt = false;
        }
        MdlSnackbarComponent.prototype.onClick = function () {
            this.onAction();
        };
        MdlSnackbarComponent.prototype.isActive = function () {
            return this.showIt;
        };
        MdlSnackbarComponent.prototype.show = function () {
            var _this = this;
            var result = new rxjs.Subject();
            // wait unit the dom is in place - then showIt will change the css class
            setTimeout(function () {
                _this.showIt = true;
                // fire after the view animation is done
                setTimeout(function () {
                    result.next();
                    result.complete();
                }, ANIMATION_TIME);
            }, ANIMATION_TIME);
            return result.asObservable();
        };
        MdlSnackbarComponent.prototype.hide = function () {
            this.showIt = false;
            var result = new rxjs.Subject();
            // fire after the view animation is done
            setTimeout(function () {
                result.next(null);
                result.complete();
            }, ANIMATION_TIME);
            return result.asObservable();
        };
        return MdlSnackbarComponent;
    }());
    MdlSnackbarComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-snackbar-component",
                    template: "\n    <div\n      id=\"demo-toast-example\"\n      class=\" mdl-snackbar\"\n      [ngClass]=\"{ 'mdl-snackbar--active': showIt }\"\n    >\n      <div class=\"mdl-snackbar__text\">{{ message }}</div>\n      <button\n        *ngIf=\"onAction\"\n        class=\"mdl-snackbar__action\"\n        type=\"button\"\n        (click)=\"onClick()\"\n      >\n        {{ actionText }}\n      </button>\n    </div>\n  ",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    var MdlSnackbarService = /** @class */ (function () {
        function MdlSnackbarService(componentFactoryResolver, dialogOutletService) {
            this.componentFactoryResolver = componentFactoryResolver;
            this.dialogOutletService = dialogOutletService;
            this.cFactory = this.componentFactoryResolver.resolveComponentFactory(MdlSnackbarComponent);
        }
        MdlSnackbarService.prototype.showToast = function (message, timeout) {
            return this.showSnackbar({
                message: message,
                timeout: timeout,
            });
        };
        MdlSnackbarService.prototype.showSnackbar = function (snackbarMessage) {
            var optTimeout = snackbarMessage.timeout || 2750;
            var closeAfterTimeout = !!snackbarMessage.closeAfterTimeout;
            var viewContainerRef = this.dialogOutletService.viewContainerRef;
            if (!viewContainerRef) {
                throw new Error("You did not provide a ViewContainerRef. " +
                    "Please see https://github.com/mseemann/angular2-mdl/wiki/How-to-use-the-MdlDialogService");
            }
            var cRef = viewContainerRef.createComponent(this.cFactory, viewContainerRef.length);
            var mdlSnackbarComponent = cRef.instance;
            mdlSnackbarComponent.message = snackbarMessage.message;
            if (this.previousSnack) {
                var previousSnack_1 = this.previousSnack;
                var subscription_1 = previousSnack_1.component.hide().subscribe(function () {
                    previousSnack_1.cRef.destroy();
                    subscription_1.unsubscribe();
                });
            }
            this.previousSnack = {
                component: mdlSnackbarComponent,
                cRef: cRef,
            };
            if (snackbarMessage.action) {
                if (closeAfterTimeout) {
                    this.hideAndDestroySnack(mdlSnackbarComponent, cRef, optTimeout);
                }
                mdlSnackbarComponent.actionText = snackbarMessage.action.text;
                mdlSnackbarComponent.onAction = function () {
                    mdlSnackbarComponent.hide().subscribe(function () {
                        cRef.destroy();
                        snackbarMessage.action.handler();
                    });
                };
            }
            else {
                this.hideAndDestroySnack(mdlSnackbarComponent, cRef, optTimeout);
            }
            var result = new rxjs.Subject();
            mdlSnackbarComponent.show().subscribe(function () {
                result.next(mdlSnackbarComponent);
                result.complete();
            });
            return result.asObservable();
        };
        MdlSnackbarService.prototype.hideAndDestroySnack = function (component, componentRef, timeOut) {
            setTimeout(function () {
                component.hide().subscribe(function () {
                    componentRef.destroy();
                });
            }, timeOut);
        };
        return MdlSnackbarService;
    }());
    MdlSnackbarService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function MdlSnackbarService_Factory() { return new MdlSnackbarService(i0__namespace.ɵɵinject(i0__namespace.ComponentFactoryResolver), i0__namespace.ɵɵinject(MdlDialogOutletService)); }, token: MdlSnackbarService, providedIn: "root" });
    MdlSnackbarService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: "root",
                },] }
    ];
    MdlSnackbarService.ctorParameters = function () { return [
        { type: i0.ComponentFactoryResolver },
        { type: MdlDialogOutletService }
    ]; };

    var MdlSnackbarModule = /** @class */ (function () {
        function MdlSnackbarModule() {
        }
        MdlSnackbarModule.forRoot = function () {
            return {
                ngModule: MdlSnackbarModule,
                providers: [MdlSnackbarService],
            };
        };
        return MdlSnackbarModule;
    }());
    MdlSnackbarModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule, MdlDialogOutletModule.forRoot()],
                    exports: [MdlSnackbarComponent],
                    declarations: [MdlSnackbarComponent],
                    entryComponents: [MdlSnackbarComponent],
                },] }
    ];

    var MdlSpinnerComponent = /** @class */ (function () {
        function MdlSpinnerComponent() {
            this.isSpinner = true;
            this.isUpgraded = true;
            this.layers = [1, 2, 3, 4];
            this.activeIntern = false;
            this.singleColorIntern = false;
        }
        Object.defineProperty(MdlSpinnerComponent.prototype, "active", {
            get: function () {
                return this.activeIntern;
            },
            set: function (value) {
                this.activeIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlSpinnerComponent.prototype, "singleColor", {
            get: function () {
                return this.singleColorIntern;
            },
            set: function (value) {
                this.singleColorIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        return MdlSpinnerComponent;
    }());
    MdlSpinnerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-spinner",
                    template: "\n    <div\n      *ngFor=\"let layer of layers\"\n      class=\"mdl-spinner__layer mdl-spinner__layer-{{ layer }}\"\n    >\n      <div class=\"mdl-spinner__circle-clipper mdl-spinner__left\">\n        <div class=\"mdl-spinner__circle\"></div>\n      </div>\n      <div class=\"mdl-spinner__gap-patch\">\n        <div class=\"mdl-spinner__circle\"></div>\n      </div>\n      <div class=\"mdl-spinner__circle-clipper mdl-spinner__right\">\n        <div class=\"mdl-spinner__circle\"></div>\n      </div>\n    </div>\n  ",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlSpinnerComponent.propDecorators = {
        isSpinner: [{ type: i0.HostBinding, args: ["class.mdl-spinner",] }],
        isUpgraded: [{ type: i0.HostBinding, args: ["class.is-upgraded",] }],
        active: [{ type: i0.HostBinding, args: ["class.is-active",] }, { type: i0.Input }],
        singleColor: [{ type: i0.HostBinding, args: ["class.mdl-spinner--single-color",] }, { type: i0.Input, args: ["single-color",] }]
    };

    var MDL_SPINNER_DIRECTIVES = [MdlSpinnerComponent];
    var MdlSpinnerModule = /** @class */ (function () {
        function MdlSpinnerModule() {
        }
        MdlSpinnerModule.forRoot = function () {
            return {
                ngModule: MdlSpinnerModule,
                providers: [],
            };
        };
        return MdlSpinnerModule;
    }());
    MdlSpinnerModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule],
                    exports: MDL_SPINNER_DIRECTIVES,
                    declarations: MDL_SPINNER_DIRECTIVES,
                },] }
    ];

    var MdlSwitchComponent = /** @class */ (function (_super) {
        __extends(MdlSwitchComponent, _super);
        function MdlSwitchComponent(elementRef, renderer) {
            var _this = _super.call(this, elementRef, renderer) || this;
            _this.isSwitch = true;
            _this.isCheckbox = false;
            return _this;
        }
        return MdlSwitchComponent;
    }(MdlCheckboxComponent));
    MdlSwitchComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-switch",
                    providers: [
                        {
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: i0.forwardRef(function () { return MdlSwitchComponent; }),
                            multi: true,
                        },
                    ],
                    template: "\n    <input\n      type=\"checkbox\"\n      class=\"mdl-switch__input\"\n      (focus)=\"onFocus()\"\n      (blur)=\"onBlur()\"\n      [disabled]=\"disabled\"\n      [(ngModel)]=\"value\"\n    />\n    <span class=\"mdl-switch__label\"><ng-content></ng-content></span>\n    <div class=\"mdl-switch__track\"></div>\n    <div class=\"mdl-switch__thumb\">\n      <span class=\"mdl-switch__focus-helper\"></span>\n    </div>\n  ",
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlSwitchComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    MdlSwitchComponent.propDecorators = {
        isSwitch: [{ type: i0.HostBinding, args: ["class.mdl-switch",] }]
    };

    var MDL_SWITCH_DIRECTIVES = [MdlSwitchComponent];
    var MdlSwitchModule = /** @class */ (function () {
        function MdlSwitchModule() {
        }
        MdlSwitchModule.forRoot = function () {
            return {
                ngModule: MdlSwitchModule,
                providers: [],
            };
        };
        return MdlSwitchModule;
    }());
    MdlSwitchModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule, forms.FormsModule],
                    exports: MDL_SWITCH_DIRECTIVES,
                    declarations: MDL_SWITCH_DIRECTIVES,
                },] }
    ];

    var MdlDefaultTableModel = /** @class */ (function () {
        function MdlDefaultTableModel(columns) {
            this.data = [];
            this.columns = columns;
        }
        MdlDefaultTableModel.prototype.addAll = function (data) {
            var _a;
            (_a = this.data).push.apply(_a, __spreadArray([], __read(data)));
        };
        return MdlDefaultTableModel;
    }());
    var template = "\n        <table class=\"mdl-data-table\">\n           <thead>\n           <tr>\n              <th *ngIf=\"selectable\">\n                 <mdl-checkbox mdl-ripple [ngModel]=\"isAllSelected()\" (ngModelChange)=\"toogleAll()\"></mdl-checkbox>\n              </th>\n              <th *ngFor=\"let column of model.columns\"\n                  [ngClass]=\"{'mdl-data-table__cell--non-numeric': !column.numeric}\">\n                 {{column.name}}\n              </th>\n           </tr>\n           </thead>\n           <tbody>\n           <tr *ngFor=\"let data of model.data; let i = index\" [ngClass]=\"{'is-selected': selectable && data.selected}\">\n              <td *ngIf=\"selectable\">\n                 <mdl-checkbox mdl-ripple\n                      [(ngModel)]=\"data.selected\"\n                      (ngModelChange)=\"selectionChanged()\"></mdl-checkbox>\n              </td>\n              <td *ngFor=\"let column of model.columns\"\n                  [ngClass]=\"{'mdl-data-table__cell--non-numeric': !column.numeric}\"\n                  [innerHTML]=\"data[column.key]\">\n              </td>\n           </tr>\n           </tbody>\n        </table>\n    ";
    var styles = "\n    :host{\n      display:inline-block;\n    }\n    ";
    var MdlTableComponent = /** @class */ (function () {
        function MdlTableComponent() {
            this.selectable = false;
        }
        MdlTableComponent.prototype.isAllSelected = function () {
            return false;
        };
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        MdlTableComponent.prototype.toogleAll = function () { };
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        MdlTableComponent.prototype.selectionChanged = function () { };
        return MdlTableComponent;
    }());
    MdlTableComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-table",
                    template: template,
                    encapsulation: i0.ViewEncapsulation.None,
                    styles: [styles]
                },] }
    ];
    MdlTableComponent.propDecorators = {
        model: [{ type: i0.Input, args: ['table-model',] }]
    };
    var MdlSelectableTableComponent = /** @class */ (function (_super) {
        __extends(MdlSelectableTableComponent, _super);
        function MdlSelectableTableComponent() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            // eslint-disable-next-line
            _this.selectionChange = new i0.EventEmitter();
            _this.selectable = true;
            _this.allSelected = false;
            return _this;
        }
        MdlSelectableTableComponent.prototype.isAllSelected = function () {
            return this.model.data.every(function (data) { return data.selected; });
        };
        MdlSelectableTableComponent.prototype.toogleAll = function () {
            var selected = !this.isAllSelected();
            this.model.data.forEach(function (data) { return (data.selected = selected); });
            this.updateSelected();
        };
        MdlSelectableTableComponent.prototype.selectionChanged = function () {
            this.updateSelected();
        };
        MdlSelectableTableComponent.prototype.updateSelected = function () {
            this.selected = this.model.data.filter(function (data) { return data.selected; });
            this.selectionChange.emit({ value: this.selected });
        };
        return MdlSelectableTableComponent;
    }(MdlTableComponent));
    MdlSelectableTableComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-table-selectable",
                    template: template,
                    encapsulation: i0.ViewEncapsulation.None,
                    styles: [styles]
                },] }
    ];
    MdlSelectableTableComponent.propDecorators = {
        model: [{ type: i0.Input, args: ['table-model',] }],
        selected: [{ type: i0.Input, args: ['table-model-selected',] }],
        selectionChange: [{ type: i0.Output, args: ['table-model-selectionChanged',] }]
    };

    var MDL_TABLE_DIRECTIVES = [MdlTableComponent, MdlSelectableTableComponent];
    var MdlTableModule = /** @class */ (function () {
        function MdlTableModule() {
        }
        MdlTableModule.forRoot = function () {
            return {
                ngModule: MdlTableModule,
                providers: [],
            };
        };
        return MdlTableModule;
    }());
    MdlTableModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [MdlCheckboxModule, MdlCommonsModule, common.CommonModule, forms.FormsModule],
                    exports: MDL_TABLE_DIRECTIVES,
                    declarations: MDL_TABLE_DIRECTIVES,
                },] }
    ];

    var DISABLE_NATIVE_VALIDITY_CHECKING = new i0.InjectionToken("disableNativeValidityChecking");
    var nextId = 0;
    var IS_FOCUSED = "is-focused";
    var IS_DISABLED = "is-disabled";
    var IS_INVALID = "is-invalid";
    var IS_DIRTY = "is-dirty";
    /* eslint-disable  @angular-eslint/no-conflicting-lifecycle */
    var MdlTextFieldComponent = /** @class */ (function () {
        function MdlTextFieldComponent(renderer, elmRef, nativeCheckGlobalDisabled) {
            this.renderer = renderer;
            this.elmRef = elmRef;
            this.nativeCheckGlobalDisabled = nativeCheckGlobalDisabled;
            // eslint-disable-next-line
            this.blurEmitter = new i0.EventEmitter();
            // eslint-disable-next-line
            this.focusEmitter = new i0.EventEmitter();
            // eslint-disable-next-line
            this.keyupEmitter = new i0.EventEmitter();
            this.type = "text";
            this.id = "mdl-textfield-" + nextId++;
            this.tabindex = null;
            this.maxlength = null;
            this.isTextfield = true;
            this.isUpgraded = true;
            this.onTouchedCallback = noop;
            this.onChangeCallback = noop;
            this.disabledIntern = false;
            this.readonlyIntern = false;
            this.requiredIntern = false;
            this.autofocusIntern = false;
            this.isFloatingLabelIntern = false;
            this.rowsIntern = null;
            this.maxrowsIntern = -1;
            // @experimental
            this.disableNativeValidityCheckingIntern = false;
            this.el = elmRef.nativeElement;
        }
        Object.defineProperty(MdlTextFieldComponent.prototype, "value", {
            get: function () {
                return this.valueIntern;
            },
            set: function (v) {
                this.valueIntern =
                    this.type === "number" ? (v === "" ? null : parseFloat(v)) : v;
                this.onChangeCallback(this.value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlTextFieldComponent.prototype, "disabled", {
            get: function () {
                return this.disabledIntern;
            },
            set: function (value) {
                this.disabledIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlTextFieldComponent.prototype, "readonly", {
            get: function () {
                return this.readonlyIntern;
            },
            set: function (value) {
                this.readonlyIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlTextFieldComponent.prototype, "required", {
            get: function () {
                return this.requiredIntern;
            },
            set: function (value) {
                this.requiredIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlTextFieldComponent.prototype, "autofocus", {
            get: function () {
                return this.autofocusIntern;
            },
            set: function (value) {
                this.autofocusIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlTextFieldComponent.prototype, "isFloatingLabel", {
            get: function () {
                return this.isFloatingLabelIntern;
            },
            set: function (value) {
                this.isFloatingLabelIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlTextFieldComponent.prototype, "rows", {
            get: function () {
                return this.rowsIntern;
            },
            set: function (value) {
                this.rowsIntern = toNumber(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlTextFieldComponent.prototype, "maxrows", {
            get: function () {
                return this.maxrowsIntern;
            },
            set: function (value) {
                this.maxrowsIntern = toNumber(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlTextFieldComponent.prototype, "disableNativeValidityChecking", {
            get: function () {
                return this.disableNativeValidityCheckingIntern;
            },
            set: function (value) {
                this.disableNativeValidityCheckingIntern = toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        MdlTextFieldComponent.prototype.writeValue = function (value) {
            this.valueIntern = value;
            this.checkDirty();
        };
        MdlTextFieldComponent.prototype.registerOnChange = function (fn) {
            this.onChangeCallback = fn;
        };
        MdlTextFieldComponent.prototype.registerOnTouched = function (fn) {
            this.onTouchedCallback = fn;
        };
        MdlTextFieldComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        // eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
        MdlTextFieldComponent.prototype.ngOnChanges = function () {
            this.checkDisabled();
        };
        // eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
        MdlTextFieldComponent.prototype.ngDoCheck = function () {
            this.checkValidity();
            this.checkDirty();
        };
        MdlTextFieldComponent.prototype.setFocus = function () {
            if (!this.inputEl) {
                return;
            }
            this.inputEl.nativeElement.dispatchEvent(new Event("focus"));
        };
        MdlTextFieldComponent.prototype.keydownTextarea = function ($event) {
            var currentRowCount = this.inputEl.nativeElement.value.split("\n").length;
            // eslint-disable-next-line
            if ($event.keyCode === 13) {
                if (currentRowCount >= this.maxrows && this.maxrows !== -1) {
                    $event.preventDefault();
                }
            }
        };
        // model value.
        MdlTextFieldComponent.prototype.triggerChange = function (event) {
            this.value = event.target.value;
            this.onTouchedCallback();
        };
        MdlTextFieldComponent.prototype.onFocus = function (event) {
            this.renderer.addClass(this.el, IS_FOCUSED);
            this.focusEmitter.emit(event);
        };
        MdlTextFieldComponent.prototype.onBlur = function (event) {
            this.renderer.removeClass(this.el, IS_FOCUSED);
            this.onTouchedCallback();
            this.blurEmitter.emit(event);
        };
        MdlTextFieldComponent.prototype.onKeyup = function (event) {
            this.keyupEmitter.emit(event);
        };
        MdlTextFieldComponent.prototype.checkDisabled = function () {
            if (this.disabled) {
                this.renderer.addClass(this.el, IS_DISABLED);
            }
            else {
                this.renderer.removeClass(this.el, IS_DISABLED);
            }
        };
        MdlTextFieldComponent.prototype.checkValidity = function () {
            // check the global setting - if globally disabled do no check
            if (this.nativeCheckGlobalDisabled === true) {
                return;
            }
            // check local setting - if locally disabled do no check
            if (this.disableNativeValidityChecking) {
                return;
            }
            if (this.inputEl && this.inputEl.nativeElement.validity) {
                if (!this.inputEl.nativeElement.validity.valid) {
                    this.renderer.addClass(this.el, IS_INVALID);
                }
                else {
                    this.renderer.removeClass(this.el, IS_INVALID);
                }
            }
        };
        MdlTextFieldComponent.prototype.checkDirty = function () {
            var dirty = this.inputEl &&
                this.inputEl.nativeElement.value &&
                this.inputEl.nativeElement.value.length > 0;
            if (dirty) {
                this.renderer.addClass(this.el, IS_DIRTY);
            }
            else {
                this.renderer.removeClass(this.el, IS_DIRTY);
            }
        };
        return MdlTextFieldComponent;
    }());
    MdlTextFieldComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-textfield",
                    template: "\n    <div *ngIf=\"!icon\">\n      <textarea\n        *ngIf=\"rows\"\n        #input\n        [rows]=\"rows\"\n        class=\"mdl-textfield__input\"\n        type=\"text\"\n        [attr.name]=\"name\"\n        [id]=\"id\"\n        [placeholder]=\"placeholder ? placeholder : ''\"\n        (focus)=\"onFocus($event)\"\n        (blur)=\"onBlur($event)\"\n        (keydown)=\"keydownTextarea($event)\"\n        (keyup)=\"onKeyup($event)\"\n        [(ngModel)]=\"value\"\n        [disabled]=\"disabled\"\n        [required]=\"required\"\n        [autofocus]=\"autofocus\"\n        [readonly]=\"readonly\"\n        [maxlength]=\"maxlength\"\n      ></textarea>\n      <input\n        *ngIf=\"!rows\"\n        #input\n        class=\"mdl-textfield__input\"\n        [type]=\"type\"\n        [attr.name]=\"name\"\n        [id]=\"id\"\n        [pattern]=\"pattern ? pattern : '.*'\"\n        [attr.min]=\"min\"\n        [attr.max]=\"max\"\n        [attr.step]=\"step\"\n        [placeholder]=\"placeholder ? placeholder : ''\"\n        [autocomplete]=\"autocomplete ? autocomplete : ''\"\n        (focus)=\"onFocus($event)\"\n        (blur)=\"onBlur($event)\"\n        (keyup)=\"onKeyup($event)\"\n        [(ngModel)]=\"value\"\n        [disabled]=\"disabled\"\n        [required]=\"required\"\n        [autofocus]=\"autofocus\"\n        [readonly]=\"readonly\"\n        [attr.tabindex]=\"tabindex\"\n        [maxlength]=\"maxlength\"\n      />\n      <label class=\"mdl-textfield__label\" [attr.for]=\"id\">{{ label }}</label>\n      <span class=\"mdl-textfield__error\">{{ errorMessage }}</span>\n    </div>\n    <div *ngIf=\"icon\">\n      <button mdl-button mdl-button-type=\"icon\" (click)=\"setFocus()\">\n        <mdl-icon>{{ icon }}</mdl-icon>\n      </button>\n      <div class=\"mdl-textfield__expandable-holder\">\n        <input\n          #input\n          class=\"mdl-textfield__input\"\n          [type]=\"type\"\n          [attr.name]=\"name\"\n          [id]=\"id\"\n          [pattern]=\"pattern ? pattern : '.*'\"\n          [attr.min]=\"min\"\n          [attr.max]=\"max\"\n          [attr.step]=\"step\"\n          [placeholder]=\"placeholder ? placeholder : ''\"\n          [autocomplete]=\"autocomplete ? autocomplete : ''\"\n          (focus)=\"onFocus($event)\"\n          (blur)=\"onBlur($event)\"\n          (keyup)=\"onKeyup($event)\"\n          [(ngModel)]=\"value\"\n          [disabled]=\"disabled\"\n          [required]=\"required\"\n          [autofocus]=\"autofocus\"\n          [readonly]=\"readonly\"\n          [attr.tabindex]=\"tabindex\"\n          [maxlength]=\"maxlength\"\n        />\n        <label class=\"mdl-textfield__label\" [attr.for]=\"id\">{{ label }}</label>\n        <span class=\"mdl-textfield__error\">{{ errorMessage }}</span>\n      </div>\n    </div>\n  ",
                    providers: [
                        {
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: i0.forwardRef(function () { return MdlTextFieldComponent; }),
                            multi: true,
                        },
                    ],
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlTextFieldComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 },
        { type: i0.ElementRef },
        { type: Boolean, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [DISABLE_NATIVE_VALIDITY_CHECKING,] }] }
    ]; };
    MdlTextFieldComponent.propDecorators = {
        blurEmitter: [{ type: i0.Output, args: ["blur",] }],
        focusEmitter: [{ type: i0.Output, args: ["focus",] }],
        keyupEmitter: [{ type: i0.Output, args: ["keyup",] }],
        inputEl: [{ type: i0.ViewChild, args: ["input",] }],
        type: [{ type: i0.Input }],
        label: [{ type: i0.Input }],
        pattern: [{ type: i0.Input }],
        min: [{ type: i0.Input }],
        max: [{ type: i0.Input }],
        step: [{ type: i0.Input }],
        name: [{ type: i0.Input }],
        id: [{ type: i0.Input }],
        errorMessage: [{ type: i0.Input, args: ["error-msg",] }],
        placeholder: [{ type: i0.HostBinding, args: ["class.has-placeholder",] }, { type: i0.Input }],
        autocomplete: [{ type: i0.Input }],
        icon: [{ type: i0.HostBinding, args: ["class.mdl-textfield--expandable",] }, { type: i0.Input }],
        tabindex: [{ type: i0.Input }],
        maxlength: [{ type: i0.Input }],
        isTextfield: [{ type: i0.HostBinding, args: ["class.mdl-textfield",] }],
        isUpgraded: [{ type: i0.HostBinding, args: ["class.is-upgraded",] }],
        value: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        readonly: [{ type: i0.Input }],
        required: [{ type: i0.Input }],
        autofocus: [{ type: i0.Input }],
        isFloatingLabel: [{ type: i0.HostBinding, args: ["class.mdl-textfield--floating-label",] }, { type: i0.Input, args: ["floating-label",] }],
        rows: [{ type: i0.Input }],
        maxrows: [{ type: i0.Input }],
        disableNativeValidityChecking: [{ type: i0.Input }]
    };

    var MdlTextFieldModule = /** @class */ (function () {
        function MdlTextFieldModule() {
        }
        MdlTextFieldModule.forRoot = function () {
            return {
                ngModule: MdlTextFieldModule,
                providers: [],
            };
        };
        return MdlTextFieldModule;
    }());
    MdlTextFieldModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [MdlIconModule, MdlButtonModule, forms.FormsModule, common.CommonModule],
                    exports: [MdlTextFieldComponent],
                    declarations: [MdlTextFieldComponent],
                },] }
    ];

    var MdlTooltipPositionService = /** @class */ (function () {
        function MdlTooltipPositionService() {
        }
        MdlTooltipPositionService.prototype.calcStyle = function (offsetWidth, offsetHeight, props, position) {
            var result = {};
            var left = props.left + props.width / 2;
            var top = props.top + props.height / 2;
            var marginLeft = -1 * (offsetWidth / 2);
            var marginTop = -1 * (offsetHeight / 2);
            if (position === "left" || position === "right") {
                if (top + marginTop < 0) {
                    result.top = "0";
                    result.marginTop = "0";
                }
                else {
                    result.top = top + "px";
                    result.marginTop = marginTop + "px";
                }
            }
            else {
                if (left + marginLeft < 0) {
                    result.left = "0";
                    result.marginLeft = "0";
                }
                else {
                    result.left = left + "px";
                    result.marginLeft = marginLeft + "px";
                }
            }
            if (position === "top") {
                result.top = props.top - offsetHeight - 10 + "px";
            }
            else if (position === "right") {
                result.left = props.left + props.width + 10 + "px";
            }
            else if (position === "left") {
                result.left = props.left - offsetWidth - 10 + "px";
            }
            else {
                result.top = props.top + props.height + 10 + "px";
            }
            return result;
        };
        return MdlTooltipPositionService;
    }());
    MdlTooltipPositionService.decorators = [
        { type: i0.Injectable }
    ];

    var IS_ACTIVE = "is-active";
    var MdlSimpleTooltipComponent = /** @class */ (function () {
        function MdlSimpleTooltipComponent(elRef, renderer, mdlTooltipPositionService) {
            this.elRef = elRef;
            this.renderer = renderer;
            this.mdlTooltipPositionService = mdlTooltipPositionService;
            this.large = false;
            this.isTooltip = true;
            this.active = false;
            this.element = elRef.nativeElement;
        }
        Object.defineProperty(MdlSimpleTooltipComponent.prototype, "isBottom", {
            get: function () {
                return this.position === "bottom";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlSimpleTooltipComponent.prototype, "isRight", {
            get: function () {
                return this.position === "right";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MdlSimpleTooltipComponent.prototype, "isLeft", {
            get: function () {
                return this.position === "left";
            },
            enumerable: false,
            configurable: true
        });
        MdlSimpleTooltipComponent.prototype.isTop = function () {
            return this.position === "top";
        };
        MdlSimpleTooltipComponent.prototype.mouseLeave = function () {
            if (this.delayTimeout) {
                clearTimeout(this.delayTimeout);
            }
            this.setActive(false);
        };
        MdlSimpleTooltipComponent.prototype.mouseEnter = function (event) {
            var _this = this;
            if (this.delay) {
                this.delayTimeout = setTimeout(function () {
                    _this.show(event.target);
                }, this.delay);
            }
            else {
                this.show(event.target);
            }
        };
        MdlSimpleTooltipComponent.prototype.isActive = function () {
            return this.active;
        };
        MdlSimpleTooltipComponent.prototype.show = function (element) {
            var e_1, _a;
            var props = element.getBoundingClientRect();
            var offsetWidth = this.element.offsetWidth;
            var offsetHeight = this.element.offsetHeight;
            var style = this.mdlTooltipPositionService.calcStyle(offsetWidth, offsetHeight, props, this.position);
            try {
                for (var _b = __values(Object.keys(style)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    this.renderer.setStyle(this.elRef.nativeElement, key, style[key]);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.setActive(true);
        };
        MdlSimpleTooltipComponent.prototype.setActive = function (active) {
            this.active = active;
            if (active) {
                this.renderer.addClass(this.elRef.nativeElement, IS_ACTIVE);
            }
            else {
                this.renderer.removeClass(this.elRef.nativeElement, IS_ACTIVE);
            }
        };
        return MdlSimpleTooltipComponent;
    }());
    MdlSimpleTooltipComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-simple-tooltip",
                    template: "<div>{{tooltipText}}</div>",
                    providers: [MdlTooltipPositionService],
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlSimpleTooltipComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: MdlTooltipPositionService }
    ]; };
    MdlSimpleTooltipComponent.propDecorators = {
        large: [{ type: i0.HostBinding, args: ["class.mdl-tooltip--large",] }],
        position: [{ type: i0.Input }],
        delay: [{ type: i0.Input }],
        isTooltip: [{ type: i0.HostBinding, args: ["class.mdl-tooltip",] }],
        isBottom: [{ type: i0.HostBinding, args: ["class.mdl-tooltip--bottom",] }],
        isRight: [{ type: i0.HostBinding, args: ["class.mdl-tooltip--right",] }],
        isLeft: [{ type: i0.HostBinding, args: ["class.mdl-tooltip--left",] }],
        isTop: [{ type: i0.HostBinding, args: ["class.mdl-tooltip--top",] }]
    };
    var MdlTooltipComponent = /** @class */ (function (_super) {
        __extends(MdlTooltipComponent, _super);
        function MdlTooltipComponent(elRef, renderer, mdlTooltipPositionService) {
            return _super.call(this, elRef, renderer, mdlTooltipPositionService) || this;
        }
        return MdlTooltipComponent;
    }(MdlSimpleTooltipComponent));
    MdlTooltipComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: "mdl-tooltip",
                    template: "<div><ng-content></ng-content></div>",
                    exportAs: "mdlTooltip",
                    providers: [MdlTooltipPositionService],
                    encapsulation: i0.ViewEncapsulation.None
                },] }
    ];
    MdlTooltipComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: MdlTooltipPositionService }
    ]; };

    var AbstractMdlTooltipDirective = /** @class */ (function () {
        function AbstractMdlTooltipDirective(vcRef, large, componentFactoryResolver) {
            this.vcRef = vcRef;
            this.large = large;
            this.componentFactoryResolver = componentFactoryResolver;
        }
        AbstractMdlTooltipDirective.prototype.onMouseEnter = function (event) {
            this.tooltipComponent.mouseEnter(event);
        };
        AbstractMdlTooltipDirective.prototype.onMouseLeave = function () {
            this.tooltipComponent.mouseLeave();
        };
        AbstractMdlTooltipDirective.prototype.ngOnInit = function () {
            // if the tooltip is not an instance of MdlTooltipComponent
            // we create a simpleTooltipComponent on the fly.
            if (!(this.tooltip instanceof MdlTooltipComponent)) {
                var cFactory = this.componentFactoryResolver.resolveComponentFactory(MdlSimpleTooltipComponent);
                var cRef = this.vcRef.createComponent(cFactory);
                this.tooltipComponent = cRef.instance;
                this.tooltipComponent.tooltipText = this.tooltip;
                this.configureTooltipComponent();
            }
            else {
                this.tooltipComponent = this.tooltip;
                this.configureTooltipComponent();
            }
        };
        AbstractMdlTooltipDirective.prototype.ngOnChanges = function (changes) {
            if (changes.tooltip && !changes.tooltip.isFirstChange()) {
                if (!(this.tooltip instanceof MdlTooltipComponent)) {
                    this.tooltipComponent.tooltipText = this.tooltip;
                }
            }
        };
        AbstractMdlTooltipDirective.prototype.configureTooltipComponent = function () {
            this.tooltipComponent.large = this.large;
            this.tooltipComponent.position = this.position;
        };
        return AbstractMdlTooltipDirective;
    }());
    AbstractMdlTooltipDirective.decorators = [
        { type: i0.Directive }
    ];
    AbstractMdlTooltipDirective.ctorParameters = function () { return [
        { type: i0.ViewContainerRef },
        { type: Boolean },
        { type: i0.ComponentFactoryResolver }
    ]; };
    AbstractMdlTooltipDirective.propDecorators = {
        onMouseEnter: [{ type: i0.HostListener, args: ["touchend", ["$event"],] }, { type: i0.HostListener, args: ["mouseenter", ["$event"],] }],
        onMouseLeave: [{ type: i0.HostListener, args: ["window:touchstart",] }, { type: i0.HostListener, args: ["mouseleave",] }]
    };
    var MdlTooltipDirective = /** @class */ (function (_super) {
        __extends(MdlTooltipDirective, _super);
        function MdlTooltipDirective(vcRef, componentFactoryResolver) {
            return _super.call(this, vcRef, false, componentFactoryResolver) || this;
        }
        return MdlTooltipDirective;
    }(AbstractMdlTooltipDirective));
    MdlTooltipDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: '[mdl-tooltip]'
                },] }
    ];
    MdlTooltipDirective.ctorParameters = function () { return [
        { type: i0.ViewContainerRef },
        { type: i0.ComponentFactoryResolver }
    ]; };
    MdlTooltipDirective.propDecorators = {
        tooltip: [{ type: i0.Input, args: ["mdl-tooltip",] }],
        position: [{ type: i0.Input, args: ["mdl-tooltip-position",] }]
    };
    var MdlTooltipLargeDirective = /** @class */ (function (_super) {
        __extends(MdlTooltipLargeDirective, _super);
        function MdlTooltipLargeDirective(vcRef, componentFactoryResolver) {
            return _super.call(this, vcRef, true, componentFactoryResolver) || this;
        }
        return MdlTooltipLargeDirective;
    }(AbstractMdlTooltipDirective));
    MdlTooltipLargeDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line
                    selector: '[mdl-tooltip-large]'
                },] }
    ];
    MdlTooltipLargeDirective.ctorParameters = function () { return [
        { type: i0.ViewContainerRef },
        { type: i0.ComponentFactoryResolver }
    ]; };
    MdlTooltipLargeDirective.propDecorators = {
        tooltip: [{ type: i0.Input, args: ["mdl-tooltip-large",] }],
        position: [{ type: i0.Input, args: ["mdl-tooltip-position",] }]
    };

    var MDL_TOOLTIP_DIRECTIVES = [
        MdlTooltipComponent,
        MdlTooltipLargeDirective,
        MdlTooltipDirective,
    ];
    var MdlTooltipModule = /** @class */ (function () {
        function MdlTooltipModule() {
        }
        MdlTooltipModule.forRoot = function () {
            return {
                ngModule: MdlTooltipModule,
                providers: [],
            };
        };
        return MdlTooltipModule;
    }());
    MdlTooltipModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [],
                    exports: MDL_TOOLTIP_DIRECTIVES,
                    declarations: __spreadArray(__spreadArray([], __read(MDL_TOOLTIP_DIRECTIVES)), [MdlSimpleTooltipComponent]),
                    entryComponents: [MdlSimpleTooltipComponent],
                },] }
    ];

    var MODULES = [
        MdlBadgeModule,
        MdlButtonModule,
        MdlCardModule,
        MdlCheckboxModule,
        MdlChipModule,
        MdlCommonsModule,
        MdlDialogModule,
        MdlDialogOutletModule,
        MdlIconModule,
        MdlIconToggleModule,
        MdlLayoutModule,
        MdlListModule,
        MdlMenuModule,
        MdlProgressModule,
        MdlRadioModule,
        MdlRippleModule,
        MdlShadowModule,
        MdlSliderModule,
        MdlSnackbarModule,
        MdlSpinnerModule,
        MdlSwitchModule,
        MdlTableModule,
        MdlTabsModule,
        MdlTextFieldModule,
        MdlTooltipModule,
    ];
    var MdlModule = /** @class */ (function () {
        function MdlModule() {
        }
        return MdlModule;
    }());
    MdlModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [],
                    imports: [
                        MdlButtonModule.forRoot(),
                        MdlLayoutModule.forRoot(),
                        MdlCheckboxModule.forRoot(),
                        MdlChipModule.forRoot(),
                        MdlDialogModule.forRoot(),
                        MdlDialogOutletModule.forRoot(),
                        MdlSpinnerModule.forRoot(),
                        MdlBadgeModule.forRoot(),
                        MdlShadowModule.forRoot(),
                        MdlCardModule.forRoot(),
                        MdlRadioModule.forRoot(),
                        MdlRippleModule.forRoot(),
                        MdlProgressModule.forRoot(),
                        MdlIconModule.forRoot(),
                        MdlIconToggleModule.forRoot(),
                        MdlListModule.forRoot(),
                        MdlSliderModule.forRoot(),
                        MdlSwitchModule.forRoot(),
                        MdlSnackbarModule.forRoot(),
                        MdlTooltipModule.forRoot(),
                        MdlTableModule.forRoot(),
                        MdlMenuModule.forRoot(),
                        MdlTabsModule.forRoot(),
                        MdlTextFieldModule.forRoot(),
                    ],
                    exports: __spreadArray([], __read(MODULES)),
                },] }
    ];
    // @deprectaed use MdlModule - all services are provided in root by default.
    var MdlNonRootModule = /** @class */ (function () {
        function MdlNonRootModule() {
        }
        MdlNonRootModule.forRoot = function () {
            return { ngModule: MdlModule };
        };
        return MdlNonRootModule;
    }());
    MdlNonRootModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: MODULES,
                    exports: MODULES,
                },] }
    ];

    /*
     * Public API Surface of core
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AbstractMdlTooltipDirective = AbstractMdlTooltipDirective;
    exports.Animations = Animations;
    exports.AppendViewContainerRefDirective = AppendViewContainerRefDirective;
    exports.CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR = CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR;
    exports.DISABLE_NATIVE_VALIDITY_CHECKING = DISABLE_NATIVE_VALIDITY_CHECKING;
    exports.LAYOUT_SCREEN_SIZE_THRESHOLD = LAYOUT_SCREEN_SIZE_THRESHOLD;
    exports.MdLUnsupportedLayoutTypeError = MdLUnsupportedLayoutTypeError;
    exports.MdlAlertComponent = MdlAlertComponent;
    exports.MdlAnchorRippleDirective = MdlAnchorRippleDirective;
    exports.MdlBackdropOverlayComponent = MdlBackdropOverlayComponent;
    exports.MdlBadgeDirective = MdlBadgeDirective;
    exports.MdlBadgeModule = MdlBadgeModule;
    exports.MdlBadgeNoBackgroundDirective = MdlBadgeNoBackgroundDirective;
    exports.MdlBadgeOverlapDirective = MdlBadgeOverlapDirective;
    exports.MdlButtonComponent = MdlButtonComponent;
    exports.MdlButtonModule = MdlButtonModule;
    exports.MdlButtonRippleDirective = MdlButtonRippleDirective;
    exports.MdlCardActionsComponent = MdlCardActionsComponent;
    exports.MdlCardBorderDirective = MdlCardBorderDirective;
    exports.MdlCardChildStructure = MdlCardChildStructure;
    exports.MdlCardComponent = MdlCardComponent;
    exports.MdlCardExpandDirective = MdlCardExpandDirective;
    exports.MdlCardMediaComponent = MdlCardMediaComponent;
    exports.MdlCardMenuComponent = MdlCardMenuComponent;
    exports.MdlCardModule = MdlCardModule;
    exports.MdlCardSupportingTextComponent = MdlCardSupportingTextComponent;
    exports.MdlCardTitleComponent = MdlCardTitleComponent;
    exports.MdlCardTitleTextDirective = MdlCardTitleTextDirective;
    exports.MdlCheckboxComponent = MdlCheckboxComponent;
    exports.MdlCheckboxModule = MdlCheckboxModule;
    exports.MdlCheckboxRippleDirective = MdlCheckboxRippleDirective;
    exports.MdlChipComponent = MdlChipComponent;
    exports.MdlChipContactDirective = MdlChipContactDirective;
    exports.MdlChipModule = MdlChipModule;
    exports.MdlCommonsModule = MdlCommonsModule;
    exports.MdlDefaultTableModel = MdlDefaultTableModel;
    exports.MdlDialogComponent = MdlDialogComponent;
    exports.MdlDialogHostComponent = MdlDialogHostComponent;
    exports.MdlDialogModule = MdlDialogModule;
    exports.MdlDialogOutletComponent = MdlDialogOutletComponent;
    exports.MdlDialogOutletModule = MdlDialogOutletModule;
    exports.MdlDialogOutletService = MdlDialogOutletService;
    exports.MdlDialogReference = MdlDialogReference;
    exports.MdlDialogService = MdlDialogService;
    exports.MdlError = MdlError;
    exports.MdlIconComponent = MdlIconComponent;
    exports.MdlIconModule = MdlIconModule;
    exports.MdlIconToggleComponent = MdlIconToggleComponent;
    exports.MdlIconToggleModule = MdlIconToggleModule;
    exports.MdlIconToggleRippleDirective = MdlIconToggleRippleDirective;
    exports.MdlLayoutComponent = MdlLayoutComponent;
    exports.MdlLayoutContentComponent = MdlLayoutContentComponent;
    exports.MdlLayoutDrawerComponent = MdlLayoutDrawerComponent;
    exports.MdlLayoutHeaderComponent = MdlLayoutHeaderComponent;
    exports.MdlLayoutHeaderRowComponent = MdlLayoutHeaderRowComponent;
    exports.MdlLayoutHeaderTransparentDirective = MdlLayoutHeaderTransparentDirective;
    exports.MdlLayoutModule = MdlLayoutModule;
    exports.MdlLayoutSpacerComponent = MdlLayoutSpacerComponent;
    exports.MdlLayoutTabPanelComponent = MdlLayoutTabPanelComponent;
    exports.MdlLayoutTitleComponent = MdlLayoutTitleComponent;
    exports.MdlListComponent = MdlListComponent;
    exports.MdlListItemAvatarDirective = MdlListItemAvatarDirective;
    exports.MdlListItemComponent = MdlListItemComponent;
    exports.MdlListItemIconDirective = MdlListItemIconDirective;
    exports.MdlListItemPrimaryContentComponent = MdlListItemPrimaryContentComponent;
    exports.MdlListItemSecondaryActionComponent = MdlListItemSecondaryActionComponent;
    exports.MdlListItemSecondaryContentComponent = MdlListItemSecondaryContentComponent;
    exports.MdlListItemSecondaryInfoComponent = MdlListItemSecondaryInfoComponent;
    exports.MdlListItemSubTitleComponent = MdlListItemSubTitleComponent;
    exports.MdlListItemTextBodyComponent = MdlListItemTextBodyComponent;
    exports.MdlListModule = MdlListModule;
    exports.MdlMenuComponent = MdlMenuComponent;
    exports.MdlMenuError = MdlMenuError;
    exports.MdlMenuItemComponent = MdlMenuItemComponent;
    exports.MdlMenuItemFullBleedDeviderDirective = MdlMenuItemFullBleedDeviderDirective;
    exports.MdlMenuItemRippleDirective = MdlMenuItemRippleDirective;
    exports.MdlMenuModule = MdlMenuModule;
    exports.MdlMenuRegisty = MdlMenuRegisty;
    exports.MdlModule = MdlModule;
    exports.MdlNonRootModule = MdlNonRootModule;
    exports.MdlProgressComponent = MdlProgressComponent;
    exports.MdlProgressModule = MdlProgressModule;
    exports.MdlRadioComponent = MdlRadioComponent;
    exports.MdlRadioGroupRegisty = MdlRadioGroupRegisty;
    exports.MdlRadioModule = MdlRadioModule;
    exports.MdlRadioRippleDirective = MdlRadioRippleDirective;
    exports.MdlRippleDirective = MdlRippleDirective;
    exports.MdlRippleModule = MdlRippleModule;
    exports.MdlScreenSizeService = MdlScreenSizeService;
    exports.MdlSelectableTableComponent = MdlSelectableTableComponent;
    exports.MdlShadowDirective = MdlShadowDirective;
    exports.MdlShadowModule = MdlShadowModule;
    exports.MdlSimpleDialogComponent = MdlSimpleDialogComponent;
    exports.MdlSimpleTooltipComponent = MdlSimpleTooltipComponent;
    exports.MdlSliderComponent = MdlSliderComponent;
    exports.MdlSliderModule = MdlSliderModule;
    exports.MdlSnackbarComponent = MdlSnackbarComponent;
    exports.MdlSnackbarModule = MdlSnackbarModule;
    exports.MdlSnackbarService = MdlSnackbarService;
    exports.MdlSpinnerComponent = MdlSpinnerComponent;
    exports.MdlSpinnerModule = MdlSpinnerModule;
    exports.MdlStructureError = MdlStructureError;
    exports.MdlSwitchComponent = MdlSwitchComponent;
    exports.MdlSwitchModule = MdlSwitchModule;
    exports.MdlSwitchRippleDirective = MdlSwitchRippleDirective;
    exports.MdlTabPanelComponent = MdlTabPanelComponent;
    exports.MdlTabPanelContentComponent = MdlTabPanelContentComponent;
    exports.MdlTabPanelTitleComponent = MdlTabPanelTitleComponent;
    exports.MdlTableComponent = MdlTableComponent;
    exports.MdlTableModule = MdlTableModule;
    exports.MdlTabsComponent = MdlTabsComponent;
    exports.MdlTabsModule = MdlTabsModule;
    exports.MdlTextFieldComponent = MdlTextFieldComponent;
    exports.MdlTextFieldModule = MdlTextFieldModule;
    exports.MdlToggleMenuDirective = MdlToggleMenuDirective;
    exports.MdlTooltipComponent = MdlTooltipComponent;
    exports.MdlTooltipDirective = MdlTooltipDirective;
    exports.MdlTooltipLargeDirective = MdlTooltipLargeDirective;
    exports.MdlTooltipModule = MdlTooltipModule;
    exports.MdlUnsupportedButtonTypeError = MdlUnsupportedButtonTypeError;
    exports.MdlUnsupportedColoredTypeError = MdlUnsupportedColoredTypeError;
    exports.MdlUnsupportedCountOfListItemLinesError = MdlUnsupportedCountOfListItemLinesError;
    exports.MdlUnsupportedShadowValueError = MdlUnsupportedShadowValueError;
    exports.NativeWebAnimationPlayer = NativeWebAnimationPlayer;
    exports.NativeWebAnimations = NativeWebAnimations;
    exports.NoopAnimationPlayer = NoopAnimationPlayer;
    exports.NoopWebAnimations = NoopWebAnimations;
    exports.callNative = callNative;
    exports.instantiateSupportedAnimationDriver = instantiateSupportedAnimationDriver;
    exports.noop = noop;
    exports.toBoolean = toBoolean;
    exports.toNumber = toNumber;
    exports.ɵ1 = ɵ1;
    exports.ɵ2 = ɵ2;
    exports.ɵa = MdlLayoutMediatorService;
    exports.ɵb = MdlDialogInnerOutletComponent;
    exports.ɵc = MDL_CONFIGUARTION;
    exports.ɵd = InternalMdlDialogReference;
    exports.ɵe = MdlTooltipPositionService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=angular-mdl-core.umd.js.map
