import * as i0 from '@angular/core';
import { Directive, ViewContainerRef, Renderer2, Input, NgModule, Injectable, Component, ViewEncapsulation, ElementRef, HostBinding, HostListener, ContentChild, ContentChildren, InjectionToken, NgZone, Optional, Inject, EventEmitter, Output, forwardRef, ChangeDetectionStrategy, ViewChildren, ViewChild, ApplicationRef, ComponentFactoryResolver, Injector, TemplateRef } from '@angular/core';
import { EventManager } from '@angular/platform-browser';
import { Subject, BehaviorSubject } from 'rxjs';
import { CommonModule } from '@angular/common';
import { NG_VALUE_ACCESSOR, FormsModule, FormGroupName } from '@angular/forms';
import { take, filter } from 'rxjs/operators';

class AppendViewContainerRefDirective {
    constructor(viewRef, renderer) {
        this.viewRef = viewRef;
        this.renderer = renderer;
    }
    ngAfterViewInit() {
        this.renderer.appendChild(this.viewRef.element.nativeElement, this.viewContainerRefToAppend.element.nativeElement);
    }
}
AppendViewContainerRefDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: '[append-view-container-ref]'
            },] }
];
AppendViewContainerRefDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Renderer2 }
];
AppendViewContainerRefDirective.propDecorators = {
    viewContainerRefToAppend: [{ type: Input, args: ["append-view-container-ref",] }]
};

class NativeWebAnimationPlayer {
    constructor(element, keyframes, duration, easing) {
        this.element = element;
        this.keyframes = keyframes;
        this.duration = duration;
        this.easing = easing;
        this.onDoneCallback = [];
    }
    onDone(fn) {
        this.onDoneCallback.push(fn);
    }
    play() {
        const animation = this.element.animate(this.keyframes, {
            duration: this.duration,
            easing: this.easing,
            fill: "forwards",
        });
        animation.addEventListener("finish", () => this.onDoneCallback.forEach((fn) => fn()));
    }
}
class NoopAnimationPlayer {
    constructor() {
        this.onDoneCallback = [];
    }
    onDone(fn) {
        this.onDoneCallback.push(fn);
    }
    play() {
        this.onDoneCallback.forEach((fn) => fn());
    }
}
class Animations {
}
class NativeWebAnimations {
    animate(element, keyframes, duration, easing) {
        return new NativeWebAnimationPlayer(element, keyframes, duration, easing);
    }
}
class NoopWebAnimations {
    animate() {
        return new NoopAnimationPlayer();
    }
}

const toBoolean = (value) => value != null && `${value}` !== "false";

/**
 * Wrapper for mdl error messages.
 */
class MdlError extends Error {
    constructor(value) {
        /* istanbul ignore next */
        super(value);
    }
}
class MdlStructureError extends MdlError {
    constructor(child, requiredParent) {
        /* istanbul ignore next */
        super(`"${child}" requires "${requiredParent}" as a parent.`);
    }
}

const callNative = (el, method, arg = null) => {
    /* istanbul ignore next */ // if this code runs in browser this is allways true!
    if (el[method]) {
        el[method](arg);
    }
};

/* istanbul ignore next */
// eslint-disable-next-line @typescript-eslint/no-empty-function
const noop = () => { };

const toNumber = (value) => {
    if (typeof value === "undefined") {
        return null;
    }
    else if (typeof value === "string") {
        return parseInt(value, 10);
    }
    return value;
};

// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function isWebAnimationsSupported() {
    return (typeof Element !== "undefined" &&
        typeof Element.prototype.animate === "function");
}
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function instantiateSupportedAnimationDriver() {
    /* istanbul ignore next */
    if (isWebAnimationsSupported()) {
        return new NativeWebAnimations();
    }
    /* istanbul ignore next */
    return new NoopWebAnimations();
}
class MdlCommonsModule {
}
MdlCommonsModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                exports: [AppendViewContainerRefDirective],
                declarations: [AppendViewContainerRefDirective],
                providers: [
                    { provide: Animations, useFactory: instantiateSupportedAnimationDriver },
                ],
            },] }
];

class MdlLayoutMediatorService {
    constructor() {
        this.tabMouseoverSubject = new Subject();
        this.tabMouseoutSubject = new Subject();
        this.tabSelectedSubject = new Subject();
    }
    onTabMouseover() {
        return this.tabMouseoverSubject.asObservable();
    }
    tabMouseover(tab) {
        this.tabMouseoverSubject.next(tab);
    }
    onTabMouseOut() {
        return this.tabMouseoutSubject.asObservable();
    }
    tabMouseout(tab) {
        this.tabMouseoutSubject.next(tab);
    }
    onTabSelected() {
        return this.tabSelectedSubject.asObservable();
    }
    tabSelected(tab) {
        this.tabSelectedSubject.next(tab);
    }
}
MdlLayoutMediatorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MdlLayoutMediatorService_Factory() { return new MdlLayoutMediatorService(); }, token: MdlLayoutMediatorService, providedIn: "root" });
MdlLayoutMediatorService.decorators = [
    { type: Injectable, args: [{
                providedIn: "root",
            },] }
];

class MdlLayoutHeaderComponent {
    constructor(elementRef, layoutMediatorService) {
        this.elementRef = elementRef;
        this.layoutMediatorService = layoutMediatorService;
        this.isSeamed = false;
        this.isLayoutHeader = true;
        this.isCompact = false;
        this.isAnimating = false;
        this.isRipple = true;
        this.el = elementRef.nativeElement;
    }
    get isWaterfall() {
        return this.mode === "waterfall";
    }
    get isCastingShadow() {
        return this.mode === "standard" || this.isCompact;
    }
    get isHeaderScroll() {
        return this.mode === "scroll";
    }
    onTransitionEnd() {
        this.isAnimating = false;
    }
    onClick() {
        if (this.isCompact) {
            this.isCompact = false;
            this.isAnimating = true;
        }
    }
    onTabMouseover(tab) {
        this.layoutMediatorService.tabMouseover(tab);
    }
    onTabMouseout(tab) {
        this.layoutMediatorService.tabMouseout(tab);
    }
    tabSelected(tab) {
        this.layoutMediatorService.tabSelected(tab);
    }
}
MdlLayoutHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-layout-header",
                template: `
    <ng-content></ng-content>
    <div
      *ngIf="tabs?.toArray()?.length > 0"
      class="mdl-layout__tab-bar-container"
    >
      <div class="mdl-layout__tab-bar is-casting-shadow">
        <div
          *ngFor="let tab of tabs.toArray()"
          class="mdl-layout__tab"
          [ngClass]="{ 'is-active': tab.isActive }"
          (mouseover)="onTabMouseover(tab)"
          (mouseout)="onTabMouseout(tab)"
        >
          <div
            *ngIf="tab.titleComponent"
            (click)="tabSelected(tab)"
            [mdl-ripple]="isRipple"
            [append-view-container-ref]="tab.titleComponent.vcRef"
          ></div>
          <a
            *ngIf="!tab.titleComponent"
            href="javascript:void(0)"
            (click)="tabSelected(tab)"
            class="mdl-layout__tab"
            [ngClass]="{ 'is-active': tab.isActive }"
            [mdl-ripple]="isRipple"
            >{{ tab.title }}</a
          >
        </div>
      </div>
    </div>
  `,
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlLayoutHeaderComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: MdlLayoutMediatorService }
];
MdlLayoutHeaderComponent.propDecorators = {
    isSeamed: [{ type: HostBinding, args: ["class.mdl-layout__header--seamed",] }],
    isLayoutHeader: [{ type: HostBinding, args: ["class.mdl-layout__header",] }],
    isCompact: [{ type: HostBinding, args: ["class.is-compact",] }],
    isWaterfall: [{ type: HostBinding, args: ["class.mdl-layout__header--waterfall",] }],
    isCastingShadow: [{ type: HostBinding, args: ["class.is-casting-shadow",] }],
    isHeaderScroll: [{ type: HostBinding, args: ["class.mdl-layout__header--scroll",] }],
    onTransitionEnd: [{ type: HostListener, args: ["transitionend",] }],
    onClick: [{ type: HostListener, args: ["click",] }]
};

class MdlLayoutDrawerComponent {
    constructor() {
        this.isDrawer = true;
        this.isDrawerVisible = false;
    }
}
MdlLayoutDrawerComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-layout-drawer",
                template: ` <ng-content></ng-content>`,
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlLayoutDrawerComponent.propDecorators = {
    isDrawer: [{ type: HostBinding, args: ["class.mdl-layout__drawer",] }],
    isDrawerVisible: [{ type: HostBinding, args: ["class.is-visible",] }]
};

class MdlTabPanelTitleComponent {
    constructor(vcRef) {
        this.vcRef = vcRef;
    }
}
MdlTabPanelTitleComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-tab-panel-title",
                template: ` <ng-content></ng-content> `,
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlTabPanelTitleComponent.ctorParameters = () => [
    { type: ViewContainerRef }
];

class MdlLayoutTabPanelComponent {
    constructor() {
        this.isLayoutTabPanel = true;
        this.isActive = false;
    }
}
MdlLayoutTabPanelComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-layout-tab-panel",
                template: `
    <ng-content
      *ngIf="titleComponent"
      select="mdl-tab-panel-content"
    ></ng-content>
    <ng-content *ngIf="!titleComponent"></ng-content>
  `,
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlLayoutTabPanelComponent.propDecorators = {
    titleComponent: [{ type: ContentChild, args: [MdlTabPanelTitleComponent, { static: true },] }],
    title: [{ type: Input, args: ["mdl-layout-tab-panel-title",] }],
    isLayoutTabPanel: [{ type: HostBinding, args: ["class.mdl-layout__tab-panel",] }],
    isActive: [{ type: HostBinding, args: ["class.is-active",] }]
};

class MdlLayoutContentComponent {
    constructor(elRef) {
        this.elRef = elRef;
        this.isContent = true;
        this.el = elRef.nativeElement;
    }
}
MdlLayoutContentComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-layout-content",
                template: ` <ng-content></ng-content>`,
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlLayoutContentComponent.ctorParameters = () => [
    { type: ElementRef }
];
MdlLayoutContentComponent.propDecorators = {
    isContent: [{ type: HostBinding, args: ["class.mdl-layout__content",] }],
    tabs: [{ type: ContentChildren, args: [MdlLayoutTabPanelComponent,] }]
};

const ESCAPE = 27;
const STANDARD = "standard";
const WATERFALL = "waterfall";
const SCROLL = "scroll";
/**
 * The LAYOUT_SCREEN_SIZE_THRESHOLD can be changed at the root module. Just provide a value for this InjectionToken:
 *
 * providers: [
 *  {provide:LAYOUT_SCREEN_SIZE_THRESHOLD, useValue: 768 }
 * ]
 *
 * you also need to change the scss variable to the same value: $layout-screen-size-threshold: 768px.
 *
 * It should be clear that this can only be used if you are using the scss and not the pre compiled css from getmdl.io.
 *
 */
const LAYOUT_SCREEN_SIZE_THRESHOLD = new InjectionToken("layoutScreenSizeThreshold");
class MdLUnsupportedLayoutTypeError extends MdlError {
    constructor(type) {
        /* istanbul ignore next */
        super(`Layout type "${type}" isn't supported by mdl-layout (allowed: standard, waterfall, scroll).`);
    }
}
class MdlScreenSizeService {
    constructor(ngZone, layoutScreenSizeThreshold) {
        this.layoutScreenSizeThreshold = layoutScreenSizeThreshold;
        this.sizesSubject = new BehaviorSubject(false);
        // if no value is injected the default size wil be used. same as $layout-screen-size-threshold in scss
        if (!this.layoutScreenSizeThreshold) {
            this.layoutScreenSizeThreshold = 1024;
        }
        // do not try to access the window object if rendered on the server
        if (typeof window === "object" && "matchMedia" in window) {
            const query = window.matchMedia(`(max-width: ${this.layoutScreenSizeThreshold}px)`);
            const queryListener = () => {
                ngZone.run(() => {
                    this.sizesSubject.next(query.matches);
                });
            };
            // - addEventListener not working in Safari
            // eslint-disable-next-line
            query.addListener(queryListener);
            this.windowMediaQueryListener = () => {
                // eslint-disable-next-line
                query.removeListener(queryListener);
            };
            // set the initial state
            this.sizesSubject.next(query.matches);
        }
    }
    isSmallScreen() {
        return this.sizesSubject.value;
    }
    sizes() {
        return this.sizesSubject.asObservable();
    }
    destroy() {
        if (this.windowMediaQueryListener) {
            this.windowMediaQueryListener();
            this.windowMediaQueryListener = null;
        }
    }
}
MdlScreenSizeService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MdlScreenSizeService_Factory() { return new MdlScreenSizeService(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(LAYOUT_SCREEN_SIZE_THRESHOLD, 8)); }, token: MdlScreenSizeService, providedIn: "root" });
MdlScreenSizeService.decorators = [
    { type: Injectable, args: [{
                providedIn: "root",
            },] }
];
MdlScreenSizeService.ctorParameters = () => [
    { type: NgZone },
    { type: Number, decorators: [{ type: Optional }, { type: Inject, args: [LAYOUT_SCREEN_SIZE_THRESHOLD,] }] }
];
class MdlLayoutComponent {
    constructor(renderer, evm, el, screenSizeService, layoutMediatorService) {
        this.renderer = renderer;
        this.evm = evm;
        this.el = el;
        this.screenSizeService = screenSizeService;
        this.layoutMediatorService = layoutMediatorService;
        // eslint-disable-next-line
        this.mode = STANDARD;
        // eslint-disable-next-line
        this.selectedTabEmitter = new EventEmitter();
        // eslint-disable-next-line
        this.mouseoverTabEmitter = new EventEmitter();
        // eslint-disable-next-line
        this.mouseoutTabEmitter = new EventEmitter();
        // eslint-disable-next-line
        this.onOpen = new EventEmitter();
        // eslint-disable-next-line
        this.onClose = new EventEmitter();
        this.isDrawerVisible = false;
        this.isSmallScreen = false;
        this.isFixedDrawerIntern = false;
        this.isFixedHeaderIntern = false;
        this.isSeamedIntern = false;
        this.selectedIndexIntern = 0;
        this.isNoDrawerIntern = false;
        this.subscriptions = [];
    }
    get isFixedDrawer() {
        return this.isFixedDrawerIntern;
    }
    set isFixedDrawer(value) {
        this.isFixedDrawerIntern = toBoolean(value);
    }
    get isFixedHeader() {
        return this.isFixedHeaderIntern;
    }
    set isFixedHeader(value) {
        this.isFixedHeaderIntern = toBoolean(value);
    }
    get isSeamed() {
        return this.isSeamedIntern;
    }
    set isSeamed(value) {
        this.isSeamedIntern = toBoolean(value);
    }
    get selectedIndex() {
        return this.selectedIndexIntern;
    }
    set selectedIndex(value) {
        this.selectedIndexIntern = toNumber(value);
    }
    get isNoDrawer() {
        return this.isNoDrawerIntern;
    }
    set isNoDrawer(value) {
        this.isNoDrawerIntern = toBoolean(value);
    }
    ngAfterContentInit() {
        this.validateMode();
        if (this.header && this.content && this.content.tabs) {
            this.header.tabs = this.content.tabs;
            this.updateSelectedTabIndex();
        }
        if (this.header && this.header.tabs) {
            this.subscriptions.push(this.layoutMediatorService
                .onTabMouseOut()
                .subscribe((tab) => {
                this.onTabMouseout(tab);
            }));
            this.subscriptions.push(this.layoutMediatorService
                .onTabMouseover()
                .subscribe((tab) => {
                this.onTabMouseover(tab);
            }));
            this.subscriptions.push(this.layoutMediatorService
                .onTabSelected()
                .subscribe((tab) => {
                this.tabSelected(tab);
            }));
        }
    }
    ngOnChanges(changes) {
        if (changes.selectedIndex) {
            this.updateSelectedTabIndex();
        }
    }
    toggleDrawer() {
        this.isDrawerVisible = !this.isDrawerVisible;
        if (this.drawers.length > 0) {
            this.setDrawerVisible(this.isDrawerVisible);
        }
    }
    closeDrawer() {
        this.isDrawerVisible = false;
        if (this.drawers.length > 0) {
            this.setDrawerVisible(false);
        }
    }
    openDrawer() {
        this.isDrawerVisible = true;
        if (this.drawers.length > 0) {
            this.setDrawerVisible(true);
        }
    }
    obfuscatorKeyDown($event) {
        if ($event.keyCode === ESCAPE) {
            this.toggleDrawer();
        }
    }
    ngOnDestroy() {
        if (this.scrollListener) {
            this.scrollListener();
            this.scrollListener = null;
        }
        this.subscriptions.forEach((sub) => sub.unsubscribe());
    }
    closeDrawerOnSmallScreens() {
        if (this.isSmallScreen && this.isDrawerVisible) {
            this.closeDrawer();
        }
    }
    openDrawerOnSmallScreens() {
        if (this.isSmallScreen && !this.isDrawerVisible) {
            this.openDrawer();
        }
    }
    hasDrawer() {
        return this.drawers.length > 0;
    }
    tabSelected(tab) {
        const index = this.header.tabs.toArray().indexOf(tab);
        if (index !== this.selectedIndex) {
            this.selectedIndex = index;
            this.updateSelectedTabIndex();
            this.selectedTabEmitter.emit({ index: this.selectedIndex });
        }
    }
    onTabMouseover(tab) {
        const index = this.header.tabs.toArray().indexOf(tab);
        this.mouseoverTabEmitter.emit({ index });
    }
    onTabMouseout(tab) {
        const index = this.header.tabs.toArray().indexOf(tab);
        this.mouseoutTabEmitter.emit({ index });
    }
    updateSelectedTabIndex() {
        if (this.header && this.header.tabs) {
            this.header.tabs.forEach((tab) => (tab.isActive = false));
            if (this.header.tabs.toArray().length > 0 &&
                this.selectedIndex < this.header.tabs.toArray().length) {
                this.header.tabs.toArray()[this.selectedIndex].isActive = true;
            }
        }
    }
    validateMode() {
        if (this.mode === "") {
            this.mode = STANDARD;
        }
        if ([STANDARD, WATERFALL, SCROLL].indexOf(this.mode) === -1) {
            throw new MdLUnsupportedLayoutTypeError(this.mode);
        }
        if (this.header) {
            // inform the header about the mode
            this.header.mode = this.mode;
            this.header.isSeamed = this.isSeamed;
        }
        if (this.content) {
            this.scrollListener = this.renderer.listen(this.content.el, "scroll", () => {
                this.onScroll(this.content.el.scrollTop);
                return true;
            });
            this.screenSizeService.sizes().subscribe((isSmall) => {
                this.onQueryChange(isSmall);
            });
        }
    }
    onScroll(scrollTop) {
        if (this.mode !== WATERFALL) {
            return;
        }
        if (this.header.isAnimating) {
            return;
        }
        const headerVisible = !this.isSmallScreen || this.isFixedHeader;
        if (scrollTop > 0 && !this.header.isCompact) {
            this.header.isCompact = true;
            if (headerVisible) {
                this.header.isAnimating = true;
            }
        }
        else if (scrollTop <= 0 && this.header.isCompact) {
            this.header.isCompact = false;
            if (headerVisible) {
                this.header.isAnimating = true;
            }
        }
    }
    onQueryChange(isSmall) {
        if (isSmall) {
            this.isSmallScreen = true;
        }
        else {
            this.isSmallScreen = false;
            this.closeDrawer();
        }
    }
    setDrawerVisible(visible) {
        this.drawers.first.isDrawerVisible = visible;
        if (this.drawers.first.isDrawerVisible) {
            this.onOpen.emit();
        }
        else {
            this.onClose.emit();
        }
    }
}
MdlLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-layout",
                template: `
    <div
      class="mdl-layout__container"
      [ngClass]="{ 'has-scrolling-header': mode === 'scroll' }"
    >
      <div
        class="mdl-layout is-upgraded"
        [ngClass]="{
          'is-small-screen': isSmallScreen,
          'mdl-layout--fixed-drawer': isFixedDrawer,
          'mdl-layout--fixed-header': isFixedHeader,
          'mdl-layout--fixed-tabs': 'tabs.toArray().length > 0'
        }"
      >
        <ng-content select="mdl-layout-header"></ng-content>
        <ng-content select="mdl-layout-drawer"></ng-content>
        <div
          *ngIf="drawers.length > 0 && isNoDrawer == false"
          class="mdl-layout__drawer-button"
          (click)="toggleDrawer()"
        >
          <mdl-icon>&#xE5D2;</mdl-icon>
        </div>
        <ng-content select="mdl-layout-content"></ng-content>
        <div
          class="mdl-layout__obfuscator"
          [ngClass]="{ 'is-visible': isDrawerVisible }"
          (click)="toggleDrawer()"
          (keydown)="obfuscatorKeyDown($event)"
        ></div>
      </div>
    </div>
  `,
                exportAs: "mdlLayout",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlLayoutComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: EventManager },
    { type: ElementRef },
    { type: MdlScreenSizeService },
    { type: MdlLayoutMediatorService }
];
MdlLayoutComponent.propDecorators = {
    header: [{ type: ContentChild, args: [MdlLayoutHeaderComponent,] }],
    drawers: [{ type: ContentChildren, args: [MdlLayoutDrawerComponent, { descendants: false },] }],
    content: [{ type: ContentChild, args: [MdlLayoutContentComponent, { static: true },] }],
    mode: [{ type: Input, args: ['mdl-layout-mode',] }],
    selectedTabEmitter: [{ type: Output, args: ['mdl-layout-tab-active-changed',] }],
    mouseoverTabEmitter: [{ type: Output, args: ['mdl-layout-tab-mouseover',] }],
    mouseoutTabEmitter: [{ type: Output, args: ['mdl-layout-tab-mouseout',] }],
    onOpen: [{ type: Output, args: ['open',] }],
    onClose: [{ type: Output, args: ['close',] }],
    isFixedDrawer: [{ type: Input, args: ["mdl-layout-fixed-drawer",] }],
    isFixedHeader: [{ type: Input, args: ["mdl-layout-fixed-header",] }],
    isSeamed: [{ type: Input, args: ["mdl-layout-header-seamed",] }],
    selectedIndex: [{ type: Input, args: ["mdl-layout-tab-active-index",] }],
    isNoDrawer: [{ type: Input, args: ["mdl-layout-no-drawer-button",] }]
};

class MdlLayoutHeaderTransparentDirective {
    constructor() {
        this.isTransparent = true;
    }
}
MdlLayoutHeaderTransparentDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: 'mdl-layout-header[mdl-layout-header-transparent]'
            },] }
];
MdlLayoutHeaderTransparentDirective.propDecorators = {
    isTransparent: [{ type: HostBinding, args: ["class.mdl-layout__header--transparent",] }]
};

class MdlLayoutHeaderRowComponent {
    constructor() {
        this.isHeaderRow = true;
    }
}
MdlLayoutHeaderRowComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-layout-header-row",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlLayoutHeaderRowComponent.propDecorators = {
    isHeaderRow: [{ type: HostBinding, args: ["class.mdl-layout__header-row",] }]
};

class MdlLayoutTitleComponent {
    constructor() {
        this.isLayoutTitle = true;
    }
}
MdlLayoutTitleComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-layout-title",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlLayoutTitleComponent.propDecorators = {
    isLayoutTitle: [{ type: HostBinding, args: ["class.mdl-layout-title",] }]
};

class MdlLayoutSpacerComponent {
    constructor() {
        this.isLayoutSpacer = true;
    }
}
MdlLayoutSpacerComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-layout-spacer",
                template: "",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlLayoutSpacerComponent.propDecorators = {
    isLayoutSpacer: [{ type: HostBinding, args: ["class.mdl-layout-spacer",] }]
};

class MdlIconComponent {
    constructor() {
        this.isMatIcon = true;
    }
}
MdlIconComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-icon",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlIconComponent.propDecorators = {
    isMatIcon: [{ type: HostBinding, args: ["class.material-icons",] }]
};

const MDL_ICON_DIRECTIVES = [MdlIconComponent];
class MdlIconModule {
    static forRoot() {
        return {
            ngModule: MdlIconModule,
            providers: [],
        };
    }
}
MdlIconModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                exports: MDL_ICON_DIRECTIVES,
                declarations: MDL_ICON_DIRECTIVES,
            },] }
];

class MdlTabPanelContentComponent {
}
MdlTabPanelContentComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-tab-panel-content",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
class MdlTabPanelComponent {
    constructor() {
        this.isTabPanel = true;
        this.isActive = false;
    }
}
MdlTabPanelComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-tab-panel",
                template: `
    <ng-content
      *ngIf="titleComponent"
      select="mdl-tab-panel-content"
    ></ng-content>
    <ng-content *ngIf="!titleComponent"></ng-content>
  `,
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlTabPanelComponent.propDecorators = {
    titleComponent: [{ type: ContentChild, args: [MdlTabPanelTitleComponent, { static: true },] }],
    title: [{ type: Input, args: ['mdl-tab-panel-title',] }],
    disabled: [{ type: Input, args: ['disabled',] }],
    isTabPanel: [{ type: HostBinding, args: ["class.mdl-tabs__panel",] }],
    isActive: [{ type: HostBinding, args: ["class.is-active",] }]
};

class MdlTabsComponent {
    constructor() {
        // eslint-disable-next-line
        this.selectedTabEmitter = new EventEmitter();
        this.isTabs = true;
        this.isUpgraded = true;
        this.selectedIndexIntern = 0;
        this.isRippleIntern = false;
    }
    get selectedIndex() {
        return this.selectedIndexIntern;
    }
    set selectedIndex(value) {
        this.selectedIndexIntern = toNumber(value);
    }
    get isRipple() {
        return this.isRippleIntern;
    }
    set isRipple(value) {
        this.isRippleIntern = toBoolean(value);
    }
    ngAfterContentInit() {
        // the initial tabs
        this.updateSelectedTabIndex();
        // listen to tab changes - this would not be necessary if this would be fixed:
        // https://github.com/angular/angular/issues/12818
        this.tabs.changes.subscribe(() => {
            this.updateSelectedTabIndex();
        });
    }
    ngOnChanges(changes) {
        if (changes.selectedIndex) {
            this.updateSelectedTabIndex();
        }
    }
    tabSelected(tab) {
        if (tab.disabled) {
            return;
        }
        const index = this.tabs.toArray().indexOf(tab);
        if (index !== this.selectedIndex) {
            this.selectedIndex = index;
            this.updateSelectedTabIndex();
            this.selectedTabEmitter.emit({ index: this.selectedIndex });
        }
    }
    updateSelectedTabIndex() {
        if (this.tabs) {
            // https://github.com/angular/angular/issues/6005
            // this would not be necessare if this would be fixed: https://github.com/angular/angular/issues/12818
            setTimeout(() => {
                this.tabs.forEach((tab, idx) => {
                    tab.isActive = this.selectedIndex === idx;
                });
            }, 1);
        }
    }
}
MdlTabsComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-tabs",
                template: `
    <div class="mdl-tabs__tab-bar">
      <div *ngFor="let tab of tabs.toArray()">
        <div
          *ngIf="tab.titleComponent"
          class="mdl-tabs__tab"
          (click)="tabSelected(tab)"
          [mdl-ripple]="isRipple && !tab.disabled"
          [ngClass]="{ 'is-active': tab.isActive, disabled: tab.disabled }"
          [append-view-container-ref]="tab.titleComponent.vcRef"
        ></div>
        <a
          *ngIf="!tab.titleComponent"
          href="javascript:void(0)"
          (click)="tabSelected(tab)"
          class="mdl-tabs__tab"
          [mdl-ripple]="isRipple && !tab.disabled"
          [ngClass]="{ 'is-active': tab.isActive, disabled: tab.disabled }"
          >{{ tab.title }}</a
        >
      </div>
    </div>
    <ng-content></ng-content>
  `,
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlTabsComponent.propDecorators = {
    selectedTabEmitter: [{ type: Output, args: ['mdl-tab-active-changed',] }],
    tabs: [{ type: ContentChildren, args: [MdlTabPanelComponent,] }],
    isTabs: [{ type: HostBinding, args: ["class.mdl-tabs",] }],
    isUpgraded: [{ type: HostBinding, args: ["class.is-upgraded",] }],
    selectedIndex: [{ type: Input, args: ["mdl-tab-active-index",] }],
    isRipple: [{ type: Input, args: ["mdl-ripple",] }]
};

/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable */
/* istanbul ignore file */
'use strict';
/**
 * Class constructor for Ripple MDL component.
 * Implements MDL component design pattern defined at:
 * https://github.com/jasonmayes/mdl-component-design-pattern
 *
 */
function MaterialRipple(renderer, element) {
    this.renderer_ = renderer;
    this.element_ = element;
    // Initialize instance.
    this.init();
}
/**
 * Store constants in one place so they can be updated easily.
 */
MaterialRipple.prototype.Constant_ = {
    INITIAL_SCALE: 'scale(0.0001, 0.0001)',
    INITIAL_SIZE: '1px',
    INITIAL_OPACITY: '0.4',
    FINAL_OPACITY: '0',
    FINAL_SCALE: ''
};
/**
 * Store strings for class names defined by this component that are used in
 * JavaScript. This allows us to simply change it in one place should we
 * decide to modify at a later date.
 */
MaterialRipple.prototype.CssClasses_ = {
    RIPPLE_CENTER: 'mdl-ripple--center',
    RIPPLE_EFFECT_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
    RIPPLE: 'mdl-ripple',
    IS_ANIMATING: 'is-animating',
    IS_VISIBLE: 'is-visible'
};
/**
 * Handle mouse / finger down on element.
 *
 */
// eslint-disable-next-line
MaterialRipple.prototype.downHandler_ = function (event) {
    if (!this.rippleElement_.style.width && !this.rippleElement_.style.height) {
        const rect = this.element_.getBoundingClientRect();
        this.boundHeight = rect.height;
        this.boundWidth = rect.width;
        this.rippleSize_ = Math.sqrt(rect.width * rect.width +
            rect.height * rect.height) * 2 + 2;
        this.rippleElement_.style.width = this.rippleSize_ + 'px';
        this.rippleElement_.style.height = this.rippleSize_ + 'px';
    }
    this.renderer_.addClass(this.rippleElement_, this.CssClasses_.IS_VISIBLE);
    if (event.type === 'mousedown' && this.ignoringMouseDown_) {
        this.ignoringMouseDown_ = false;
    }
    else {
        if (event.type === 'touchstart') {
            this.ignoringMouseDown_ = true;
        }
        const frameCount = this.getFrameCount();
        if (frameCount > 0) {
            return;
        }
        this.setFrameCount(1);
        const bound = event.currentTarget.getBoundingClientRect();
        let x;
        let y;
        // Check if we are handling a keyboard click.
        if (event.clientX === 0 && event.clientY === 0) {
            x = Math.round(bound.width / 2);
            y = Math.round(bound.height / 2);
        }
        else {
            const clientX = event.clientX !== undefined ? event.clientX : event.touches[0].clientX;
            const clientY = event.clientY !== undefined ? event.clientY : event.touches[0].clientY;
            x = Math.round(clientX - bound.left);
            y = Math.round(clientY - bound.top);
        }
        this.setRippleXY(x, y);
        this.setRippleStyles(true);
        window.requestAnimationFrame(this.animFrameHandler.bind(this));
    }
};
/**
 * Handle mouse / finger up on element.
 *
 */
// eslint-disable-next-line
MaterialRipple.prototype.upHandler_ = function (event) {
    // Don't fire for the artificial "mouseup" generated by a double-click.
    if (event && event.detail !== 2) {
        // Allow a repaint to occur before removing this class, so the animation
        // shows for tap events, which seem to trigger a mouseup too soon after
        // mousedown.
        // eslint-disable-next-line
        setTimeout(function () {
            this.renderer_.removeClass(this.rippleElement_, this.CssClasses_.IS_VISIBLE);
        }.bind(this), 0);
    }
};
/**
 * Initialize element.
 */
// eslint-disable-next-line
MaterialRipple.prototype.init = function () {
    if (this.element_) {
        const recentering = this.element_.classList.contains(this.CssClasses_.RIPPLE_CENTER);
        if (!this.element_.classList.contains(this.CssClasses_.RIPPLE_EFFECT_IGNORE_EVENTS)) {
            this.rippleElement_ = this.element_.querySelector('.' +
                this.CssClasses_.RIPPLE);
            this.frameCount_ = 0;
            this.rippleSize_ = 0;
            this.x_ = 0;
            this.y_ = 0;
            // Touch start produces a compat mouse down event, which would cause a
            // second ripples. To avoid that, we use this property to ignore the first
            // mouse down after a touch start.
            this.ignoringMouseDown_ = false;
            this.boundDownHandler = this.downHandler_.bind(this);
            this.element_.addEventListener('mousedown', this.boundDownHandler);
            this.element_.addEventListener('touchstart', this.boundDownHandler);
            this.boundUpHandler = this.upHandler_.bind(this);
            this.element_.addEventListener('mouseup', this.boundUpHandler);
            this.element_.addEventListener('mouseleave', this.boundUpHandler);
            this.element_.addEventListener('touchend', this.boundUpHandler);
            this.element_.addEventListener('blur', this.boundUpHandler);
            // eslint-disable-next-line
            this.getFrameCount = function () {
                return this.frameCount_;
            };
            // eslint-disable-next-line
            this.setFrameCount = function (fC) {
                this.frameCount_ = fC;
            };
            // eslint-disable-next-line
            this.getRippleElement = function () {
                return this.rippleElement_;
            };
            // eslint-disable-next-line
            this.setRippleXY = function (newX, newY) {
                this.x_ = newX;
                this.y_ = newY;
            };
            // eslint-disable-next-line
            this.setRippleStyles = function (start) {
                if (this.rippleElement_ !== null) {
                    let transformString;
                    let scale;
                    let size;
                    let offset = 'translate(' + this.x_ + 'px, ' + this.y_ + 'px)';
                    if (start) {
                        scale = this.Constant_.INITIAL_SCALE;
                        size = this.Constant_.INITIAL_SIZE;
                    }
                    else {
                        scale = this.Constant_.FINAL_SCALE;
                        size = this.rippleSize_ + 'px';
                        if (recentering) {
                            offset = 'translate(' + this.boundWidth / 2 + 'px, ' +
                                this.boundHeight / 2 + 'px)';
                        }
                    }
                    transformString = 'translate(-50%, -50%) ' + offset + scale;
                    this.rippleElement_.style.webkitTransform = transformString;
                    this.rippleElement_.style.msTransform = transformString;
                    this.rippleElement_.style.transform = transformString;
                    if (start) {
                        this.renderer_.removeClass(this.rippleElement_, this.CssClasses_.IS_ANIMATING);
                    }
                    else {
                        this.renderer_.addClass(this.rippleElement_, this.CssClasses_.IS_ANIMATING);
                    }
                }
            };
            /**
             * Handles an animation frame.
             */
            // eslint-disable-next-line
            this.animFrameHandler = function () {
                if (this.frameCount_-- > 0) {
                    window.requestAnimationFrame(this.animFrameHandler.bind(this));
                }
                else {
                    this.setRippleStyles(false);
                }
            };
        }
    }
};

const RIPPLE = "mdl-ripple";
// known bugs: https://github.com/google/material-design-lite/issues/4215
class MdlRippleDirective {
    constructor(elementRef, renderer, cssContainerClasses) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.cssContainerClasses = cssContainerClasses;
        this.rippleActive = true;
        this.el = elementRef.nativeElement;
    }
    ngOnChanges() {
        // remove any existing ripple container
        if (this.rippleContainer) {
            this.el.removeChild(this.rippleContainer);
            delete this.rippleContainer;
            delete this.ripple;
        }
        // if used as mdl-ripple without property binding it is an empty string
        // otherwise (e.g. [mdl-ripple] it is a boolean - may be with the default value true.
        if (this.rippleActive === "" || this.rippleActive) {
            this.rippleContainer = this.renderer.createElement("span");
            this.cssContainerClasses.forEach((cssClass) => {
                this.renderer.addClass(this.rippleContainer, cssClass);
            });
            const rippleElement = this.renderer.createElement("span");
            this.renderer.addClass(rippleElement, RIPPLE);
            this.rippleContainer.appendChild(rippleElement);
            this.el.appendChild(this.rippleContainer);
            this.ripple = new MaterialRipple(this.renderer, this.el);
        }
    }
}
MdlRippleDirective.decorators = [
    { type: Directive }
];
MdlRippleDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: Array }
];
class MdlButtonRippleDirective extends MdlRippleDirective {
    constructor(elementRef, renderer) {
        super(elementRef, renderer, ["mdl-button__ripple-container"]);
        // eslint-disable-next-line
        this.rippleActive = true;
    }
}
MdlButtonRippleDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: 'mdl-button[mdl-ripple], button[mdl-ripple]'
            },] }
];
MdlButtonRippleDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
MdlButtonRippleDirective.propDecorators = {
    rippleActive: [{ type: Input, args: ['mdl-ripple',] }]
};
class MdlCheckboxRippleDirective extends MdlRippleDirective {
    constructor(elementRef, renderer) {
        super(elementRef, renderer, [
            "mdl-checkbox__ripple-container",
            "mdl-ripple--center",
        ]);
        // eslint-disable-next-line
        this.rippleActive = true;
    }
}
MdlCheckboxRippleDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: 'mdl-checkbox[mdl-ripple]'
            },] }
];
MdlCheckboxRippleDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
MdlCheckboxRippleDirective.propDecorators = {
    rippleActive: [{ type: Input, args: ['mdl-ripple',] }]
};
class MdlRadioRippleDirective extends MdlRippleDirective {
    constructor(elementRef, renderer) {
        super(elementRef, renderer, [
            "mdl-radio__ripple-container",
            "mdl-ripple--center",
        ]);
        // eslint-disable-next-line
        this.rippleActive = true;
    }
}
MdlRadioRippleDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: 'mdl-radio[mdl-ripple]'
            },] }
];
MdlRadioRippleDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
MdlRadioRippleDirective.propDecorators = {
    rippleActive: [{ type: Input, args: ['mdl-ripple',] }]
};
class MdlIconToggleRippleDirective extends MdlRippleDirective {
    constructor(elementRef, renderer) {
        super(elementRef, renderer, [
            "mdl-icon-toggle__ripple-container",
            "mdl-ripple--center",
        ]);
        // eslint-disable-next-line
        this.rippleActive = true;
    }
}
MdlIconToggleRippleDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: 'mdl-icon-toggle[mdl-ripple]'
            },] }
];
MdlIconToggleRippleDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
MdlIconToggleRippleDirective.propDecorators = {
    rippleActive: [{ type: Input, args: ['mdl-ripple',] }]
};
class MdlSwitchRippleDirective extends MdlRippleDirective {
    constructor(elementRef, renderer) {
        super(elementRef, renderer, [
            "mdl-switch__ripple-container",
            "mdl-ripple--center",
        ]);
        // eslint-disable-next-line
        this.rippleActive = true;
    }
}
MdlSwitchRippleDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: 'mdl-switch[mdl-ripple]'
            },] }
];
MdlSwitchRippleDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
MdlSwitchRippleDirective.propDecorators = {
    rippleActive: [{ type: Input, args: ['mdl-ripple',] }]
};
class MdlMenuItemRippleDirective extends MdlRippleDirective {
    constructor(elementRef, renderer) {
        super(elementRef, renderer, ["mdl-menu__item--ripple-container"]);
        // eslint-disable-next-line
        this.rippleActive = true;
    }
}
MdlMenuItemRippleDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: 'mdl-menu-item[mdl-ripple]'
            },] }
];
MdlMenuItemRippleDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
MdlMenuItemRippleDirective.propDecorators = {
    rippleActive: [{ type: Input, args: ['mdl-ripple',] }]
};
class MdlAnchorRippleDirective extends MdlRippleDirective {
    constructor(elementRef, renderer) {
        super(elementRef, renderer, [
            "mdl-tabs__ripple-container",
            "mdl-layout__tab-ripple-container",
        ]);
        // eslint-disable-next-line
        this.rippleActive = true;
    }
}
MdlAnchorRippleDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: 'a[mdl-ripple],div[mdl-ripple]'
            },] }
];
MdlAnchorRippleDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
MdlAnchorRippleDirective.propDecorators = {
    rippleActive: [{ type: Input, args: ['mdl-ripple',] }]
};

const MDL_RIPPLE_DIRECTIVES = [
    MdlCheckboxRippleDirective,
    MdlButtonRippleDirective,
    MdlRadioRippleDirective,
    MdlIconToggleRippleDirective,
    MdlSwitchRippleDirective,
    MdlMenuItemRippleDirective,
    MdlAnchorRippleDirective,
];
class MdlRippleModule {
    static forRoot() {
        return {
            ngModule: MdlRippleModule,
            providers: [],
        };
    }
}
MdlRippleModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                exports: MDL_RIPPLE_DIRECTIVES,
                declarations: MDL_RIPPLE_DIRECTIVES,
            },] }
];

const MDL_TABS_DIRECTIVES = [
    MdlTabsComponent,
    MdlTabPanelComponent,
    MdlTabPanelTitleComponent,
    MdlTabPanelContentComponent,
];
class MdlTabsModule {
    static forRoot() {
        return {
            ngModule: MdlTabsModule,
            providers: [],
        };
    }
}
MdlTabsModule.decorators = [
    { type: NgModule, args: [{
                imports: [MdlCommonsModule, MdlRippleModule, CommonModule, MdlRippleModule],
                exports: MDL_TABS_DIRECTIVES,
                declarations: [...MDL_TABS_DIRECTIVES],
            },] }
];

const MDL_LAYOUT_DIRECTIVES = [
    MdlLayoutComponent,
    MdlLayoutHeaderComponent,
    MdlLayoutDrawerComponent,
    MdlLayoutContentComponent,
    MdlLayoutHeaderTransparentDirective,
    MdlLayoutHeaderRowComponent,
    MdlLayoutTitleComponent,
    MdlLayoutSpacerComponent,
    MdlLayoutTabPanelComponent,
];
class MdlLayoutModule {
    static forRoot() {
        return {
            ngModule: MdlLayoutModule,
            providers: [MdlScreenSizeService],
        };
    }
}
MdlLayoutModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    MdlIconModule,
                    MdlCommonsModule,
                    MdlRippleModule,
                    MdlTabsModule,
                    CommonModule,
                ],
                exports: MDL_LAYOUT_DIRECTIVES,
                declarations: MDL_LAYOUT_DIRECTIVES,
            },] }
];

const DATA_BADE_ATTR = "data-badge";
class MdlBadgeDirective {
    constructor(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.isBadge = true;
        this.el = elementRef.nativeElement;
    }
    ngOnChanges() {
        if (this.mdlBadgeContent === null ||
            typeof this.mdlBadgeContent === "undefined") {
            this.renderer.removeAttribute(this.el, DATA_BADE_ATTR);
            return;
        }
        this.renderer.setAttribute(this.el, DATA_BADE_ATTR, this.mdlBadgeContent);
    }
}
MdlBadgeDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: '[mdl-badge]'
            },] }
];
MdlBadgeDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
MdlBadgeDirective.propDecorators = {
    mdlBadgeContent: [{ type: Input, args: ["mdl-badge",] }],
    isBadge: [{ type: HostBinding, args: ["class.mdl-badge",] }]
};
class MdlBadgeOverlapDirective {
    constructor() {
        this.isOverlapping = true;
    }
}
MdlBadgeOverlapDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: '[mdl-badge-overlap]'
            },] }
];
MdlBadgeOverlapDirective.propDecorators = {
    isOverlapping: [{ type: HostBinding, args: ["class.mdl-badge--overlap",] }]
};
class MdlBadgeNoBackgroundDirective {
    constructor() {
        this.isNoBackground = true;
    }
}
MdlBadgeNoBackgroundDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: '[mdl-badge-no-background]'
            },] }
];
MdlBadgeNoBackgroundDirective.propDecorators = {
    isNoBackground: [{ type: HostBinding, args: ["class.mdl-badge--no-background",] }]
};

const MDL_BADGE_DIRECTIVES = [
    MdlBadgeDirective,
    MdlBadgeOverlapDirective,
    MdlBadgeNoBackgroundDirective,
];
class MdlBadgeModule {
    static forRoot() {
        return {
            ngModule: MdlBadgeModule,
            providers: [],
        };
    }
}
MdlBadgeModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                exports: MDL_BADGE_DIRECTIVES,
                declarations: MDL_BADGE_DIRECTIVES,
            },] }
];

class MdlUnsupportedButtonTypeError extends MdlError {
    constructor(type) {
        /* istanbul ignore next */
        super(`Button type "${type}" isn't supported (allowed: raised, fab, mini-fab, icon, '').`);
    }
}
class MdlUnsupportedColoredTypeError extends MdlError {
    constructor(type) {
        /* istanbul ignore next */
        super(`Colored type "${type}" isn't supported (allowed: primary, accent, '').`);
    }
}
const MDL_BUTTON_TYPES = ["raised", "fab", "mini-fab", "icon", ""];
const MDL_COLORED_TYPES = ["primary", "accent", ""];
class MdlButtonComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isButton = true;
        this.disabledIntern = false;
        this.element = elementRef.nativeElement;
    }
    get isDisable() {
        return this.disabled ? "disabled" : null;
    }
    get raised() {
        return this.mdlButtonType === "raised";
    }
    get fab() {
        return this.mdlButtonType === "fab" || this.mdlButtonType === "mini-fab";
    }
    get miniFab() {
        return this.mdlButtonType === "mini-fab";
    }
    get icon() {
        return this.mdlButtonType === "icon";
    }
    get primary() {
        return this.mdlColoredType === "primary";
    }
    get accent() {
        return this.mdlColoredType === "accent";
    }
    get disabled() {
        return this.disabledIntern;
    }
    set disabled(value) {
        this.disabledIntern = toBoolean(value);
    }
    onMouseUp() {
        this.blurIt();
    }
    onMouseLeave() {
        this.blurIt();
    }
    ngOnChanges() {
        if (this.mdlButtonType &&
            MDL_BUTTON_TYPES.indexOf(this.mdlButtonType) === -1) {
            throw new MdlUnsupportedButtonTypeError(this.mdlButtonType);
        }
        if (this.mdlColoredType &&
            MDL_COLORED_TYPES.indexOf(this.mdlColoredType) === -1) {
            throw new MdlUnsupportedColoredTypeError(this.mdlColoredType);
        }
    }
    blurIt() {
        callNative(this.element, "blur");
    }
}
MdlButtonComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-button, button[mdl-button], a[mdl-button]",
                exportAs: "mdlButton",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlButtonComponent.ctorParameters = () => [
    { type: ElementRef }
];
MdlButtonComponent.propDecorators = {
    isButton: [{ type: HostBinding, args: ["class.mdl-button",] }],
    mdlButtonType: [{ type: Input, args: ["mdl-button-type",] }],
    mdlColoredType: [{ type: Input, args: ["mdl-colored",] }],
    isDisable: [{ type: HostBinding, args: ["attr.disabled",] }],
    raised: [{ type: HostBinding, args: ["class.mdl-button--raised",] }],
    fab: [{ type: HostBinding, args: ["class.mdl-button--fab",] }],
    miniFab: [{ type: HostBinding, args: ["class.mdl-button--mini-fab",] }],
    icon: [{ type: HostBinding, args: ["class.mdl-button--icon",] }],
    primary: [{ type: HostBinding, args: ["class.mdl-button--primary",] }],
    accent: [{ type: HostBinding, args: ["class.mdl-button--accent",] }],
    disabled: [{ type: Input }],
    onMouseUp: [{ type: HostListener, args: ["mouseup",] }],
    onMouseLeave: [{ type: HostListener, args: ["mouseleave",] }]
};

const MDL_BUTTON_DIRECTIVES = [MdlButtonComponent];
class MdlButtonModule {
    static forRoot() {
        return {
            ngModule: MdlButtonModule,
            providers: [],
        };
    }
}
MdlButtonModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                exports: MDL_BUTTON_DIRECTIVES,
                declarations: MDL_BUTTON_DIRECTIVES,
            },] }
];

class MdlCardComponent {
    constructor() {
        this.isCard = true;
    }
}
MdlCardComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-card",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlCardComponent.propDecorators = {
    isCard: [{ type: HostBinding, args: ["class.mdl-card",] }]
};
// eslint-disable-next-line @angular-eslint/directive-class-suffix
class MdlCardChildStructure {
    constructor(mdlCardComponent, childComponentName) {
        this.mdlCardComponent = mdlCardComponent;
        this.childComponentName = childComponentName;
    }
    ngOnInit() {
        if (this.mdlCardComponent === null) {
            throw new MdlStructureError(this.childComponentName, "mdl-card");
        }
    }
}
MdlCardChildStructure.decorators = [
    { type: Directive }
];
MdlCardChildStructure.ctorParameters = () => [
    { type: MdlCardComponent },
    { type: String }
];
class MdlCardTitleComponent extends MdlCardChildStructure {
    constructor(mdlCardComponent) {
        super(mdlCardComponent, "mdl-card-title");
        this.isCardTitle = true;
    }
}
MdlCardTitleComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-card-title",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlCardTitleComponent.ctorParameters = () => [
    { type: MdlCardComponent, decorators: [{ type: Optional }] }
];
MdlCardTitleComponent.propDecorators = {
    isCardTitle: [{ type: HostBinding, args: ["class.mdl-card__title",] }]
};
class MdlCardSupportingTextComponent extends MdlCardChildStructure {
    constructor(mdlCardComponent) {
        super(mdlCardComponent, "mdl-card-supporting-text");
        this.isSupportingText = true;
    }
}
MdlCardSupportingTextComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-card-supporting-text",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlCardSupportingTextComponent.ctorParameters = () => [
    { type: MdlCardComponent, decorators: [{ type: Optional }] }
];
MdlCardSupportingTextComponent.propDecorators = {
    isSupportingText: [{ type: HostBinding, args: ["class.mdl-card__supporting-text",] }]
};
class MdlCardMediaComponent extends MdlCardChildStructure {
    constructor(mdlCardComponent) {
        super(mdlCardComponent, "mdl-card-media");
        this.isCardMedia = true;
    }
}
MdlCardMediaComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-card-media",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlCardMediaComponent.ctorParameters = () => [
    { type: MdlCardComponent, decorators: [{ type: Optional }] }
];
MdlCardMediaComponent.propDecorators = {
    isCardMedia: [{ type: HostBinding, args: ["class.mdl-card__media",] }]
};
class MdlCardActionsComponent extends MdlCardChildStructure {
    constructor(mdlCardComponent) {
        super(mdlCardComponent, "mdl-card-actions");
        this.isCardAction = true;
    }
}
MdlCardActionsComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-card-actions",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlCardActionsComponent.ctorParameters = () => [
    { type: MdlCardComponent, decorators: [{ type: Optional }] }
];
MdlCardActionsComponent.propDecorators = {
    isCardAction: [{ type: HostBinding, args: ["class.mdl-card__actions",] }]
};
class MdlCardMenuComponent extends MdlCardChildStructure {
    constructor(mdlCardComponent) {
        super(mdlCardComponent, "mdl-card-menu");
        this.isCardMenu = true;
    }
}
MdlCardMenuComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-card-menu",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlCardMenuComponent.ctorParameters = () => [
    { type: MdlCardComponent, decorators: [{ type: Optional }] }
];
MdlCardMenuComponent.propDecorators = {
    isCardMenu: [{ type: HostBinding, args: ["class.mdl-card__menu",] }]
};
class MdlCardTitleTextDirective {
    constructor() {
        this.isCardTitleText = true;
    }
}
MdlCardTitleTextDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: '[mdl-card-title-text]'
            },] }
];
MdlCardTitleTextDirective.propDecorators = {
    isCardTitleText: [{ type: HostBinding, args: ["class.mdl-card__title-text",] }]
};
class MdlCardBorderDirective {
    constructor() {
        this.isCardBorder = true;
    }
}
MdlCardBorderDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: '[mdl-card-border]'
            },] }
];
MdlCardBorderDirective.propDecorators = {
    isCardBorder: [{ type: HostBinding, args: ["class.mdl-card--border",] }]
};
class MdlCardExpandDirective {
    constructor() {
        this.isCardExpand = true;
    }
}
MdlCardExpandDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: '[mdl-card-expand]'
            },] }
];
MdlCardExpandDirective.propDecorators = {
    isCardExpand: [{ type: HostBinding, args: ["class.mdl-card--expand",] }]
};

const MDL_CARD_DIRECTIVES = [
    MdlCardComponent,
    MdlCardTitleComponent,
    MdlCardMediaComponent,
    MdlCardSupportingTextComponent,
    MdlCardActionsComponent,
    MdlCardMenuComponent,
    MdlCardTitleTextDirective,
    MdlCardBorderDirective,
    MdlCardExpandDirective,
];
class MdlCardModule {
    static forRoot() {
        return {
            ngModule: MdlCardModule,
            providers: [],
        };
    }
}
MdlCardModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                exports: MDL_CARD_DIRECTIVES,
                declarations: MDL_CARD_DIRECTIVES,
            },] }
];

const IS_FOCUSED$2 = "is-focused";
const CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => MdlCheckboxComponent),
    multi: true,
};
class MdlCheckboxComponent {
    constructor(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.tabindex = null;
        // eslint-disable-next-line
        this.change = new EventEmitter();
        this.isCheckbox = true;
        this.isUpgraded = true;
        this.onTouchedCallback = noop;
        this.onChangeCallback = noop;
        this.internalValue = false;
        this.internalDisabled = false;
        this.el = elementRef.nativeElement;
    }
    get value() {
        return this.internalValue;
    }
    set value(v) {
        this.internalValue = v;
        this.onChangeCallback(v);
        this.change.emit(v);
    }
    get disabled() {
        return this.internalDisabled;
    }
    set disabled(value) {
        this.internalDisabled = toBoolean(value);
    }
    onClick() {
        if (this.disabled) {
            return;
        }
        this.value = !this.value;
    }
    writeValue(value) {
        this.internalValue = value;
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    onFocus() {
        this.renderer.addClass(this.el, IS_FOCUSED$2);
    }
    onBlur() {
        this.renderer.removeClass(this.el, IS_FOCUSED$2);
        this.onTouchedCallback();
    }
}
MdlCheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-checkbox",
                providers: [CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR],
                template: `
    <input
      type="checkbox"
      class="mdl-checkbox__input"
      (focus)="onFocus()"
      (blur)="onBlur()"
      [disabled]="disabled"
      [attr.tabindex]="tabindex"
      [ngModel]="value"
    />
    <span class="mdl-checkbox__label"><ng-content></ng-content></span>
    <span class="mdl-checkbox__focus-helper"></span>
    <span class="mdl-checkbox__box-outline">
      <span class="mdl-checkbox__tick-outline"></span>
    </span>
  `,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
MdlCheckboxComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
MdlCheckboxComponent.propDecorators = {
    tabindex: [{ type: Input }],
    change: [{ type: Output }],
    isCheckbox: [{ type: HostBinding, args: ["class.mdl-checkbox",] }],
    isUpgraded: [{ type: HostBinding, args: ["class.is-upgraded",] }],
    value: [{ type: Input }, { type: HostBinding, args: ["class.is-checked",] }],
    disabled: [{ type: Input }, { type: HostBinding, args: ["class.is-disabled",] }],
    onClick: [{ type: HostListener, args: ["click",] }]
};

const MDL_CHECKBOX_DIRECTIVES = [MdlCheckboxComponent];
class MdlCheckboxModule {
    static forRoot() {
        return {
            ngModule: MdlCheckboxModule,
            providers: [],
        };
    }
}
MdlCheckboxModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule],
                exports: MDL_CHECKBOX_DIRECTIVES,
                declarations: MDL_CHECKBOX_DIRECTIVES,
            },] }
];

class MdlChipComponent {
    constructor() {
        // eslint-disable-next-line
        this.actionClick = new EventEmitter();
        this.isChip = true;
        this.isChipContact = false;
    }
    action() {
        this.actionClick.emit();
    }
}
MdlChipComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-chip",
                template: `
    <ng-content></ng-content>
    <span *ngIf="mdlLabel" class="mdl-chip__text">{{ mdlLabel }}</span>
    <button
      *ngIf="mdlActionIcon"
      (click)="action()"
      type="button"
      class="mdl-chip__action"
    >
      <mdl-icon>{{ mdlActionIcon }}</mdl-icon>
    </button>
  `,
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlChipComponent.propDecorators = {
    mdlLabel: [{ type: Input, args: ['mdl-label',] }],
    mdlActionIcon: [{ type: Input, args: ['mdl-action-icon',] }],
    actionClick: [{ type: Output, args: ['action-click',] }],
    isChip: [{ type: HostBinding, args: ["class.mdl-chip",] }],
    isChipContact: [{ type: HostBinding, args: ["class.mdl-chip--contact",] }]
};

class MdlChipContactDirective {
    constructor(mdlChipComponent) {
        this.mdlChipComponent = mdlChipComponent;
        this.isChipContact = true;
    }
    ngOnInit() {
        if (!this.mdlChipComponent) {
            throw new MdlStructureError("mdl-chip-contact", "mdl-chip");
        }
        this.mdlChipComponent.isChipContact = true;
    }
}
MdlChipContactDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: '[mdl-chip-contact]'
            },] }
];
MdlChipContactDirective.ctorParameters = () => [
    { type: MdlChipComponent, decorators: [{ type: Optional }, { type: Inject, args: [MdlChipComponent,] }] }
];
MdlChipContactDirective.propDecorators = {
    isChipContact: [{ type: HostBinding, args: ["class.mdl-chip__contact",] }]
};

const DIRECTIVES = [MdlChipComponent, MdlChipContactDirective];
class MdlChipModule {
    static forRoot() {
        return {
            ngModule: MdlChipModule,
            providers: [],
        };
    }
}
MdlChipModule.decorators = [
    { type: NgModule, args: [{
                imports: [MdlIconModule, CommonModule],
                exports: DIRECTIVES,
                declarations: DIRECTIVES,
            },] }
];

const MDL_CONFIGUARTION = new InjectionToken("MDL_CONFIGUARTION");
const MIN_DIALOG_Z_INDEX = 100000;

/**
 * The reference to the created and displayed dialog.
 */
class MdlDialogReference {
    constructor(internaleRef) {
        this.internaleRef = internaleRef;
        internaleRef.dialogRef = this;
    }
    /**
     * closes the dialog
     */
    hide(data) {
        this.internaleRef.hide(data);
    }
    /**
     * Observable that emits, if the dialog was closed.
     * returns {Observable<void>}
     */
    onHide() {
        return this.internaleRef.onHide();
    }
    /**
     * Observable that emits, if the dialog is really visible and not only created.
     * returns {Observable<void>}
     */
    onVisible() {
        return this.internaleRef.onVisible();
    }
}

class MdlSimpleDialogComponent {
    // why do i need forwardRef at this point, the demo LoginDialog dosn't need this!?!?
    constructor(dialogConfiguration, dialog) {
        this.dialogConfiguration = dialogConfiguration;
        this.dialog = dialog;
        this.dialog = dialog;
        dialog.onVisible().subscribe(() => {
            if (this.buttons) {
                this.buttons.first.elementRef.nativeElement.focus();
            }
        });
    }
    onEsc() {
        // run the first action that is marked as closing action
        const closeAction = this.dialogConfiguration.actions.find((action) => action.isClosingAction);
        if (closeAction) {
            closeAction.handler();
            this.dialog.hide();
        }
    }
    actionClicked(action) {
        action.handler();
        this.dialog.hide();
    }
}
MdlSimpleDialogComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-dialog-component",
                template: `
    <h3 class="mdl-dialog__title" *ngIf="dialogConfiguration?.title">
      {{ dialogConfiguration?.title }}
    </h3>
    <div
      class="mdl-dialog__content"
      [innerHTML]="dialogConfiguration?.message"
    ></div>
    <div
      class="mdl-dialog__actions"
      [ngClass]="{
        'mdl-dialog__actions--full-width': dialogConfiguration?.fullWidthAction
      }"
    >
      <button
        mdl-button
        mdl-colored="primary"
        type="button"
        *ngFor="let action of dialogConfiguration?.actions"
        (click)="actionClicked(action)"
        [ngClass]="{ close: action.isClosingAction }"
      >
        {{ action.text }}
      </button>
    </div>
  `,
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlSimpleDialogComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [forwardRef(() => MDL_CONFIGUARTION),] }] },
    { type: MdlDialogReference, decorators: [{ type: Inject, args: [forwardRef(() => MdlDialogReference),] }] }
];
MdlSimpleDialogComponent.propDecorators = {
    buttons: [{ type: ViewChildren, args: [MdlButtonComponent,] }],
    onEsc: [{ type: HostListener, args: ["keydown.esc",] }]
};

/**
 * Internal representation of the dialog ref. the service
 * user should not have access to the created components
 * and internal implementations.
 */
class InternalMdlDialogReference {
    constructor(config) {
        this.config = config;
        this.isModal = false;
        this.onHideSubject = new Subject();
        this.onVisibleSubject = new Subject();
        this.dialogRef = new MdlDialogReference(this);
    }
    get hostDialog() {
        return this.hostDialogComponentRef.instance;
    }
    hide(data) {
        this.onHideSubject.next(data);
        this.onHideSubject.complete();
        this.closeCallback();
    }
    visible() {
        this.onVisibleSubject.next();
        this.onVisibleSubject.complete();
    }
    onHide() {
        return this.onHideSubject.asObservable();
    }
    onVisible() {
        return this.onVisibleSubject.asObservable();
    }
}

const enterTransitionDuration = 300;
const leaveTransitionDuration = 250;
const enterTransitionEasingCurve = "cubic-bezier(0.0, 0.0, 0.2, 1)";
const leaveTransitionEasingCurve = "cubic-bezier(0.0, 0.0, 0.2, 1)";
const createOpenCloseRect = (rect) => ({
    height: rect.top - rect.bottom,
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
});
const ɵ0$1 = createOpenCloseRect;
const getCenterInScreen = (rect) => ({
    cx: Math.round(rect.left + rect.width / 2),
    cy: Math.round(rect.top + rect.height / 2),
});
const ɵ1 = getCenterInScreen;
const getClientRect = (input) => {
    if (input instanceof MdlButtonComponent) {
        const elRef = input.elementRef;
        const rect = elRef.nativeElement.getBoundingClientRect();
        return createOpenCloseRect(rect);
    }
    else if (input instanceof MouseEvent) {
        const evt = input;
        // just to make it possible to test this code with a fake event - target is
        // readonly and con not be mutated.
        // eslint-disable-next-line
        const htmlElement = (evt.target || evt.testtarget);
        const rect = htmlElement.getBoundingClientRect();
        return createOpenCloseRect(rect);
    }
    return input;
};
const ɵ2 = getClientRect;
// @experimental
class MdlDialogHostComponent {
    constructor(ngZone, renderer, animations, elementRef, config, internalDialogRef) {
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.animations = animations;
        this.elementRef = elementRef;
        this.config = config;
        this.internalDialogRef = internalDialogRef;
        this.isDialog = true;
        this.visible = false;
        this.zIndex = MIN_DIALOG_Z_INDEX + 1;
        this.showAnimationStartStyle = {
            top: "38%",
            opacity: "0",
        };
        this.showStyle = {
            top: "50%",
            opacity: "1",
        };
        this.hideAnimationEndStyle = {
            top: "63%",
            opacity: "0",
        };
    }
    show() {
        this.visible = true;
        // give the dialogs time to draw so that a focus can be set
        setTimeout(() => {
            this.internalDialogRef.visible();
        });
        if (this.isAnimateEnabled()) {
            if (this.config.openFrom || this.config.closeTo) {
                // transform is modified during anmiation and must be part of each animation keyframe.
                this.showStyle.transform = "translate(0, -50%) scale(1.0)";
                const targetClientRect = this.elementRef.nativeElement.getBoundingClientRect();
                const openFromRect = getClientRect(this.config.openFrom);
                const closeToRect = this.config.closeTo
                    ? getClientRect(this.config.closeTo)
                    : openFromRect;
                const centerTarget = getCenterInScreen(targetClientRect);
                const centerFrom = getCenterInScreen(openFromRect);
                const centerTo = getCenterInScreen(closeToRect);
                const translationFrom = {
                    x: Math.round(centerFrom.cx - centerTarget.cx),
                    y: Math.round(centerFrom.cy - centerTarget.cy),
                    scaleX: Math.round(100 * Math.min(0.25, openFromRect.width / targetClientRect.width)) / 100,
                    scaleY: Math.round(100 *
                        Math.min(0.25, openFromRect.height / targetClientRect.height)) / 100,
                };
                this.showAnimationStartStyle = {
                    top: `${targetClientRect.top}px`,
                    opacity: "0",
                    transform: `translate(${translationFrom.x}px, ${translationFrom.y}px) scale(${translationFrom.scaleX}, ${translationFrom.scaleY})`,
                };
                const translationTo = {
                    x: Math.round(centerTo.cx - centerTarget.cx),
                    y: Math.round(centerTo.cy - centerTarget.cy),
                    scaleX: Math.round(100 * Math.min(0.25, closeToRect.width / targetClientRect.width)) / 100,
                    scaleY: Math.round(100 * Math.min(0.25, closeToRect.height / targetClientRect.height)) / 100,
                };
                this.hideAnimationEndStyle = {
                    top: `${targetClientRect.top}px`,
                    opacity: "0",
                    transform: `translate(${translationTo.x}px, ${translationTo.y}px) scale(${translationTo.scaleX}, ${translationTo.scaleY})`,
                };
            }
            const animation = this.animations.animate(this.elementRef.nativeElement, [this.showAnimationStartStyle, this.showStyle], this.config.enterTransitionDuration || enterTransitionDuration, this.config.enterTransitionEasingCurve || enterTransitionEasingCurve);
            animation.play();
        }
    }
    hide(selfComponentRef) {
        if (this.isAnimateEnabled()) {
            const animation = this.animations.animate(this.elementRef.nativeElement, [this.showStyle, this.hideAnimationEndStyle], this.config.leaveTransitionDuration || leaveTransitionDuration, this.config.leaveTransitionEasingCurve || leaveTransitionEasingCurve);
            animation.onDone(() => {
                selfComponentRef.destroy();
            });
            animation.play();
        }
        else {
            selfComponentRef.destroy();
        }
    }
    ngOnInit() {
        this.applyStyle(this.config.styles);
        this.applyClasses(this.config.classes ? this.config.classes : "");
    }
    applyStyle(styles) {
        if (styles) {
            for (const style of Object.keys(styles)) {
                this.renderer.setStyle(this.elementRef.nativeElement, style, styles[style]);
            }
        }
    }
    applyClasses(classes) {
        classes
            .split(" ")
            .filter((cssClass) => !!cssClass)
            .forEach((cssClass) => {
            this.renderer.addClass(this.elementRef.nativeElement, cssClass);
        });
    }
    isAnimateEnabled() {
        // not present?  assume it is true.
        if (typeof this.config.animate === "undefined") {
            return true;
        }
        return this.config.animate;
    }
}
MdlDialogHostComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-dialog-host-component",
                template: ` <div #dialogTarget></div>`,
                encapsulation: ViewEncapsulation.None,
                styles: [`
      mdl-dialog-host-component {
        width: fit-content;
        height: fit-content;
        padding: 1em;
        background: white;
        color: black;
        opacity: 1;
        visibility: hidden;
        display: block;
        position: fixed;
        margin: auto;
        left: 0;
        right: 0;
        transition: all;
        top: 50%;
        transform: translate(0, -50%);
      }

      mdl-dialog-host-component.open {
        visibility: visible;
      }
    `]
            },] }
];
MdlDialogHostComponent.ctorParameters = () => [
    { type: NgZone },
    { type: Renderer2 },
    { type: Animations },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [forwardRef(() => MDL_CONFIGUARTION),] }] },
    { type: InternalMdlDialogReference }
];
MdlDialogHostComponent.propDecorators = {
    dialogTarget: [{ type: ViewChild, args: ["dialogTarget", { read: ViewContainerRef, static: true },] }],
    isDialog: [{ type: HostBinding, args: ["class.mdl-dialog",] }],
    visible: [{ type: HostBinding, args: ["class.open",] }],
    zIndex: [{ type: HostBinding, args: ["style.zIndex",] }]
};

class MdlBackdropOverlayComponent {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.zIndex = 0;
        this.isBackdrop = true;
        this.clickEmitter = new EventEmitter();
        this.visible = false;
    }
    get display() {
        return this.visible ? null : "none";
    }
    onBackdropClick(e) {
        // this event runs not in angular zone of the main app. make sure it runs in the main angular zone
        // and change detection works
        this.ngZone.run(() => {
            this.clickEmitter.emit();
        });
        e.stopPropagation();
    }
    hide() {
        this.visible = false;
    }
    showWithZIndex(zIndex) {
        this.zIndex = zIndex;
        this.visible = true;
    }
}
MdlBackdropOverlayComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-backdrop-overlay",
                template: ``,
                encapsulation: ViewEncapsulation.None,
                styles: [`
      .dialog-backdrop {
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background: rgba(0, 0, 0, 0.1);
      }
    `]
            },] }
];
MdlBackdropOverlayComponent.ctorParameters = () => [
    { type: NgZone }
];
MdlBackdropOverlayComponent.propDecorators = {
    zIndex: [{ type: HostBinding, args: ["style.zIndex",] }],
    isBackdrop: [{ type: HostBinding, args: ["class.dialog-backdrop",] }],
    display: [{ type: HostBinding, args: ["style.display",] }],
    onBackdropClick: [{ type: HostListener, args: ["click", ["$event"],] }]
};

// the componnet is used outside the app-root. injecting MdlDialogService would not work
// this component is not exported - needs to be instanciated by
//    let x = this.appRef.bootstrap(MdlDialogOutletComponent);
class MdlDialogOutletComponent {
    constructor(vCRef) {
        this.vCRef = vCRef;
    }
    get viewContainerRef() {
        return this.vCRef;
    }
}
MdlDialogOutletComponent.decorators = [
    { type: Component, args: [{
                // eslint-disable-next-line
                selector: 'dialog-outlet',
                template: ""
            },] }
];
MdlDialogOutletComponent.ctorParameters = () => [
    { type: ViewContainerRef }
];

class MdlDialogOutletService {
    constructor(appRef, componentFactoryResolver) {
        this.appRef = appRef;
        this.componentFactoryResolver = componentFactoryResolver;
        this.backdropClickEmitter = new EventEmitter();
        this.viewContainerRefInternal = null;
        let dialogOutletCompRef = null;
        appRef.isStable
            .pipe(take(1), filter(() => this.viewContainerRefInternal == null))
            .subscribe(() => {
            try {
                dialogOutletCompRef = this.appRef.bootstrap(MdlDialogOutletComponent);
            }
            catch (e) {
                // the user did not use the dialog.outlet element outside of his root app.
                // console.log(e);
            }
            if (dialogOutletCompRef) {
                this.setViewContainerRef(dialogOutletCompRef.instance.viewContainerRef);
            }
        });
    }
    get viewContainerRef() {
        return this.viewContainerRefInternal;
    }
    setDefaultViewContainerRef(vCRef) {
        this.setViewContainerRef(vCRef);
    }
    hideBackdrop() {
        this.backdropComponent.hide();
    }
    showBackdropWithZIndex(zIndex) {
        this.backdropComponent.showWithZIndex(zIndex);
    }
    setViewContainerRef(value) {
        this.viewContainerRefInternal = value;
        if (this.viewContainerRefInternal) {
            const cFactory = this.componentFactoryResolver.resolveComponentFactory(MdlBackdropOverlayComponent);
            this.backdropComponent = this.viewContainerRefInternal.createComponent(cFactory).instance;
            this.backdropComponent.clickEmitter.subscribe(() => {
                this.backdropClickEmitter.emit();
            });
        }
    }
}
MdlDialogOutletService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MdlDialogOutletService_Factory() { return new MdlDialogOutletService(i0.ɵɵinject(i0.ApplicationRef), i0.ɵɵinject(i0.ComponentFactoryResolver)); }, token: MdlDialogOutletService, providedIn: "root" });
MdlDialogOutletService.decorators = [
    { type: Injectable, args: [{
                providedIn: "root",
            },] }
];
MdlDialogOutletService.ctorParameters = () => [
    { type: ApplicationRef },
    { type: ComponentFactoryResolver }
];

/**
 * The MdlDialogService is used to open different kind of dialogs. SimpleDialogs and Custom Dialogs.
 *
 * @experimental
 */
class MdlDialogService {
    constructor(componentFactoryResolver, mdlDialogOutletService, injector) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.mdlDialogOutletService = mdlDialogOutletService;
        this.injector = injector;
        /**
         * Emits an event when either all modals are closed, or one gets opened.
         *
         * @returns A subscribable event emitter that provides a boolean indicating whether a modal is open or not.
         */
        this.onDialogsOpenChanged = new EventEmitter();
        this.openDialogs = new Array();
        this.mdlDialogOutletService.backdropClickEmitter.subscribe(() => {
            this.onBackdropClick();
        });
    }
    /**
     * Shows a dialog that is just an alert - e.g. with one button.
     *
     * @param alertMessage The message that should be displayed.
     * @param okText The text that the button should have
     * @param title The optional title of the dialog
     * returns An Observable that is called if the user hits the Ok button.
     */
    alert(alertMessage, okText = "Ok", title) {
        const result = new Subject();
        this.showDialog({
            title,
            message: alertMessage,
            actions: [
                {
                    handler: () => {
                        result.next(null);
                        result.complete();
                    },
                    text: okText,
                },
            ],
            isModal: true,
        });
        return result;
    }
    /**
     * Shows a dialog that is just a confirm message - e.g. with two button.
     *
     * @param question The question that should be displayed.
     * @param title The title that should be displayed on top of Question.
     * @param declineText The text for decline button. defaults to Cancel
     * @param confirmText The text for the confirm button . defaults to Ok
     * returns An Observable that is called if the user hits the Ok button.
     */
    confirm(question, declineText = "Cancel", confirmText = "Ok", title) {
        const result = new Subject();
        this.showDialog({
            title,
            message: question,
            actions: [
                {
                    handler: () => {
                        result.next(null);
                        result.complete();
                    },
                    text: confirmText,
                },
                {
                    handler: () => {
                        result.error(null);
                    },
                    text: declineText,
                    isClosingAction: true,
                },
            ],
            isModal: true,
        });
        return result.asObservable();
    }
    /**
     * Shows a dialog that is specified by the provided configuration.
     *
     * @param config The simple dialog configuration.
     * returns An Observable that returns the MdlDialogReference.
     */
    showDialog(config) {
        if (config.actions.length === 0) {
            throw new Error("a dialog mus have at least one action");
        }
        const internalDialogRef = new InternalMdlDialogReference(config);
        const providers = [
            {
                provide: MdlDialogReference,
                useValue: new MdlDialogReference(internalDialogRef),
            },
            { provide: MDL_CONFIGUARTION, useValue: config },
        ];
        const hostComponentRef = this.createHostDialog(internalDialogRef, config);
        this.createComponentInstance(hostComponentRef.instance.dialogTarget, providers, MdlSimpleDialogComponent);
        return this.showHostDialog(internalDialogRef.dialogRef, hostComponentRef);
    }
    /**
     * Shows a dialog that is specified by the provided configuration.
     *
     * @param config The custom dialog configuration.
     * returns An Observable that returns the MdlDialogReference.
     */
    showCustomDialog(config) {
        const internalDialogRef = new InternalMdlDialogReference(config);
        const providers = [
            {
                provide: MdlDialogReference,
                useValue: new MdlDialogReference(internalDialogRef),
            },
        ];
        if (config.providers) {
            providers.push(...config.providers);
        }
        const hostComponentRef = this.createHostDialog(internalDialogRef, config);
        this.createComponentInstance(hostComponentRef.instance.dialogTarget, providers, config.component);
        return this.showHostDialog(internalDialogRef.dialogRef, hostComponentRef);
    }
    showDialogTemplate(template, config) {
        const internalDialogRef = new InternalMdlDialogReference(config);
        const hostComponentRef = this.createHostDialog(internalDialogRef, config);
        hostComponentRef.instance.dialogTarget.createEmbeddedView(template);
        return this.showHostDialog(internalDialogRef.dialogRef, hostComponentRef);
    }
    showHostDialog(dialogRef, hostComponentRef) {
        const result = new Subject();
        setTimeout(() => {
            result.next(dialogRef);
            result.complete();
            hostComponentRef.instance.show();
        });
        return result.asObservable();
    }
    createHostDialog(internalDialogRef, dialogConfig) {
        const viewContainerRef = this.mdlDialogOutletService.viewContainerRef;
        if (!viewContainerRef) {
            throw new Error("You did not provide a ViewContainerRef. " +
                "Please see https://github.com/mseemann/angular2-mdl/wiki/How-to-use-the-MdlDialogService");
        }
        const providers = [
            { provide: MDL_CONFIGUARTION, useValue: dialogConfig },
            { provide: InternalMdlDialogReference, useValue: internalDialogRef },
        ];
        const hostDialogComponent = this.createComponentInstance(viewContainerRef, providers, MdlDialogHostComponent);
        internalDialogRef.hostDialogComponentRef = hostDialogComponent;
        internalDialogRef.isModal = dialogConfig.isModal;
        internalDialogRef.closeCallback = () => {
            this.popDialog(internalDialogRef);
            hostDialogComponent.instance.hide(hostDialogComponent);
        };
        this.pushDialog(internalDialogRef);
        return hostDialogComponent;
    }
    pushDialog(dialogRef) {
        if (this.openDialogs.length === 0) {
            // first dialog being opened
            this.onDialogsOpenChanged.emit(true);
        }
        this.openDialogs.push(dialogRef);
        this.orderDialogStack();
    }
    popDialog(dialogRef) {
        this.openDialogs.splice(this.openDialogs.indexOf(dialogRef), 1);
        this.orderDialogStack();
        if (this.openDialogs.length === 0) {
            // last dialog being closed
            this.onDialogsOpenChanged.emit(false);
        }
    }
    orderDialogStack() {
        // +1 because the overlay may have MIN_DIALOG_Z_INDEX if the dialog is modal.
        let zIndex = MIN_DIALOG_Z_INDEX + 1;
        this.openDialogs.forEach((iDialogRef) => {
            iDialogRef.hostDialog.zIndex = zIndex;
            // +2 to make room for the overlay if a dialog is modal
            zIndex += 2;
        });
        this.mdlDialogOutletService.hideBackdrop();
        // if there is a modal dialog append the overloay to the dom - if not remove the overlay from the body
        const topMostModalDialog = this.getTopMostInternalDialogRef();
        if (topMostModalDialog) {
            // move the overlay diredct under the topmos modal dialog
            this.mdlDialogOutletService.showBackdropWithZIndex(topMostModalDialog.hostDialog.zIndex - 1);
        }
    }
    getTopMostInternalDialogRef() {
        let topMostModalDialog = null;
        for (let i = this.openDialogs.length - 1; i >= 0; i--) {
            if (this.openDialogs[i].isModal) {
                topMostModalDialog = this.openDialogs[i];
                break;
            }
        }
        return topMostModalDialog;
    }
    onBackdropClick() {
        const topMostModalDialog = this.getTopMostInternalDialogRef();
        if (topMostModalDialog.config.clickOutsideToClose) {
            topMostModalDialog.hide();
        }
    }
    createComponentInstance(viewContainerRef, providers, component) {
        const cFactory = this.componentFactoryResolver.resolveComponentFactory(component);
        const injector = Injector.create({
            providers: [
                ...providers,
                { provide: ViewContainerRef, useValue: viewContainerRef },
            ],
            parent: this.injector,
        });
        return viewContainerRef.createComponent(cFactory, viewContainerRef.length, injector);
    }
}
MdlDialogService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MdlDialogService_Factory() { return new MdlDialogService(i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(MdlDialogOutletService), i0.ɵɵinject(i0.INJECTOR)); }, token: MdlDialogService, providedIn: "root" });
MdlDialogService.decorators = [
    { type: Injectable, args: [{
                providedIn: "root",
            },] }
];
MdlDialogService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: MdlDialogOutletService },
    { type: Injector }
];

class MdlDialogComponent {
    constructor(dialogService) {
        this.dialogService = dialogService;
        // eslint-disable-next-line
        this.showEmitter = new EventEmitter();
        // eslint-disable-next-line
        this.hideEmitter = new EventEmitter();
        this.isShown = false;
        this.dialogRef = null;
    }
    show() {
        if (this.isShown) {
            throw new Error("Only one instance of an embedded mdl-dialog can exist!");
        }
        this.isShown = true;
        const mergedConfig = this.config || {};
        // default is true
        if (typeof mergedConfig.isModal === "undefined") {
            mergedConfig.isModal = true;
        }
        const result = new Subject();
        const p = this.dialogService.showDialogTemplate(this.template, mergedConfig);
        p.subscribe((dialogRef) => {
            this.dialogRef = dialogRef;
            this.dialogRef.onVisible().subscribe(() => {
                this.showEmitter.emit(dialogRef);
                result.next(dialogRef);
                result.complete();
            });
            this.dialogRef.onHide().subscribe(() => {
                this.hideEmitter.emit(null);
                this.dialogRef = null;
                this.isShown = false;
            });
        });
        return result.asObservable();
    }
    close() {
        if (this.dialogRef) {
            this.dialogRef.hide();
        }
    }
}
MdlDialogComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-dialog",
                template: `
    <div *dialogTemplate>
      <ng-content></ng-content>
    </div>
  `,
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlDialogComponent.ctorParameters = () => [
    { type: MdlDialogService }
];
MdlDialogComponent.propDecorators = {
    template: [{ type: ViewChild, args: [TemplateRef, { static: true },] }],
    config: [{ type: Input, args: ['mdl-dialog-config',] }],
    showEmitter: [{ type: Output, args: ['show',] }],
    hideEmitter: [{ type: Output, args: ['hide',] }]
};

class MdlAlertComponent {
    constructor(mdlDialogService) {
        this.mdlDialogService = mdlDialogService;
        this.display = "none";
        this.confirmed = new EventEmitter();
    }
    show() {
        this.mdlDialogService
            .alert(this.message, this.okText, this.title)
            .subscribe(() => {
            this.confirmed.emit();
        });
    }
}
MdlAlertComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-alert",
                template: ``,
                exportAs: "mdlAlert"
            },] }
];
MdlAlertComponent.ctorParameters = () => [
    { type: MdlDialogService }
];
MdlAlertComponent.propDecorators = {
    title: [{ type: Input }],
    message: [{ type: Input }],
    okText: [{ type: Input }],
    display: [{ type: HostBinding, args: ["style.display",] }],
    confirmed: [{ type: Output }]
};

// the component is used inside the app-root. this is possible because this component
class MdlDialogInnerOutletComponent {
    constructor(vCRef, service) {
        this.vCRef = vCRef;
        service.setDefaultViewContainerRef(vCRef);
    }
}
MdlDialogInnerOutletComponent.decorators = [
    { type: Component, args: [{
                // eslint-disable-next-line
                selector: 'dialog-outlet',
                template: ""
            },] }
];
MdlDialogInnerOutletComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: MdlDialogOutletService, decorators: [{ type: Inject, args: [forwardRef(() => MdlDialogOutletService),] }] }
];

const PUBLIC_COMPONENTS$1 = [MdlDialogInnerOutletComponent];
const PRIVATE_COMPONENTS$1 = [
    MdlDialogOutletComponent,
    MdlBackdropOverlayComponent,
];
class MdlDialogOutletModule {
    static forRoot() {
        return {
            ngModule: MdlDialogOutletModule,
            providers: [MdlDialogOutletService],
        };
    }
}
MdlDialogOutletModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                exports: PUBLIC_COMPONENTS$1,
                declarations: [...PUBLIC_COMPONENTS$1, ...PRIVATE_COMPONENTS$1],
                entryComponents: [MdlDialogOutletComponent, MdlBackdropOverlayComponent],
            },] }
];

const PUBLIC_COMPONENTS = [MdlDialogComponent, MdlAlertComponent];
const PRIVATE_COMPONENTS = [MdlDialogHostComponent, MdlSimpleDialogComponent];
class MdlDialogModule {
    static forRoot() {
        return {
            ngModule: MdlDialogModule,
            providers: [MdlDialogService, MdlDialogOutletService],
        };
    }
}
MdlDialogModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MdlCommonsModule,
                    MdlButtonModule,
                    MdlDialogOutletModule,
                ],
                exports: [...PUBLIC_COMPONENTS],
                declarations: [...PUBLIC_COMPONENTS, ...PRIVATE_COMPONENTS],
                entryComponents: [...PUBLIC_COMPONENTS, ...PRIVATE_COMPONENTS],
            },] }
];

class MdlIconToggleComponent extends MdlCheckboxComponent {
    constructor(elementRef, renderer) {
        super(elementRef, renderer);
        this.isIconToggle = true;
        this.isCheckbox = false;
    }
}
MdlIconToggleComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-icon-toggle",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => MdlIconToggleComponent),
                        multi: true,
                    },
                ],
                template: `
    <input
      type="checkbox"
      class="mdl-icon-toggle__input"
      (focus)="onFocus()"
      (blur)="onBlur()"
      [disabled]="disabled"
      [(ngModel)]="value"
    />
    <mdl-icon class="mdl-icon-toggle__label">
      <ng-content></ng-content>
    </mdl-icon>
  `,
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlIconToggleComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
MdlIconToggleComponent.propDecorators = {
    isIconToggle: [{ type: HostBinding, args: ["class.mdl-icon-toggle",] }]
};

const MDL_ICON_TOGGLE_DIRECTIVES = [MdlIconToggleComponent];
class MdlIconToggleModule {
    static forRoot() {
        return {
            ngModule: MdlIconToggleModule,
            providers: [],
        };
    }
}
MdlIconToggleModule.decorators = [
    { type: NgModule, args: [{
                imports: [MdlIconModule, CommonModule, FormsModule],
                exports: MDL_ICON_TOGGLE_DIRECTIVES,
                declarations: MDL_ICON_TOGGLE_DIRECTIVES,
            },] }
];

class MdlUnsupportedCountOfListItemLinesError extends MdlError {
    constructor(lines) {
        /* istanbul ignore next */
        super(`"${lines}" is not supported - max 3 lines please.`);
    }
}
class MdlListComponent {
    constructor() {
        this.isMdlList = true;
    }
}
MdlListComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-list",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlListComponent.propDecorators = {
    isMdlList: [{ type: HostBinding, args: ["class.mdl-list",] }]
};
class MdlListItemComponent {
    constructor() {
        this.isMdlListItem = true;
        this.linesIntern = 1;
    }
    get lines() {
        return this.linesIntern;
    }
    set lines(value) {
        this.linesIntern = toNumber(value);
    }
    get lines2() {
        return this.lines === 2;
    }
    get lines3() {
        return this.lines === 3;
    }
    ngOnChanges() {
        if (this.lines && this.lines > 3) {
            throw new MdlUnsupportedCountOfListItemLinesError(this.lines);
        }
    }
}
MdlListItemComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-list-item",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlListItemComponent.propDecorators = {
    isMdlListItem: [{ type: HostBinding, args: ["class.mdl-list__item",] }],
    lines: [{ type: Input }],
    lines2: [{ type: HostBinding, args: ["class.mdl-list__item--two-line",] }],
    lines3: [{ type: HostBinding, args: ["class.mdl-list__item--three-line",] }]
};
class MdlListItemPrimaryContentComponent {
    constructor(mdlListItemComponent) {
        this.mdlListItemComponent = mdlListItemComponent;
        this.isPrimaryContent = true;
    }
    ngOnInit() {
        if (this.mdlListItemComponent === null) {
            throw new MdlStructureError("mdl-list-item-primary-content", "mdl-list-item");
        }
    }
}
MdlListItemPrimaryContentComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-list-item-primary-content",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlListItemPrimaryContentComponent.ctorParameters = () => [
    { type: MdlListItemComponent, decorators: [{ type: Optional }] }
];
MdlListItemPrimaryContentComponent.propDecorators = {
    isPrimaryContent: [{ type: HostBinding, args: ["class.mdl-list__item-primary-content",] }]
};
class MdlListItemSecondaryContentComponent {
    constructor(mdlListItemComponent) {
        this.mdlListItemComponent = mdlListItemComponent;
        this.isSecondaryContent = true;
    }
    ngOnInit() {
        if (this.mdlListItemComponent === null) {
            throw new MdlStructureError("mdl-list-item-secondary-content", "mdl-list-item");
        }
    }
}
MdlListItemSecondaryContentComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-list-item-secondary-content",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlListItemSecondaryContentComponent.ctorParameters = () => [
    { type: MdlListItemComponent, decorators: [{ type: Optional }] }
];
MdlListItemSecondaryContentComponent.propDecorators = {
    isSecondaryContent: [{ type: HostBinding, args: ["class.mdl-list__item-secondary-content",] }]
};
class MdlListItemSecondaryActionComponent {
    constructor(mdlListItemComponent) {
        this.mdlListItemComponent = mdlListItemComponent;
        this.isSecondaryAction = true;
    }
    ngOnInit() {
        if (this.mdlListItemComponent === null) {
            throw new MdlStructureError("mdl-list-item-secondary-action", "mdl-list-item");
        }
    }
}
MdlListItemSecondaryActionComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-list-item-secondary-action",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlListItemSecondaryActionComponent.ctorParameters = () => [
    { type: MdlListItemComponent, decorators: [{ type: Optional }] }
];
MdlListItemSecondaryActionComponent.propDecorators = {
    isSecondaryAction: [{ type: HostBinding, args: ["class.mdl-list__item-secondary-action",] }]
};
class MdlListItemSubTitleComponent {
    constructor(mdlListItemComponent) {
        this.mdlListItemComponent = mdlListItemComponent;
        this.isSubTitle = true;
    }
    ngOnInit() {
        if (this.mdlListItemComponent === null) {
            throw new MdlStructureError("mdl-list-item-sub-title", "mdl-list-item-primary-content");
        }
    }
}
MdlListItemSubTitleComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-list-item-sub-title",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlListItemSubTitleComponent.ctorParameters = () => [
    { type: MdlListItemPrimaryContentComponent, decorators: [{ type: Optional }] }
];
MdlListItemSubTitleComponent.propDecorators = {
    isSubTitle: [{ type: HostBinding, args: ["class.mdl-list__item-sub-title",] }]
};
class MdlListItemSecondaryInfoComponent {
    constructor(mdlListItemComponent) {
        this.mdlListItemComponent = mdlListItemComponent;
        this.isSecondaryInfo = true;
    }
    ngOnInit() {
        if (this.mdlListItemComponent === null) {
            throw new MdlStructureError("mdl-list-item-secondary-info", "mdl-list-item-secondary-content");
        }
    }
}
MdlListItemSecondaryInfoComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-list-item-secondary-info",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlListItemSecondaryInfoComponent.ctorParameters = () => [
    { type: MdlListItemSecondaryContentComponent, decorators: [{ type: Optional }] }
];
MdlListItemSecondaryInfoComponent.propDecorators = {
    isSecondaryInfo: [{ type: HostBinding, args: ["class.mdl-list__item-secondary-info",] }]
};
class MdlListItemTextBodyComponent {
    constructor(mdlListItemComponent) {
        this.mdlListItemComponent = mdlListItemComponent;
        this.isTextBody = true;
    }
    ngOnInit() {
        if (this.mdlListItemComponent === null) {
            throw new MdlStructureError("mdl-list-item-text-body", "mdl-list-item");
        }
    }
}
MdlListItemTextBodyComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-list-item-text-body",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlListItemTextBodyComponent.ctorParameters = () => [
    { type: MdlListItemComponent, decorators: [{ type: Optional }] }
];
MdlListItemTextBodyComponent.propDecorators = {
    isTextBody: [{ type: HostBinding, args: ["class.mdl-list__item-text-body",] }]
};
class MdlListItemIconDirective {
    constructor() {
        this.isItemIcon = true;
    }
}
MdlListItemIconDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: 'mdl-icon[mdl-list-item-icon]'
            },] }
];
MdlListItemIconDirective.propDecorators = {
    isItemIcon: [{ type: HostBinding, args: ["class.mdl-list__item-icon",] }]
};
class MdlListItemAvatarDirective {
    constructor() {
        this.isItemAvatar = true;
    }
}
MdlListItemAvatarDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: 'mdl-icon[mdl-list-item-avatar]'
            },] }
];
MdlListItemAvatarDirective.propDecorators = {
    isItemAvatar: [{ type: HostBinding, args: ["class.mdl-list__item-avatar",] }]
};

const MDL_LIST_DIRECTIVES = [
    MdlListComponent,
    MdlListItemComponent,
    MdlListItemPrimaryContentComponent,
    MdlListItemIconDirective,
    MdlListItemAvatarDirective,
    MdlListItemSecondaryContentComponent,
    MdlListItemSecondaryActionComponent,
    MdlListItemSubTitleComponent,
    MdlListItemSecondaryInfoComponent,
    MdlListItemTextBodyComponent,
];
class MdlListModule {
    static forRoot() {
        return {
            ngModule: MdlListModule,
            providers: [],
        };
    }
}
MdlListModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                exports: MDL_LIST_DIRECTIVES,
                declarations: MDL_LIST_DIRECTIVES,
            },] }
];

const BOTTOM_LEFT = "bottom-left";
const BOTTOM_RIGHT = "bottom-right";
const TOP_LEFT = "top-left";
const TOP_RIGHT = "top-right";
const UNALIGNED = "unaligned";
// Total duration of the menu animation.
const TRANSITION_DURATION_SECONDS = 0.3;
// The fraction of the total duration we want to use for menu item animations.
const TRANSITION_DURATION_FRACTION = 0.8;
// How long the menu stays open after choosing an option (so the user can see
// the ripple).
const CLOSE_TIMEOUT = 175;
const CSS_ALIGN_MAP = {};
CSS_ALIGN_MAP[BOTTOM_LEFT] = "mdl-menu--bottom-left";
CSS_ALIGN_MAP[BOTTOM_RIGHT] = "mdl-menu--bottom-right";
CSS_ALIGN_MAP[TOP_LEFT] = "mdl-menu--top-left";
CSS_ALIGN_MAP[TOP_RIGHT] = "mdl-menu--top-right";
CSS_ALIGN_MAP[UNALIGNED] = "mdl-menu--unaligned";
class MdlMenuError extends MdlError {
}
class MdlMenuRegisty {
    constructor() {
        this.menuComponents = [];
    }
    add(menuComponent) {
        this.menuComponents.push(menuComponent);
    }
    remove(menuComponent) {
        const fromIndex = this.menuComponents.indexOf(menuComponent);
        this.menuComponents.splice(fromIndex, 1);
    }
    hideAllExcept(menuComponent) {
        this.menuComponents.forEach((component) => {
            if (component !== menuComponent) {
                component.hide();
            }
        });
    }
}
MdlMenuRegisty.ɵprov = i0.ɵɵdefineInjectable({ factory: function MdlMenuRegisty_Factory() { return new MdlMenuRegisty(); }, token: MdlMenuRegisty, providedIn: "root" });
MdlMenuRegisty.decorators = [
    { type: Injectable, args: [{
                providedIn: "root",
            },] }
];
class MdlMenuComponent {
    constructor(renderer, menuRegistry) {
        this.renderer = renderer;
        this.menuRegistry = menuRegistry;
        this.cssPosition = "mdl-menu--bottom-left";
        this.isVisible = false;
        this.menuRegistry.add(this);
    }
    ngOnInit() {
        this.cssPosition = CSS_ALIGN_MAP[this.position] || BOTTOM_LEFT;
    }
    ngAfterViewInit() {
        this.container = this.containerChild.nativeElement;
        this.menuElement = this.menuElementChild.nativeElement;
        this.outline = this.outlineChild.nativeElement;
        // Add a click listener to the document, to close the menu.
        const callback = () => {
            if (this.isVisible) {
                this.hide();
            }
            return true;
        };
        this.renderer.listen("window", "click", callback);
        this.renderer.listen("window", "touchstart", callback);
    }
    toggle(event, mdlButton) {
        if (!mdlButton) {
            throw new MdlMenuError(`MdlButtonComponent is required`);
        }
        if (this.isVisible) {
            this.hide();
        }
        else {
            this.show(event, mdlButton);
        }
    }
    hideOnItemClicked() {
        // Wait some time before closing menu, so the user can see the ripple.
        setTimeout(() => {
            this.hide();
        }, CLOSE_TIMEOUT);
    }
    hide() {
        // Remove all transition delays; menu items fade out concurrently.
        document.querySelectorAll("mdl-menu-item").forEach((el) => {
            el.style.removeProperty("transition-delay");
        });
        // this.menuItemComponents.toArray().forEach(mi => {
        //   mi.element.style.removeProperty('transition-delay');
        // });
        // Measure the inner element.
        const rect = this.menuElement.getBoundingClientRect();
        const height = rect.height;
        const width = rect.width;
        // Turn on animation, and apply the final clip. Also make invisible.
        // This triggers the transitions.
        this.renderer.addClass(this.menuElement, "is-animating");
        this.applyClip(height, width);
        this.renderer.removeClass(this.container, "is-visible");
        // Clean up after the animation is complete.
        this.addAnimationEndListener();
        this.isVisible = false;
    }
    show(event, mdlButton) {
        this.menuRegistry.hideAllExcept(this);
        event.stopPropagation();
        const forElement = mdlButton.element;
        const rect = forElement.getBoundingClientRect();
        const forRect = forElement.parentElement.getBoundingClientRect();
        if (this.position === UNALIGNED) {
            // Do not position the menu automatically. Requires the developer to
            // manually specify position.
        }
        else if (this.position === BOTTOM_RIGHT) {
            // Position below the "for" element, aligned to its right.
            this.container.style.right = forRect.right - rect.right + "px";
            this.container.style.top =
                forElement.offsetTop + forElement.offsetHeight + "px";
        }
        else if (this.position === TOP_LEFT) {
            // Position above the "for" element, aligned to its left.
            this.container.style.left = forElement.offsetLeft + "px";
            this.container.style.bottom = forRect.bottom - rect.top + "px";
        }
        else if (this.position === TOP_RIGHT) {
            // Position above the "for" element, aligned to its right.
            this.container.style.right = forRect.right - rect.right + "px";
            this.container.style.bottom = forRect.bottom - rect.top + "px";
        }
        else {
            // Default: position below the "for" element, aligned to its left.
            this.container.style.left = forElement.offsetLeft + "px";
            this.container.style.top =
                forElement.offsetTop + forElement.offsetHeight + "px";
        }
        // Measure the inner element.
        const height = this.menuElement.getBoundingClientRect().height;
        const width = this.menuElement.getBoundingClientRect().width;
        this.container.style.width = width + "px";
        this.container.style.height = height + "px";
        this.outline.style.width = width + "px";
        this.outline.style.height = height + "px";
        const transitionDuration = TRANSITION_DURATION_SECONDS * TRANSITION_DURATION_FRACTION;
        document.querySelectorAll("mdl-menu-item").forEach((el) => {
            const mi = el;
            let itemDelay;
            if (this.position === TOP_LEFT || this.position === TOP_RIGHT) {
                itemDelay =
                    ((height - mi.offsetTop - mi.offsetHeight) / height) *
                        transitionDuration +
                        "s";
            }
            else {
                itemDelay = (mi.offsetTop / height) * transitionDuration + "s";
            }
            mi.style.transitionDelay = itemDelay;
        });
        // Apply the initial clip to the text before we start animating.
        this.applyClip(height, width);
        this.renderer.addClass(this.container, "is-visible");
        this.menuElement.style.clip = "rect(0 " + width + "px " + height + "px 0)";
        this.renderer.addClass(this.menuElement, "is-animating");
        this.addAnimationEndListener();
        this.isVisible = true;
    }
    ngOnDestroy() {
        this.menuRegistry.remove(this);
    }
    addAnimationEndListener() {
        this.renderer.listen(this.menuElement, "transitionend", () => {
            this.renderer.removeClass(this.menuElement, "is-animating");
            return true;
        });
    }
    applyClip(height, width) {
        if (this.position === UNALIGNED) {
            // Do not clip.
            this.menuElement.style.clip = "";
        }
        else if (this.position === BOTTOM_RIGHT) {
            // Clip to the top right corner of the menu.
            this.menuElement.style.clip =
                "rect(0 " + width + "px " + "0 " + width + "px)";
        }
        else if (this.position === TOP_LEFT) {
            // Clip to the bottom left corner of the menu.
            this.menuElement.style.clip =
                "rect(" + height + "px 0 " + height + "px 0)";
        }
        else if (this.position === TOP_RIGHT) {
            // Clip to the bottom right corner of the menu.
            this.menuElement.style.clip =
                "rect(" +
                    height +
                    "px " +
                    width +
                    "px " +
                    height +
                    "px " +
                    width +
                    "px)";
        }
        else {
            // Default: do not clip (same as clipping to the top left corner).
            this.menuElement.style.clip = "";
        }
    }
}
MdlMenuComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-menu",
                exportAs: "mdlMenu",
                template: `
    <div #container class="mdl-menu__container is-upgraded">
      <div #outline class="mdl-menu__outline" [ngClass]="cssPosition"></div>
      <div class="mdl-menu" #menuElement>
        <ng-content></ng-content>
      </div>
    </div>
  `,
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlMenuComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: MdlMenuRegisty }
];
MdlMenuComponent.propDecorators = {
    position: [{ type: Input, args: ['mdl-menu-position',] }],
    containerChild: [{ type: ViewChild, args: ["container", { static: true },] }],
    menuElementChild: [{ type: ViewChild, args: ["menuElement", { static: true },] }],
    outlineChild: [{ type: ViewChild, args: ["outline", { static: true },] }]
};

class MdlMenuItemComponent {
    // forwardRef is needed because of he circular dependency menu queries menuitems; menuitem needs the parent
    constructor(elementRef, mdlMenu) {
        this.elementRef = elementRef;
        this.mdlMenu = mdlMenu;
        this.tabindex = -1;
        this.isMenuItem = true;
        this.disabledIntern = false;
        this.element = elementRef.nativeElement;
    }
    get disabled() {
        return this.disabledIntern;
    }
    set disabled(value) {
        this.disabledIntern = toBoolean(value);
    }
    onClick($event) {
        $event.stopPropagation();
        if (this.disabled) {
            this.mdlMenu.hide();
            return;
        }
        this.mdlMenu.hideOnItemClicked();
    }
    // we need to register a touchstart at the window to get informed if the user taps outside the menu.
    // But if we register a touchstart event - safari will no longer convert touch events to click events.
    // So we need to convert touch to click and the user still needs to register a (click) listener to be
    // informed if the menu item has clicked.
    onTouch($event) {
        // ensure that this event is totally consumed
        $event.stopPropagation();
        $event.preventDefault();
        const event = new MouseEvent("click", { bubbles: true });
        callNative(this.element, "dispatchEvent", event);
    }
}
MdlMenuItemComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-menu-item",
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlMenuItemComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: MdlMenuComponent, decorators: [{ type: Inject, args: [forwardRef(() => MdlMenuComponent),] }] }
];
MdlMenuItemComponent.propDecorators = {
    tabindex: [{ type: HostBinding, args: ["tabindex",] }],
    isMenuItem: [{ type: HostBinding, args: ["class.mdl-menu__item",] }],
    disabled: [{ type: Input }],
    onClick: [{ type: HostListener, args: ["click", ["$event"],] }],
    onTouch: [{ type: HostListener, args: ["touchstart", ["$event"],] }]
};

class MdlMenuItemFullBleedDeviderDirective {
    constructor() {
        this.isFullBleedDivider = true;
    }
}
MdlMenuItemFullBleedDeviderDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: '[mdl-menu-item-full-bleed-divider]'
            },] }
];
MdlMenuItemFullBleedDeviderDirective.propDecorators = {
    isFullBleedDivider: [{ type: HostBinding, args: ["class.mdl-menu__item--full-bleed-divider",] }]
};

class MdlToggleMenuDirective {
    constructor(button) {
        this.button = button;
    }
    onClick($event) {
        this.menu.toggle($event, this.button);
    }
}
MdlToggleMenuDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: '[mdl-button][mdl-toggle-menu]'
            },] }
];
MdlToggleMenuDirective.ctorParameters = () => [
    { type: MdlButtonComponent }
];
MdlToggleMenuDirective.propDecorators = {
    menu: [{ type: Input, args: ['mdl-toggle-menu',] }],
    onClick: [{ type: HostListener, args: ["click", ["$event"],] }]
};

const MDL_MENU_DIRECTIVES = [
    MdlMenuComponent,
    MdlMenuItemComponent,
    MdlMenuItemFullBleedDeviderDirective,
    MdlToggleMenuDirective,
];
class MdlMenuModule {
    static forRoot() {
        return {
            ngModule: MdlMenuModule,
            providers: [MdlMenuRegisty],
        };
    }
}
MdlMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: MDL_MENU_DIRECTIVES,
                declarations: MDL_MENU_DIRECTIVES,
            },] }
];

class MdlProgressComponent {
    constructor() {
        this.progress = 0;
        this.buffer = 100;
        this.aux = 0;
        this.isProgess = true;
        this.indeterminateIntern = false;
    }
    get indeterminate() {
        return this.indeterminateIntern;
    }
    set indeterminate(value) {
        this.indeterminateIntern = toBoolean(value);
    }
    ngOnChanges(changes) {
        if (changes.buffer) {
            this.setBuffer(changes.buffer.currentValue);
        }
    }
    setBuffer(b) {
        this.aux = 100 - b;
    }
}
MdlProgressComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-progress",
                template: `
    <div class="progressbar bar bar1" [style.width]="progress + '%'"></div>
    <div class="bufferbar bar bar2" [style.width]="buffer + '%'"></div>
    <div class="auxbar bar bar3" [ngStyle]="{ width: aux + '%' }"></div>
  `,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
MdlProgressComponent.propDecorators = {
    progress: [{ type: Input }],
    buffer: [{ type: Input }],
    aux: [{ type: Input }],
    isProgess: [{ type: HostBinding, args: ["class.mdl-progress",] }],
    indeterminate: [{ type: HostBinding, args: ["class.mdl-progress__indeterminate",] }, { type: Input }]
};

const MDL_PROGRESS_DIRECTIVES = [MdlProgressComponent];
class MdlProgressModule {
    static forRoot() {
        return {
            ngModule: MdlProgressModule,
            providers: [],
        };
    }
}
MdlProgressModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: MDL_PROGRESS_DIRECTIVES,
                declarations: MDL_PROGRESS_DIRECTIVES,
            },] }
];

const throwNameError = () => {
    throw new Error(`
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <mdl-radio formControlName="food" name="food"></mdl-radio>
    `);
};
const ɵ0 = throwNameError;
const IS_FOCUSED$1 = "is-focused";
// Registry for mdl-readio compnents. Is responsible to keep the
// right state of the radio buttons of a radio group. It would be
// easier if i had a mdl-radio-group component. but this would be
// a big braking change.
class MdlRadioGroupRegisty {
    constructor() {
        this.defaultFormGroup = "defaultFromGroup";
        this.radioComponents = [];
    }
    add(radioComponent, formGroupName) {
        this.radioComponents.push({
            radio: radioComponent,
            group: formGroupName || this.defaultFormGroup,
        });
    }
    remove(radioComponent) {
        this.radioComponents = this.radioComponents.filter((radioComponentInArray) => radioComponentInArray.radio !== radioComponent);
    }
    select(radioComponent, formGroupName) {
        // unselect every radioComponent that is not the provided radiocomponent
        // and has the same name and is in teh same group.
        const groupToTest = formGroupName || this.defaultFormGroup;
        this.radioComponents.forEach((component) => {
            if (component.radio.name === radioComponent.name &&
                component.group === groupToTest) {
                if (component.radio !== radioComponent) {
                    component.radio.deselect(radioComponent.value);
                }
            }
        });
    }
}
MdlRadioGroupRegisty.ɵprov = i0.ɵɵdefineInjectable({ factory: function MdlRadioGroupRegisty_Factory() { return new MdlRadioGroupRegisty(); }, token: MdlRadioGroupRegisty, providedIn: "root" });
MdlRadioGroupRegisty.decorators = [
    { type: Injectable, args: [{
                providedIn: "root",
            },] }
];
/*
 <mdl-radio name="group1" value="1" [(ngModel)]="radioOption">Value 1</mdl-radio>
 */
class MdlRadioComponent {
    constructor(elementRef, renderer, radioGroupRegistry, formGroupName) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.radioGroupRegistry = radioGroupRegistry;
        this.formGroupName = formGroupName;
        this.tabindex = null;
        // eslint-disable-next-line
        this.change = new EventEmitter();
        // the internal state - used to set the underlaying radio button state.
        this.checked = false;
        this.isUpgraded = true;
        this.isRadio = true;
        this.onTouchedCallback = noop;
        this.onChangeCallback = noop;
        this.disabledIntern = false;
        this.el = elementRef.nativeElement;
    }
    get disabled() {
        return this.disabledIntern;
    }
    set disabled(value) {
        this.disabledIntern = toBoolean(value);
    }
    onClick() {
        if (this.disabled) {
            return;
        }
        this.optionValue = this.value;
        this.updateCheckState();
        this.onChangeCallback();
        this.change.emit(this.optionValue);
    }
    ngOnInit() {
        // we need a name and it must be the same as in the formcontrol.
        // a radio group without name is useless.
        this.checkName();
        // register the radio button - this is the only chance to unselect the
        // radio button that is no longer active - scope the radio button with it's group
        // if there is one.
        this.radioGroupRegistry.add(this, this.formGroupName);
    }
    ngOnDestroy() {
        this.radioGroupRegistry.remove(this);
    }
    writeValue(optionValue) {
        this.optionValue = optionValue;
        this.updateCheckState();
    }
    deselect(value) {
        // called from the registry. the value is the value of the selected radio button
        // e.g. the radio button get unselected if it isnÄt the selected one.
        this.writeValue(value);
    }
    registerOnChange(fn) {
        // wrap the callback, so that we can call select on the registry
        this.onChangeCallback = () => {
            fn(this.value);
            this.radioGroupRegistry.select(this, this.formGroupName);
        };
    }
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    onFocus() {
        this.renderer.addClass(this.el, IS_FOCUSED$1);
    }
    onBlur() {
        this.renderer.removeClass(this.el, IS_FOCUSED$1);
    }
    spaceKeyPress() {
        this.checked = false; // in case of space key is pressed radio button value must remain same
    }
    updateCheckState() {
        this.checked = this.optionValue === this.value;
    }
    checkName() {
        if (this.name &&
            this.formControlName &&
            this.name !== this.formControlName) {
            throwNameError();
        }
        if (!this.name && this.formControlName) {
            this.name = this.formControlName;
        }
    }
}
MdlRadioComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-radio",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => MdlRadioComponent),
                        multi: true,
                    },
                ],
                template: `
    <input
      type="checkbox"
      class="mdl-radio__button"
      [attr.name]="name"
      (focus)="onFocus()"
      (blur)="onBlur()"
      (keyup.space)="spaceKeyPress()"
      [disabled]="disabled"
      [attr.tabindex]="tabindex"
      [(ngModel)]="checked"
    />
    <span class="mdl-radio__label"><ng-content></ng-content></span>
    <span class="mdl-radio__outer-circle"></span>
    <span class="mdl-radio__inner-circle"></span>
  `,
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlRadioComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: MdlRadioGroupRegisty },
    { type: FormGroupName, decorators: [{ type: Optional }] }
];
MdlRadioComponent.propDecorators = {
    name: [{ type: Input }],
    formControlName: [{ type: Input }],
    value: [{ type: Input }],
    tabindex: [{ type: Input }],
    change: [{ type: Output }],
    checked: [{ type: HostBinding, args: ["class.is-checked",] }],
    isUpgraded: [{ type: HostBinding, args: ["class.is-upgraded",] }],
    isRadio: [{ type: HostBinding, args: ["class.mdl-radio",] }],
    disabled: [{ type: HostBinding, args: ["class.is-disabled",] }, { type: Input }],
    onClick: [{ type: HostListener, args: ["click",] }]
};

class MdlRadioModule {
    static forRoot() {
        return {
            ngModule: MdlRadioModule,
            providers: [MdlRadioGroupRegisty],
        };
    }
}
MdlRadioModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule],
                exports: [MdlRadioComponent],
                declarations: [MdlRadioComponent],
            },] }
];

class MdlUnsupportedShadowValueError extends MdlError {
    constructor(value) {
        /* istanbul ignore next */
        super(`Shadow value "${value}" isn't supported (allowed: 2,3,4,6,8,16,24).`);
    }
}
const MDL_SHADOW_VALUES = [0, 2, 3, 4, 6, 8, 16, 24];
class MdlShadowDirective {
    constructor(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.mdlShadowIntern = 2;
        this.el = elementRef.nativeElement;
    }
    get mdlShadow() {
        return this.mdlShadowIntern;
    }
    set mdlShadow(value) {
        this.mdlShadowIntern = toNumber(value);
    }
    ngOnChanges(changes) {
        if (MDL_SHADOW_VALUES.indexOf(Number(this.mdlShadow)) === -1) {
            throw new MdlUnsupportedShadowValueError(this.mdlShadow);
        }
        const change = changes.mdlShadow;
        if (!change.isFirstChange()) {
            this.renderer.removeClass(this.el, `mdl-shadow--${change.previousValue}dp`);
        }
        this.renderer.addClass(this.el, `mdl-shadow--${change.currentValue}dp`);
    }
}
MdlShadowDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: '[mdl-shadow]'
            },] }
];
MdlShadowDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
MdlShadowDirective.propDecorators = {
    mdlShadow: [{ type: Input, args: ["mdl-shadow",] }]
};

const MDL_SHADOW_DIRECTIVES = [MdlShadowDirective];
class MdlShadowModule {
    static forRoot() {
        return {
            ngModule: MdlShadowModule,
            providers: [],
        };
    }
}
MdlShadowModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                exports: MDL_SHADOW_DIRECTIVES,
                declarations: MDL_SHADOW_DIRECTIVES,
            },] }
];

class MdlSliderComponent {
    constructor(renderer, elRef) {
        this.renderer = renderer;
        this.elRef = elRef;
        this.isSliderContainer = true;
        this.onTouchedCallback = noop;
        this.onChangeCallback = noop;
        this.disabledIntern = false;
    }
    get disabled() {
        return this.disabledIntern;
    }
    set disabled(value) {
        this.disabledIntern = toBoolean(value);
    }
    get value() {
        return this.valueIntern;
    }
    set value(v) {
        this.valueIntern = v;
        this.updateSliderUI();
        this.onChangeCallback(v);
    }
    onMouseUp(event) {
        event.target.blur();
    }
    onMouseDown(event) {
        if (event.target !== this.elRef.nativeElement) {
            return;
        }
        // Discard the original event and create a new event that
        // is on the slider element.
        event.preventDefault();
        const newEvent = new MouseEvent("mousedown", {
            relatedTarget: event.relatedTarget,
            button: event.button,
            buttons: event.buttons,
            clientX: event.clientX,
            clientY: this.inputEl.nativeElement.getBoundingClientRect().y,
            screenX: event.screenX,
            screenY: event.screenY,
        });
        callNative(this.inputEl.nativeElement, "dispatchEvent", newEvent);
    }
    ngAfterViewInit() {
        this.updateSliderUI();
    }
    writeValue(value) {
        this.valueIntern = value;
        this.updateSliderUI();
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    updateSliderUI() {
        // if the input hat a static value (for example value="30"
        // the setvalue method is called before the ViewChilds are initialized
        // this has changed in Angular 9! :(
        if (!this.inputEl) {
            return;
        }
        const fraction = (this.valueIntern - this.min) / (this.max - this.min);
        if (fraction === 0) {
            this.renderer.addClass(this.inputEl.nativeElement, "is-lowest-value");
        }
        else {
            this.renderer.removeClass(this.inputEl.nativeElement, "is-lowest-value");
        }
        this.renderer.setStyle(this.lowerEl.nativeElement, "flex", "" + fraction);
        this.renderer.setStyle(this.upperEl.nativeElement, "flex", "" + (1 - fraction));
    }
}
MdlSliderComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-slider",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => MdlSliderComponent),
                        multi: true,
                    },
                ],
                template: `
    <input
      class="mdl-slider is-upgraded"
      type="range"
      [min]="min"
      [max]="max"
      [step]="step"
      [(ngModel)]="value"
      [disabled]="disabled"
      tabindex="0"
      #input
    />
    <div class="mdl-slider__background-flex">
      <div class="mdl-slider__background-lower" #lower></div>
      <div class="mdl-slider__background-upper" #uppper></div>
    </div>
  `,
                encapsulation: ViewEncapsulation.None,
                styles: [`
      :host {
        height: 22px;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
      }
    `]
            },] }
];
MdlSliderComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
MdlSliderComponent.propDecorators = {
    min: [{ type: Input }],
    max: [{ type: Input }],
    step: [{ type: Input }],
    lowerEl: [{ type: ViewChild, args: ["lower", { static: true },] }],
    upperEl: [{ type: ViewChild, args: ["uppper", { static: true },] }],
    inputEl: [{ type: ViewChild, args: ["input", { static: true },] }],
    isSliderContainer: [{ type: HostBinding, args: ["class.mdl-slider__container",] }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    onMouseUp: [{ type: HostListener, args: ["mouseup", ["$event"],] }],
    onMouseDown: [{ type: HostListener, args: ["mousedown", ["$event"],] }]
};

const MDL_SLIDER_DIRECTIVES = [MdlSliderComponent];
class MdlSliderModule {
    static forRoot() {
        return {
            ngModule: MdlSliderModule,
            providers: [],
        };
    }
}
MdlSliderModule.decorators = [
    { type: NgModule, args: [{
                imports: [FormsModule, CommonModule],
                exports: MDL_SLIDER_DIRECTIVES,
                declarations: MDL_SLIDER_DIRECTIVES,
            },] }
];

const ANIMATION_TIME = 250;
class MdlSnackbarComponent {
    constructor() {
        this.showIt = false;
    }
    onClick() {
        this.onAction();
    }
    isActive() {
        return this.showIt;
    }
    show() {
        const result = new Subject();
        // wait unit the dom is in place - then showIt will change the css class
        setTimeout(() => {
            this.showIt = true;
            // fire after the view animation is done
            setTimeout(() => {
                result.next();
                result.complete();
            }, ANIMATION_TIME);
        }, ANIMATION_TIME);
        return result.asObservable();
    }
    hide() {
        this.showIt = false;
        const result = new Subject();
        // fire after the view animation is done
        setTimeout(() => {
            result.next(null);
            result.complete();
        }, ANIMATION_TIME);
        return result.asObservable();
    }
}
MdlSnackbarComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-snackbar-component",
                template: `
    <div
      id="demo-toast-example"
      class=" mdl-snackbar"
      [ngClass]="{ 'mdl-snackbar--active': showIt }"
    >
      <div class="mdl-snackbar__text">{{ message }}</div>
      <button
        *ngIf="onAction"
        class="mdl-snackbar__action"
        type="button"
        (click)="onClick()"
      >
        {{ actionText }}
      </button>
    </div>
  `,
                encapsulation: ViewEncapsulation.None
            },] }
];
class MdlSnackbarService {
    constructor(componentFactoryResolver, dialogOutletService) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.dialogOutletService = dialogOutletService;
        this.cFactory = this.componentFactoryResolver.resolveComponentFactory(MdlSnackbarComponent);
    }
    showToast(message, timeout) {
        return this.showSnackbar({
            message,
            timeout,
        });
    }
    showSnackbar(snackbarMessage) {
        const optTimeout = snackbarMessage.timeout || 2750;
        const closeAfterTimeout = !!snackbarMessage.closeAfterTimeout;
        const viewContainerRef = this.dialogOutletService.viewContainerRef;
        if (!viewContainerRef) {
            throw new Error("You did not provide a ViewContainerRef. " +
                "Please see https://github.com/mseemann/angular2-mdl/wiki/How-to-use-the-MdlDialogService");
        }
        const cRef = viewContainerRef.createComponent(this.cFactory, viewContainerRef.length);
        const mdlSnackbarComponent = cRef.instance;
        mdlSnackbarComponent.message = snackbarMessage.message;
        if (this.previousSnack) {
            const previousSnack = this.previousSnack;
            const subscription = previousSnack.component.hide().subscribe(() => {
                previousSnack.cRef.destroy();
                subscription.unsubscribe();
            });
        }
        this.previousSnack = {
            component: mdlSnackbarComponent,
            cRef,
        };
        if (snackbarMessage.action) {
            if (closeAfterTimeout) {
                this.hideAndDestroySnack(mdlSnackbarComponent, cRef, optTimeout);
            }
            mdlSnackbarComponent.actionText = snackbarMessage.action.text;
            mdlSnackbarComponent.onAction = () => {
                mdlSnackbarComponent.hide().subscribe(() => {
                    cRef.destroy();
                    snackbarMessage.action.handler();
                });
            };
        }
        else {
            this.hideAndDestroySnack(mdlSnackbarComponent, cRef, optTimeout);
        }
        const result = new Subject();
        mdlSnackbarComponent.show().subscribe(() => {
            result.next(mdlSnackbarComponent);
            result.complete();
        });
        return result.asObservable();
    }
    hideAndDestroySnack(component, componentRef, timeOut) {
        setTimeout(() => {
            component.hide().subscribe(() => {
                componentRef.destroy();
            });
        }, timeOut);
    }
}
MdlSnackbarService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MdlSnackbarService_Factory() { return new MdlSnackbarService(i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(MdlDialogOutletService)); }, token: MdlSnackbarService, providedIn: "root" });
MdlSnackbarService.decorators = [
    { type: Injectable, args: [{
                providedIn: "root",
            },] }
];
MdlSnackbarService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: MdlDialogOutletService }
];

class MdlSnackbarModule {
    static forRoot() {
        return {
            ngModule: MdlSnackbarModule,
            providers: [MdlSnackbarService],
        };
    }
}
MdlSnackbarModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, MdlDialogOutletModule.forRoot()],
                exports: [MdlSnackbarComponent],
                declarations: [MdlSnackbarComponent],
                entryComponents: [MdlSnackbarComponent],
            },] }
];

class MdlSpinnerComponent {
    constructor() {
        this.isSpinner = true;
        this.isUpgraded = true;
        this.layers = [1, 2, 3, 4];
        this.activeIntern = false;
        this.singleColorIntern = false;
    }
    get active() {
        return this.activeIntern;
    }
    set active(value) {
        this.activeIntern = toBoolean(value);
    }
    get singleColor() {
        return this.singleColorIntern;
    }
    set singleColor(value) {
        this.singleColorIntern = toBoolean(value);
    }
}
MdlSpinnerComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-spinner",
                template: `
    <div
      *ngFor="let layer of layers"
      class="mdl-spinner__layer mdl-spinner__layer-{{ layer }}"
    >
      <div class="mdl-spinner__circle-clipper mdl-spinner__left">
        <div class="mdl-spinner__circle"></div>
      </div>
      <div class="mdl-spinner__gap-patch">
        <div class="mdl-spinner__circle"></div>
      </div>
      <div class="mdl-spinner__circle-clipper mdl-spinner__right">
        <div class="mdl-spinner__circle"></div>
      </div>
    </div>
  `,
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlSpinnerComponent.propDecorators = {
    isSpinner: [{ type: HostBinding, args: ["class.mdl-spinner",] }],
    isUpgraded: [{ type: HostBinding, args: ["class.is-upgraded",] }],
    active: [{ type: HostBinding, args: ["class.is-active",] }, { type: Input }],
    singleColor: [{ type: HostBinding, args: ["class.mdl-spinner--single-color",] }, { type: Input, args: ["single-color",] }]
};

const MDL_SPINNER_DIRECTIVES = [MdlSpinnerComponent];
class MdlSpinnerModule {
    static forRoot() {
        return {
            ngModule: MdlSpinnerModule,
            providers: [],
        };
    }
}
MdlSpinnerModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: MDL_SPINNER_DIRECTIVES,
                declarations: MDL_SPINNER_DIRECTIVES,
            },] }
];

class MdlSwitchComponent extends MdlCheckboxComponent {
    constructor(elementRef, renderer) {
        super(elementRef, renderer);
        this.isSwitch = true;
        this.isCheckbox = false;
    }
}
MdlSwitchComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-switch",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => MdlSwitchComponent),
                        multi: true,
                    },
                ],
                template: `
    <input
      type="checkbox"
      class="mdl-switch__input"
      (focus)="onFocus()"
      (blur)="onBlur()"
      [disabled]="disabled"
      [(ngModel)]="value"
    />
    <span class="mdl-switch__label"><ng-content></ng-content></span>
    <div class="mdl-switch__track"></div>
    <div class="mdl-switch__thumb">
      <span class="mdl-switch__focus-helper"></span>
    </div>
  `,
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlSwitchComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
MdlSwitchComponent.propDecorators = {
    isSwitch: [{ type: HostBinding, args: ["class.mdl-switch",] }]
};

const MDL_SWITCH_DIRECTIVES = [MdlSwitchComponent];
class MdlSwitchModule {
    static forRoot() {
        return {
            ngModule: MdlSwitchModule,
            providers: [],
        };
    }
}
MdlSwitchModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule],
                exports: MDL_SWITCH_DIRECTIVES,
                declarations: MDL_SWITCH_DIRECTIVES,
            },] }
];

class MdlDefaultTableModel {
    constructor(columns) {
        this.data = [];
        this.columns = columns;
    }
    addAll(data) {
        this.data.push(...data);
    }
}
const template = `
        <table class="mdl-data-table">
           <thead>
           <tr>
              <th *ngIf="selectable">
                 <mdl-checkbox mdl-ripple [ngModel]="isAllSelected()" (ngModelChange)="toogleAll()"></mdl-checkbox>
              </th>
              <th *ngFor="let column of model.columns"
                  [ngClass]="{'mdl-data-table__cell--non-numeric': !column.numeric}">
                 {{column.name}}
              </th>
           </tr>
           </thead>
           <tbody>
           <tr *ngFor="let data of model.data; let i = index" [ngClass]="{'is-selected': selectable && data.selected}">
              <td *ngIf="selectable">
                 <mdl-checkbox mdl-ripple
                      [(ngModel)]="data.selected"
                      (ngModelChange)="selectionChanged()"></mdl-checkbox>
              </td>
              <td *ngFor="let column of model.columns"
                  [ngClass]="{'mdl-data-table__cell--non-numeric': !column.numeric}"
                  [innerHTML]="data[column.key]">
              </td>
           </tr>
           </tbody>
        </table>
    `;
const styles = `
    :host{
      display:inline-block;
    }
    `;
class MdlTableComponent {
    constructor() {
        this.selectable = false;
    }
    isAllSelected() {
        return false;
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    toogleAll() { }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    selectionChanged() { }
}
MdlTableComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-table",
                template,
                encapsulation: ViewEncapsulation.None,
                styles: [styles]
            },] }
];
MdlTableComponent.propDecorators = {
    model: [{ type: Input, args: ['table-model',] }]
};
class MdlSelectableTableComponent extends MdlTableComponent {
    constructor() {
        super(...arguments);
        // eslint-disable-next-line
        this.selectionChange = new EventEmitter();
        this.selectable = true;
        this.allSelected = false;
    }
    isAllSelected() {
        return this.model.data.every((data) => data.selected);
    }
    toogleAll() {
        const selected = !this.isAllSelected();
        this.model.data.forEach((data) => (data.selected = selected));
        this.updateSelected();
    }
    selectionChanged() {
        this.updateSelected();
    }
    updateSelected() {
        this.selected = this.model.data.filter((data) => data.selected);
        this.selectionChange.emit({ value: this.selected });
    }
}
MdlSelectableTableComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-table-selectable",
                template,
                encapsulation: ViewEncapsulation.None,
                styles: [styles]
            },] }
];
MdlSelectableTableComponent.propDecorators = {
    model: [{ type: Input, args: ['table-model',] }],
    selected: [{ type: Input, args: ['table-model-selected',] }],
    selectionChange: [{ type: Output, args: ['table-model-selectionChanged',] }]
};

const MDL_TABLE_DIRECTIVES = [MdlTableComponent, MdlSelectableTableComponent];
class MdlTableModule {
    static forRoot() {
        return {
            ngModule: MdlTableModule,
            providers: [],
        };
    }
}
MdlTableModule.decorators = [
    { type: NgModule, args: [{
                imports: [MdlCheckboxModule, MdlCommonsModule, CommonModule, FormsModule],
                exports: MDL_TABLE_DIRECTIVES,
                declarations: MDL_TABLE_DIRECTIVES,
            },] }
];

const DISABLE_NATIVE_VALIDITY_CHECKING = new InjectionToken("disableNativeValidityChecking");
let nextId = 0;
const IS_FOCUSED = "is-focused";
const IS_DISABLED = "is-disabled";
const IS_INVALID = "is-invalid";
const IS_DIRTY = "is-dirty";
/* eslint-disable  @angular-eslint/no-conflicting-lifecycle */
class MdlTextFieldComponent {
    constructor(renderer, elmRef, nativeCheckGlobalDisabled) {
        this.renderer = renderer;
        this.elmRef = elmRef;
        this.nativeCheckGlobalDisabled = nativeCheckGlobalDisabled;
        // eslint-disable-next-line
        this.blurEmitter = new EventEmitter();
        // eslint-disable-next-line
        this.focusEmitter = new EventEmitter();
        // eslint-disable-next-line
        this.keyupEmitter = new EventEmitter();
        this.type = "text";
        this.id = `mdl-textfield-${nextId++}`;
        this.tabindex = null;
        this.maxlength = null;
        this.isTextfield = true;
        this.isUpgraded = true;
        this.onTouchedCallback = noop;
        this.onChangeCallback = noop;
        this.disabledIntern = false;
        this.readonlyIntern = false;
        this.requiredIntern = false;
        this.autofocusIntern = false;
        this.isFloatingLabelIntern = false;
        this.rowsIntern = null;
        this.maxrowsIntern = -1;
        // @experimental
        this.disableNativeValidityCheckingIntern = false;
        this.el = elmRef.nativeElement;
    }
    get value() {
        return this.valueIntern;
    }
    set value(v) {
        this.valueIntern =
            this.type === "number" ? (v === "" ? null : parseFloat(v)) : v;
        this.onChangeCallback(this.value);
    }
    get disabled() {
        return this.disabledIntern;
    }
    set disabled(value) {
        this.disabledIntern = toBoolean(value);
    }
    get readonly() {
        return this.readonlyIntern;
    }
    set readonly(value) {
        this.readonlyIntern = toBoolean(value);
    }
    get required() {
        return this.requiredIntern;
    }
    set required(value) {
        this.requiredIntern = toBoolean(value);
    }
    get autofocus() {
        return this.autofocusIntern;
    }
    set autofocus(value) {
        this.autofocusIntern = toBoolean(value);
    }
    get isFloatingLabel() {
        return this.isFloatingLabelIntern;
    }
    set isFloatingLabel(value) {
        this.isFloatingLabelIntern = toBoolean(value);
    }
    get rows() {
        return this.rowsIntern;
    }
    set rows(value) {
        this.rowsIntern = toNumber(value);
    }
    get maxrows() {
        return this.maxrowsIntern;
    }
    set maxrows(value) {
        this.maxrowsIntern = toNumber(value);
    }
    get disableNativeValidityChecking() {
        return this.disableNativeValidityCheckingIntern;
    }
    set disableNativeValidityChecking(value) {
        this.disableNativeValidityCheckingIntern = toBoolean(value);
    }
    writeValue(value) {
        this.valueIntern = value;
        this.checkDirty();
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    // eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
    ngOnChanges() {
        this.checkDisabled();
    }
    // eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
    ngDoCheck() {
        this.checkValidity();
        this.checkDirty();
    }
    setFocus() {
        if (!this.inputEl) {
            return;
        }
        this.inputEl.nativeElement.dispatchEvent(new Event("focus"));
    }
    keydownTextarea($event) {
        const currentRowCount = this.inputEl.nativeElement.value.split("\n").length;
        // eslint-disable-next-line
        if ($event.keyCode === 13) {
            if (currentRowCount >= this.maxrows && this.maxrows !== -1) {
                $event.preventDefault();
            }
        }
    }
    // model value.
    triggerChange(event) {
        this.value = event.target.value;
        this.onTouchedCallback();
    }
    onFocus(event) {
        this.renderer.addClass(this.el, IS_FOCUSED);
        this.focusEmitter.emit(event);
    }
    onBlur(event) {
        this.renderer.removeClass(this.el, IS_FOCUSED);
        this.onTouchedCallback();
        this.blurEmitter.emit(event);
    }
    onKeyup(event) {
        this.keyupEmitter.emit(event);
    }
    checkDisabled() {
        if (this.disabled) {
            this.renderer.addClass(this.el, IS_DISABLED);
        }
        else {
            this.renderer.removeClass(this.el, IS_DISABLED);
        }
    }
    checkValidity() {
        // check the global setting - if globally disabled do no check
        if (this.nativeCheckGlobalDisabled === true) {
            return;
        }
        // check local setting - if locally disabled do no check
        if (this.disableNativeValidityChecking) {
            return;
        }
        if (this.inputEl && this.inputEl.nativeElement.validity) {
            if (!this.inputEl.nativeElement.validity.valid) {
                this.renderer.addClass(this.el, IS_INVALID);
            }
            else {
                this.renderer.removeClass(this.el, IS_INVALID);
            }
        }
    }
    checkDirty() {
        const dirty = this.inputEl &&
            this.inputEl.nativeElement.value &&
            this.inputEl.nativeElement.value.length > 0;
        if (dirty) {
            this.renderer.addClass(this.el, IS_DIRTY);
        }
        else {
            this.renderer.removeClass(this.el, IS_DIRTY);
        }
    }
}
MdlTextFieldComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-textfield",
                template: `
    <div *ngIf="!icon">
      <textarea
        *ngIf="rows"
        #input
        [rows]="rows"
        class="mdl-textfield__input"
        type="text"
        [attr.name]="name"
        [id]="id"
        [placeholder]="placeholder ? placeholder : ''"
        (focus)="onFocus($event)"
        (blur)="onBlur($event)"
        (keydown)="keydownTextarea($event)"
        (keyup)="onKeyup($event)"
        [(ngModel)]="value"
        [disabled]="disabled"
        [required]="required"
        [autofocus]="autofocus"
        [readonly]="readonly"
        [maxlength]="maxlength"
      ></textarea>
      <input
        *ngIf="!rows"
        #input
        class="mdl-textfield__input"
        [type]="type"
        [attr.name]="name"
        [id]="id"
        [pattern]="pattern ? pattern : '.*'"
        [attr.min]="min"
        [attr.max]="max"
        [attr.step]="step"
        [placeholder]="placeholder ? placeholder : ''"
        [autocomplete]="autocomplete ? autocomplete : ''"
        (focus)="onFocus($event)"
        (blur)="onBlur($event)"
        (keyup)="onKeyup($event)"
        [(ngModel)]="value"
        [disabled]="disabled"
        [required]="required"
        [autofocus]="autofocus"
        [readonly]="readonly"
        [attr.tabindex]="tabindex"
        [maxlength]="maxlength"
      />
      <label class="mdl-textfield__label" [attr.for]="id">{{ label }}</label>
      <span class="mdl-textfield__error">{{ errorMessage }}</span>
    </div>
    <div *ngIf="icon">
      <button mdl-button mdl-button-type="icon" (click)="setFocus()">
        <mdl-icon>{{ icon }}</mdl-icon>
      </button>
      <div class="mdl-textfield__expandable-holder">
        <input
          #input
          class="mdl-textfield__input"
          [type]="type"
          [attr.name]="name"
          [id]="id"
          [pattern]="pattern ? pattern : '.*'"
          [attr.min]="min"
          [attr.max]="max"
          [attr.step]="step"
          [placeholder]="placeholder ? placeholder : ''"
          [autocomplete]="autocomplete ? autocomplete : ''"
          (focus)="onFocus($event)"
          (blur)="onBlur($event)"
          (keyup)="onKeyup($event)"
          [(ngModel)]="value"
          [disabled]="disabled"
          [required]="required"
          [autofocus]="autofocus"
          [readonly]="readonly"
          [attr.tabindex]="tabindex"
          [maxlength]="maxlength"
        />
        <label class="mdl-textfield__label" [attr.for]="id">{{ label }}</label>
        <span class="mdl-textfield__error">{{ errorMessage }}</span>
      </div>
    </div>
  `,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => MdlTextFieldComponent),
                        multi: true,
                    },
                ],
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlTextFieldComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [DISABLE_NATIVE_VALIDITY_CHECKING,] }] }
];
MdlTextFieldComponent.propDecorators = {
    blurEmitter: [{ type: Output, args: ["blur",] }],
    focusEmitter: [{ type: Output, args: ["focus",] }],
    keyupEmitter: [{ type: Output, args: ["keyup",] }],
    inputEl: [{ type: ViewChild, args: ["input",] }],
    type: [{ type: Input }],
    label: [{ type: Input }],
    pattern: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    step: [{ type: Input }],
    name: [{ type: Input }],
    id: [{ type: Input }],
    errorMessage: [{ type: Input, args: ["error-msg",] }],
    placeholder: [{ type: HostBinding, args: ["class.has-placeholder",] }, { type: Input }],
    autocomplete: [{ type: Input }],
    icon: [{ type: HostBinding, args: ["class.mdl-textfield--expandable",] }, { type: Input }],
    tabindex: [{ type: Input }],
    maxlength: [{ type: Input }],
    isTextfield: [{ type: HostBinding, args: ["class.mdl-textfield",] }],
    isUpgraded: [{ type: HostBinding, args: ["class.is-upgraded",] }],
    value: [{ type: Input }],
    disabled: [{ type: Input }],
    readonly: [{ type: Input }],
    required: [{ type: Input }],
    autofocus: [{ type: Input }],
    isFloatingLabel: [{ type: HostBinding, args: ["class.mdl-textfield--floating-label",] }, { type: Input, args: ["floating-label",] }],
    rows: [{ type: Input }],
    maxrows: [{ type: Input }],
    disableNativeValidityChecking: [{ type: Input }]
};

class MdlTextFieldModule {
    static forRoot() {
        return {
            ngModule: MdlTextFieldModule,
            providers: [],
        };
    }
}
MdlTextFieldModule.decorators = [
    { type: NgModule, args: [{
                imports: [MdlIconModule, MdlButtonModule, FormsModule, CommonModule],
                exports: [MdlTextFieldComponent],
                declarations: [MdlTextFieldComponent],
            },] }
];

class MdlTooltipPositionService {
    calcStyle(offsetWidth, offsetHeight, props, position) {
        const result = {};
        const left = props.left + props.width / 2;
        const top = props.top + props.height / 2;
        const marginLeft = -1 * (offsetWidth / 2);
        const marginTop = -1 * (offsetHeight / 2);
        if (position === "left" || position === "right") {
            if (top + marginTop < 0) {
                result.top = "0";
                result.marginTop = "0";
            }
            else {
                result.top = top + "px";
                result.marginTop = marginTop + "px";
            }
        }
        else {
            if (left + marginLeft < 0) {
                result.left = "0";
                result.marginLeft = "0";
            }
            else {
                result.left = left + "px";
                result.marginLeft = marginLeft + "px";
            }
        }
        if (position === "top") {
            result.top = props.top - offsetHeight - 10 + "px";
        }
        else if (position === "right") {
            result.left = props.left + props.width + 10 + "px";
        }
        else if (position === "left") {
            result.left = props.left - offsetWidth - 10 + "px";
        }
        else {
            result.top = props.top + props.height + 10 + "px";
        }
        return result;
    }
}
MdlTooltipPositionService.decorators = [
    { type: Injectable }
];

const IS_ACTIVE = "is-active";
class MdlSimpleTooltipComponent {
    constructor(elRef, renderer, mdlTooltipPositionService) {
        this.elRef = elRef;
        this.renderer = renderer;
        this.mdlTooltipPositionService = mdlTooltipPositionService;
        this.large = false;
        this.isTooltip = true;
        this.active = false;
        this.element = elRef.nativeElement;
    }
    get isBottom() {
        return this.position === "bottom";
    }
    get isRight() {
        return this.position === "right";
    }
    get isLeft() {
        return this.position === "left";
    }
    isTop() {
        return this.position === "top";
    }
    mouseLeave() {
        if (this.delayTimeout) {
            clearTimeout(this.delayTimeout);
        }
        this.setActive(false);
    }
    mouseEnter(event) {
        if (this.delay) {
            this.delayTimeout = setTimeout(() => {
                this.show(event.target);
            }, this.delay);
        }
        else {
            this.show(event.target);
        }
    }
    isActive() {
        return this.active;
    }
    show(element) {
        const props = element.getBoundingClientRect();
        const offsetWidth = this.element.offsetWidth;
        const offsetHeight = this.element.offsetHeight;
        const style = this.mdlTooltipPositionService.calcStyle(offsetWidth, offsetHeight, props, this.position);
        for (const key of Object.keys(style)) {
            this.renderer.setStyle(this.elRef.nativeElement, key, style[key]);
        }
        this.setActive(true);
    }
    setActive(active) {
        this.active = active;
        if (active) {
            this.renderer.addClass(this.elRef.nativeElement, IS_ACTIVE);
        }
        else {
            this.renderer.removeClass(this.elRef.nativeElement, IS_ACTIVE);
        }
    }
}
MdlSimpleTooltipComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-simple-tooltip",
                template: "<div>{{tooltipText}}</div>",
                providers: [MdlTooltipPositionService],
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlSimpleTooltipComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: MdlTooltipPositionService }
];
MdlSimpleTooltipComponent.propDecorators = {
    large: [{ type: HostBinding, args: ["class.mdl-tooltip--large",] }],
    position: [{ type: Input }],
    delay: [{ type: Input }],
    isTooltip: [{ type: HostBinding, args: ["class.mdl-tooltip",] }],
    isBottom: [{ type: HostBinding, args: ["class.mdl-tooltip--bottom",] }],
    isRight: [{ type: HostBinding, args: ["class.mdl-tooltip--right",] }],
    isLeft: [{ type: HostBinding, args: ["class.mdl-tooltip--left",] }],
    isTop: [{ type: HostBinding, args: ["class.mdl-tooltip--top",] }]
};
class MdlTooltipComponent extends MdlSimpleTooltipComponent {
    constructor(elRef, renderer, mdlTooltipPositionService) {
        super(elRef, renderer, mdlTooltipPositionService);
    }
}
MdlTooltipComponent.decorators = [
    { type: Component, args: [{
                selector: "mdl-tooltip",
                template: "<div><ng-content></ng-content></div>",
                exportAs: "mdlTooltip",
                providers: [MdlTooltipPositionService],
                encapsulation: ViewEncapsulation.None
            },] }
];
MdlTooltipComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: MdlTooltipPositionService }
];

class AbstractMdlTooltipDirective {
    constructor(vcRef, large, componentFactoryResolver) {
        this.vcRef = vcRef;
        this.large = large;
        this.componentFactoryResolver = componentFactoryResolver;
    }
    onMouseEnter(event) {
        this.tooltipComponent.mouseEnter(event);
    }
    onMouseLeave() {
        this.tooltipComponent.mouseLeave();
    }
    ngOnInit() {
        // if the tooltip is not an instance of MdlTooltipComponent
        // we create a simpleTooltipComponent on the fly.
        if (!(this.tooltip instanceof MdlTooltipComponent)) {
            const cFactory = this.componentFactoryResolver.resolveComponentFactory(MdlSimpleTooltipComponent);
            const cRef = this.vcRef.createComponent(cFactory);
            this.tooltipComponent = cRef.instance;
            this.tooltipComponent.tooltipText = this.tooltip;
            this.configureTooltipComponent();
        }
        else {
            this.tooltipComponent = this.tooltip;
            this.configureTooltipComponent();
        }
    }
    ngOnChanges(changes) {
        if (changes.tooltip && !changes.tooltip.isFirstChange()) {
            if (!(this.tooltip instanceof MdlTooltipComponent)) {
                this.tooltipComponent.tooltipText = this.tooltip;
            }
        }
    }
    configureTooltipComponent() {
        this.tooltipComponent.large = this.large;
        this.tooltipComponent.position = this.position;
    }
}
AbstractMdlTooltipDirective.decorators = [
    { type: Directive }
];
AbstractMdlTooltipDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Boolean },
    { type: ComponentFactoryResolver }
];
AbstractMdlTooltipDirective.propDecorators = {
    onMouseEnter: [{ type: HostListener, args: ["touchend", ["$event"],] }, { type: HostListener, args: ["mouseenter", ["$event"],] }],
    onMouseLeave: [{ type: HostListener, args: ["window:touchstart",] }, { type: HostListener, args: ["mouseleave",] }]
};
class MdlTooltipDirective extends AbstractMdlTooltipDirective {
    constructor(vcRef, componentFactoryResolver) {
        super(vcRef, false, componentFactoryResolver);
    }
}
MdlTooltipDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: '[mdl-tooltip]'
            },] }
];
MdlTooltipDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver }
];
MdlTooltipDirective.propDecorators = {
    tooltip: [{ type: Input, args: ["mdl-tooltip",] }],
    position: [{ type: Input, args: ["mdl-tooltip-position",] }]
};
class MdlTooltipLargeDirective extends AbstractMdlTooltipDirective {
    constructor(vcRef, componentFactoryResolver) {
        super(vcRef, true, componentFactoryResolver);
    }
}
MdlTooltipLargeDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: '[mdl-tooltip-large]'
            },] }
];
MdlTooltipLargeDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver }
];
MdlTooltipLargeDirective.propDecorators = {
    tooltip: [{ type: Input, args: ["mdl-tooltip-large",] }],
    position: [{ type: Input, args: ["mdl-tooltip-position",] }]
};

const MDL_TOOLTIP_DIRECTIVES = [
    MdlTooltipComponent,
    MdlTooltipLargeDirective,
    MdlTooltipDirective,
];
class MdlTooltipModule {
    static forRoot() {
        return {
            ngModule: MdlTooltipModule,
            providers: [],
        };
    }
}
MdlTooltipModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                exports: MDL_TOOLTIP_DIRECTIVES,
                declarations: [...MDL_TOOLTIP_DIRECTIVES, MdlSimpleTooltipComponent],
                entryComponents: [MdlSimpleTooltipComponent],
            },] }
];

const MODULES = [
    MdlBadgeModule,
    MdlButtonModule,
    MdlCardModule,
    MdlCheckboxModule,
    MdlChipModule,
    MdlCommonsModule,
    MdlDialogModule,
    MdlDialogOutletModule,
    MdlIconModule,
    MdlIconToggleModule,
    MdlLayoutModule,
    MdlListModule,
    MdlMenuModule,
    MdlProgressModule,
    MdlRadioModule,
    MdlRippleModule,
    MdlShadowModule,
    MdlSliderModule,
    MdlSnackbarModule,
    MdlSpinnerModule,
    MdlSwitchModule,
    MdlTableModule,
    MdlTabsModule,
    MdlTextFieldModule,
    MdlTooltipModule,
];
class MdlModule {
}
MdlModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [
                    MdlButtonModule.forRoot(),
                    MdlLayoutModule.forRoot(),
                    MdlCheckboxModule.forRoot(),
                    MdlChipModule.forRoot(),
                    MdlDialogModule.forRoot(),
                    MdlDialogOutletModule.forRoot(),
                    MdlSpinnerModule.forRoot(),
                    MdlBadgeModule.forRoot(),
                    MdlShadowModule.forRoot(),
                    MdlCardModule.forRoot(),
                    MdlRadioModule.forRoot(),
                    MdlRippleModule.forRoot(),
                    MdlProgressModule.forRoot(),
                    MdlIconModule.forRoot(),
                    MdlIconToggleModule.forRoot(),
                    MdlListModule.forRoot(),
                    MdlSliderModule.forRoot(),
                    MdlSwitchModule.forRoot(),
                    MdlSnackbarModule.forRoot(),
                    MdlTooltipModule.forRoot(),
                    MdlTableModule.forRoot(),
                    MdlMenuModule.forRoot(),
                    MdlTabsModule.forRoot(),
                    MdlTextFieldModule.forRoot(),
                ],
                exports: [...MODULES],
            },] }
];
// @deprectaed use MdlModule - all services are provided in root by default.
class MdlNonRootModule {
    static forRoot() {
        return { ngModule: MdlModule };
    }
}
MdlNonRootModule.decorators = [
    { type: NgModule, args: [{
                imports: MODULES,
                exports: MODULES,
            },] }
];

/*
 * Public API Surface of core
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AbstractMdlTooltipDirective, Animations, AppendViewContainerRefDirective, CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR, DISABLE_NATIVE_VALIDITY_CHECKING, LAYOUT_SCREEN_SIZE_THRESHOLD, MdLUnsupportedLayoutTypeError, MdlAlertComponent, MdlAnchorRippleDirective, MdlBackdropOverlayComponent, MdlBadgeDirective, MdlBadgeModule, MdlBadgeNoBackgroundDirective, MdlBadgeOverlapDirective, MdlButtonComponent, MdlButtonModule, MdlButtonRippleDirective, MdlCardActionsComponent, MdlCardBorderDirective, MdlCardChildStructure, MdlCardComponent, MdlCardExpandDirective, MdlCardMediaComponent, MdlCardMenuComponent, MdlCardModule, MdlCardSupportingTextComponent, MdlCardTitleComponent, MdlCardTitleTextDirective, MdlCheckboxComponent, MdlCheckboxModule, MdlCheckboxRippleDirective, MdlChipComponent, MdlChipContactDirective, MdlChipModule, MdlCommonsModule, MdlDefaultTableModel, MdlDialogComponent, MdlDialogHostComponent, MdlDialogModule, MdlDialogOutletComponent, MdlDialogOutletModule, MdlDialogOutletService, MdlDialogReference, MdlDialogService, MdlError, MdlIconComponent, MdlIconModule, MdlIconToggleComponent, MdlIconToggleModule, MdlIconToggleRippleDirective, MdlLayoutComponent, MdlLayoutContentComponent, MdlLayoutDrawerComponent, MdlLayoutHeaderComponent, MdlLayoutHeaderRowComponent, MdlLayoutHeaderTransparentDirective, MdlLayoutModule, MdlLayoutSpacerComponent, MdlLayoutTabPanelComponent, MdlLayoutTitleComponent, MdlListComponent, MdlListItemAvatarDirective, MdlListItemComponent, MdlListItemIconDirective, MdlListItemPrimaryContentComponent, MdlListItemSecondaryActionComponent, MdlListItemSecondaryContentComponent, MdlListItemSecondaryInfoComponent, MdlListItemSubTitleComponent, MdlListItemTextBodyComponent, MdlListModule, MdlMenuComponent, MdlMenuError, MdlMenuItemComponent, MdlMenuItemFullBleedDeviderDirective, MdlMenuItemRippleDirective, MdlMenuModule, MdlMenuRegisty, MdlModule, MdlNonRootModule, MdlProgressComponent, MdlProgressModule, MdlRadioComponent, MdlRadioGroupRegisty, MdlRadioModule, MdlRadioRippleDirective, MdlRippleDirective, MdlRippleModule, MdlScreenSizeService, MdlSelectableTableComponent, MdlShadowDirective, MdlShadowModule, MdlSimpleDialogComponent, MdlSimpleTooltipComponent, MdlSliderComponent, MdlSliderModule, MdlSnackbarComponent, MdlSnackbarModule, MdlSnackbarService, MdlSpinnerComponent, MdlSpinnerModule, MdlStructureError, MdlSwitchComponent, MdlSwitchModule, MdlSwitchRippleDirective, MdlTabPanelComponent, MdlTabPanelContentComponent, MdlTabPanelTitleComponent, MdlTableComponent, MdlTableModule, MdlTabsComponent, MdlTabsModule, MdlTextFieldComponent, MdlTextFieldModule, MdlToggleMenuDirective, MdlTooltipComponent, MdlTooltipDirective, MdlTooltipLargeDirective, MdlTooltipModule, MdlUnsupportedButtonTypeError, MdlUnsupportedColoredTypeError, MdlUnsupportedCountOfListItemLinesError, MdlUnsupportedShadowValueError, NativeWebAnimationPlayer, NativeWebAnimations, NoopAnimationPlayer, NoopWebAnimations, callNative, instantiateSupportedAnimationDriver, noop, toBoolean, toNumber, ɵ1, ɵ2, MdlLayoutMediatorService as ɵa, MdlDialogInnerOutletComponent as ɵb, MDL_CONFIGUARTION as ɵc, InternalMdlDialogReference as ɵd, MdlTooltipPositionService as ɵe };
//# sourceMappingURL=angular-mdl-core.js.map
