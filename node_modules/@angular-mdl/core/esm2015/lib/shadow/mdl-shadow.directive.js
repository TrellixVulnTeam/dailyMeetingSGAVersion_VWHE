import { Directive, ElementRef, Input, Renderer2, } from "@angular/core";
import { MdlError } from "../common/mdl-error";
import { toNumber } from "../common/number.property";
export class MdlUnsupportedShadowValueError extends MdlError {
    constructor(value) {
        /* istanbul ignore next */
        super(`Shadow value "${value}" isn't supported (allowed: 2,3,4,6,8,16,24).`);
    }
}
const MDL_SHADOW_VALUES = [0, 2, 3, 4, 6, 8, 16, 24];
export class MdlShadowDirective {
    constructor(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.mdlShadowIntern = 2;
        this.el = elementRef.nativeElement;
    }
    get mdlShadow() {
        return this.mdlShadowIntern;
    }
    set mdlShadow(value) {
        this.mdlShadowIntern = toNumber(value);
    }
    ngOnChanges(changes) {
        if (MDL_SHADOW_VALUES.indexOf(Number(this.mdlShadow)) === -1) {
            throw new MdlUnsupportedShadowValueError(this.mdlShadow);
        }
        const change = changes.mdlShadow;
        if (!change.isFirstChange()) {
            this.renderer.removeClass(this.el, `mdl-shadow--${change.previousValue}dp`);
        }
        this.renderer.addClass(this.el, `mdl-shadow--${change.currentValue}dp`);
    }
}
MdlShadowDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: '[mdl-shadow]'
            },] }
];
MdlShadowDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
MdlShadowDirective.propDecorators = {
    mdlShadow: [{ type: Input, args: ["mdl-shadow",] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWRsLXNoYWRvdy5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb3JlL3NyYy9saWIvc2hhZG93L21kbC1zaGFkb3cuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsVUFBVSxFQUNWLEtBQUssRUFFTCxTQUFTLEdBRVYsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQy9DLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUVyRCxNQUFNLE9BQU8sOEJBQStCLFNBQVEsUUFBUTtJQUMxRCxZQUFZLEtBQXNCO1FBQ2hDLDBCQUEwQjtRQUMxQixLQUFLLENBQ0gsaUJBQWlCLEtBQUssK0NBQStDLENBQ3RFLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUFFRCxNQUFNLGlCQUFpQixHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBTXJELE1BQU0sT0FBTyxrQkFBa0I7SUFJN0IsWUFBb0IsVUFBc0IsRUFBVSxRQUFtQjtRQUFuRCxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQVUsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQUYvRCxvQkFBZSxHQUFHLENBQUMsQ0FBQztRQUcxQixJQUFJLENBQUMsRUFBRSxHQUFHLFVBQVUsQ0FBQyxhQUFhLENBQUM7SUFDckMsQ0FBQztJQUVELElBQ0ksU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQztJQUM5QixDQUFDO0lBRUQsSUFBSSxTQUFTLENBQUMsS0FBYTtRQUN6QixJQUFJLENBQUMsZUFBZSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLElBQUksaUJBQWlCLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtZQUM1RCxNQUFNLElBQUksOEJBQThCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQzFEO1FBRUQsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQztRQUVqQyxJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRSxFQUFFO1lBQzNCLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUN2QixJQUFJLENBQUMsRUFBRSxFQUNQLGVBQWUsTUFBTSxDQUFDLGFBQWEsSUFBSSxDQUN4QyxDQUFDO1NBQ0g7UUFFRCxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLGVBQWUsTUFBTSxDQUFDLFlBQVksSUFBSSxDQUFDLENBQUM7SUFDMUUsQ0FBQzs7O1lBcENGLFNBQVMsU0FBQztnQkFDVCwyQkFBMkI7Z0JBQzNCLFFBQVEsRUFBRSxjQUFjO2FBQ3pCOzs7WUF2QkMsVUFBVTtZQUdWLFNBQVM7Ozt3QkE2QlIsS0FBSyxTQUFDLFlBQVkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIFJlbmRlcmVyMixcbiAgU2ltcGxlQ2hhbmdlcyxcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IE1kbEVycm9yIH0gZnJvbSBcIi4uL2NvbW1vbi9tZGwtZXJyb3JcIjtcbmltcG9ydCB7IHRvTnVtYmVyIH0gZnJvbSBcIi4uL2NvbW1vbi9udW1iZXIucHJvcGVydHlcIjtcblxuZXhwb3J0IGNsYXNzIE1kbFVuc3VwcG9ydGVkU2hhZG93VmFsdWVFcnJvciBleHRlbmRzIE1kbEVycm9yIHtcbiAgY29uc3RydWN0b3IodmFsdWU6IG51bWJlciB8IHN0cmluZykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgc3VwZXIoXG4gICAgICBgU2hhZG93IHZhbHVlIFwiJHt2YWx1ZX1cIiBpc24ndCBzdXBwb3J0ZWQgKGFsbG93ZWQ6IDIsMyw0LDYsOCwxNiwyNCkuYFxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgTURMX1NIQURPV19WQUxVRVMgPSBbMCwgMiwgMywgNCwgNiwgOCwgMTYsIDI0XTtcblxuQERpcmVjdGl2ZSh7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBzZWxlY3RvcjogJ1ttZGwtc2hhZG93XSdcbn0pXG5leHBvcnQgY2xhc3MgTWRsU2hhZG93RGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgcHJpdmF0ZSByZWFkb25seSBlbDogSFRNTEVsZW1lbnQ7XG4gIHByaXZhdGUgbWRsU2hhZG93SW50ZXJuID0gMjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMikge1xuICAgIHRoaXMuZWwgPSBlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gIH1cblxuICBASW5wdXQoXCJtZGwtc2hhZG93XCIpXG4gIGdldCBtZGxTaGFkb3coKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5tZGxTaGFkb3dJbnRlcm47XG4gIH1cblxuICBzZXQgbWRsU2hhZG93KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLm1kbFNoYWRvd0ludGVybiA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAoTURMX1NIQURPV19WQUxVRVMuaW5kZXhPZihOdW1iZXIodGhpcy5tZGxTaGFkb3cpKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBNZGxVbnN1cHBvcnRlZFNoYWRvd1ZhbHVlRXJyb3IodGhpcy5tZGxTaGFkb3cpO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYW5nZSA9IGNoYW5nZXMubWRsU2hhZG93O1xuXG4gICAgaWYgKCFjaGFuZ2UuaXNGaXJzdENoYW5nZSgpKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKFxuICAgICAgICB0aGlzLmVsLFxuICAgICAgICBgbWRsLXNoYWRvdy0tJHtjaGFuZ2UucHJldmlvdXNWYWx1ZX1kcGBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLCBgbWRsLXNoYWRvdy0tJHtjaGFuZ2UuY3VycmVudFZhbHVlfWRwYCk7XG4gIH1cbn1cbiJdfQ==