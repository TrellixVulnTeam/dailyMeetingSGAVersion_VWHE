import { Directive, ElementRef, HostBinding, Input, Renderer2, } from "@angular/core";
const DATA_BADE_ATTR = "data-badge";
export class MdlBadgeDirective {
    constructor(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.isBadge = true;
        this.el = elementRef.nativeElement;
    }
    ngOnChanges() {
        if (this.mdlBadgeContent === null ||
            typeof this.mdlBadgeContent === "undefined") {
            this.renderer.removeAttribute(this.el, DATA_BADE_ATTR);
            return;
        }
        this.renderer.setAttribute(this.el, DATA_BADE_ATTR, this.mdlBadgeContent);
    }
}
MdlBadgeDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: '[mdl-badge]'
            },] }
];
MdlBadgeDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
MdlBadgeDirective.propDecorators = {
    mdlBadgeContent: [{ type: Input, args: ["mdl-badge",] }],
    isBadge: [{ type: HostBinding, args: ["class.mdl-badge",] }]
};
export class MdlBadgeOverlapDirective {
    constructor() {
        this.isOverlapping = true;
    }
}
MdlBadgeOverlapDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: '[mdl-badge-overlap]'
            },] }
];
MdlBadgeOverlapDirective.propDecorators = {
    isOverlapping: [{ type: HostBinding, args: ["class.mdl-badge--overlap",] }]
};
export class MdlBadgeNoBackgroundDirective {
    constructor() {
        this.isNoBackground = true;
    }
}
MdlBadgeNoBackgroundDirective.decorators = [
    { type: Directive, args: [{
                // eslint-disable-next-line
                selector: '[mdl-badge-no-background]'
            },] }
];
MdlBadgeNoBackgroundDirective.propDecorators = {
    isNoBackground: [{ type: HostBinding, args: ["class.mdl-badge--no-background",] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWRsLWJhZGdlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2NvcmUvc3JjL2xpYi9iYWRnZS9tZGwtYmFkZ2UuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsVUFBVSxFQUNWLFdBQVcsRUFDWCxLQUFLLEVBRUwsU0FBUyxHQUNWLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE1BQU0sY0FBYyxHQUFHLFlBQVksQ0FBQztBQU1wQyxNQUFNLE9BQU8saUJBQWlCO0lBTzVCLFlBQW9CLFVBQXNCLEVBQVUsUUFBbUI7UUFBbkQsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUFVLGFBQVEsR0FBUixRQUFRLENBQVc7UUFKdkMsWUFBTyxHQUFHLElBQUksQ0FBQztRQUs3QyxJQUFJLENBQUMsRUFBRSxHQUFHLFVBQVUsQ0FBQyxhQUFhLENBQUM7SUFDckMsQ0FBQztJQUVNLFdBQVc7UUFDaEIsSUFDRSxJQUFJLENBQUMsZUFBZSxLQUFLLElBQUk7WUFDN0IsT0FBTyxJQUFJLENBQUMsZUFBZSxLQUFLLFdBQVcsRUFDM0M7WUFDQSxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1lBQ3ZELE9BQU87U0FDUjtRQUNELElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsY0FBYyxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUM1RSxDQUFDOzs7WUF4QkYsU0FBUyxTQUFDO2dCQUNULDJCQUEyQjtnQkFDM0IsUUFBUSxFQUFFLGFBQWE7YUFDeEI7OztZQVpDLFVBQVU7WUFJVixTQUFTOzs7OEJBVVIsS0FBSyxTQUFDLFdBQVc7c0JBRWpCLFdBQVcsU0FBQyxpQkFBaUI7O0FBd0JoQyxNQUFNLE9BQU8sd0JBQXdCO0lBSnJDO1FBSzJDLGtCQUFhLEdBQUcsSUFBSSxDQUFDO0lBQ2hFLENBQUM7OztZQU5BLFNBQVMsU0FBQztnQkFDVCwyQkFBMkI7Z0JBQzNCLFFBQVEsRUFBRSxxQkFBcUI7YUFDaEM7Ozs0QkFFRSxXQUFXLFNBQUMsMEJBQTBCOztBQU96QyxNQUFNLE9BQU8sNkJBQTZCO0lBSjFDO1FBS2lELG1CQUFjLEdBQUcsSUFBSSxDQUFDO0lBQ3ZFLENBQUM7OztZQU5BLFNBQVMsU0FBQztnQkFDVCwyQkFBMkI7Z0JBQzNCLFFBQVEsRUFBRSwyQkFBMkI7YUFDdEM7Ozs2QkFFRSxXQUFXLFNBQUMsZ0NBQWdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBIb3N0QmluZGluZyxcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgUmVuZGVyZXIyLFxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuXG5jb25zdCBEQVRBX0JBREVfQVRUUiA9IFwiZGF0YS1iYWRnZVwiO1xuXG5ARGlyZWN0aXZlKHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIHNlbGVjdG9yOiAnW21kbC1iYWRnZV0nXG59KVxuZXhwb3J0IGNsYXNzIE1kbEJhZGdlRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KFwibWRsLWJhZGdlXCIpIHB1YmxpYyBtZGxCYWRnZUNvbnRlbnQ6IHN0cmluZztcblxuICBASG9zdEJpbmRpbmcoXCJjbGFzcy5tZGwtYmFkZ2VcIikgaXNCYWRnZSA9IHRydWU7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBlbDogSFRNTEVsZW1lbnQ7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIpIHtcbiAgICB0aGlzLmVsID0gZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICB9XG5cbiAgcHVibGljIG5nT25DaGFuZ2VzKCk6IHZvaWQge1xuICAgIGlmIChcbiAgICAgIHRoaXMubWRsQmFkZ2VDb250ZW50ID09PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdGhpcy5tZGxCYWRnZUNvbnRlbnQgPT09IFwidW5kZWZpbmVkXCJcbiAgICApIHtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuZWwsIERBVEFfQkFERV9BVFRSKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5lbCwgREFUQV9CQURFX0FUVFIsIHRoaXMubWRsQmFkZ2VDb250ZW50KTtcbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIHNlbGVjdG9yOiAnW21kbC1iYWRnZS1vdmVybGFwXSdcbn0pXG5leHBvcnQgY2xhc3MgTWRsQmFkZ2VPdmVybGFwRGlyZWN0aXZlIHtcbiAgQEhvc3RCaW5kaW5nKFwiY2xhc3MubWRsLWJhZGdlLS1vdmVybGFwXCIpIGlzT3ZlcmxhcHBpbmcgPSB0cnVlO1xufVxuXG5ARGlyZWN0aXZlKHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIHNlbGVjdG9yOiAnW21kbC1iYWRnZS1uby1iYWNrZ3JvdW5kXSdcbn0pXG5leHBvcnQgY2xhc3MgTWRsQmFkZ2VOb0JhY2tncm91bmREaXJlY3RpdmUge1xuICBASG9zdEJpbmRpbmcoXCJjbGFzcy5tZGwtYmFkZ2UtLW5vLWJhY2tncm91bmRcIikgaXNOb0JhY2tncm91bmQgPSB0cnVlO1xufVxuIl19